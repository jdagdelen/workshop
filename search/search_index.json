{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Materials Project Workshop 2020 (July 28 - 30) \u00b6 The Materials Project Workshop is two-day interactive workshop to learn to use th Materials Project (MP) open-source tools. Topics will include basic structure manipulation, querying data from MP using the API, automating DFT calculations, exploring new chemical systems and machine learning. A optional one-day python and MongoDB primer is provided for anyone new to python programming and using databases. We'll also provide a virtual poster-session for anyone interested in networking with other participants. Registration \u00b6 Registration is currently closed. Location \u00b6 The 2020 Materials Project Workshop will be fully virtual due to COVID related travel and congregation restrictions. We'll use a cloud-based python environment to enable interactive tutorials where we provide close support. Primer (optional) \u00b6 All times are in Pacific Daylight Time. Tuesday Morning -- Python/Jupyter Primer \u00b6 09:00-09:20 Intro - Logistics 09:20-10:20 Basics - Variables, Lists, Loops 10:20-10:40 Break 10:40-11:40 Control: Conditions, Funtions, Sets/Dictionaries 11:40-12:00 Open Discussion 12:00-13:00 Lunch Tuesday Afternoon -- MongoDB using Python primer \u00b6 13:00-13:20 Data Modeling - Python Types to JSON to MongoDB 13:20-14:00 Listing, Counting, Finding, and Dot Notation 14:00-14:20 Break 14:20-15:20 Advanced Filtering, Basic Aggregation, and Indexing 15:20-15:40 Open Discussion 15:40-16:00 Wrap-Up Main Workshop \u00b6 All times are in Pacific Daylight Time. Wednesday Morning \u00b6 09:00-09:20 Overview of the Materials Project 09:20-10:20 Using the Website Effectively 10:20-10:40 Break 10:40-11:40 Pymatgen Foundations 11:40-12:00 Open Discussion 12:00-13:00 Lunch Wednesday Afternoon \u00b6 13:00-14:00 Working with Surfaces in Pymatgen 14:00-14:20 Break 14:20-15:20 Using the Materials API 15:20-15:40 Open Discussion 15:40-16:00 Wrap-up Thursday Morning \u00b6 09:00-09:20 Intro 09:20-10:20 Automating DFT 10:20-10:40 Break 10:40-11:40 Exploring New Systems with Pymatgen 11:40-12:00 Open Discussion 12:00-13:00 Lunch Thursday Afternoon \u00b6 13:00-14:00 MPContribs : Share You Data via MPContribs 14:00-14:20 Break 14:20-15:40 Machine Learning with Matminer 15:40-16:00 Wrap-Up Still have questions? \u00b6 If you have any further questions, you can find some more helpful info and confact information here","title":"Home"},{"location":"#materials-project-workshop-2020-july-28-30","text":"The Materials Project Workshop is two-day interactive workshop to learn to use th Materials Project (MP) open-source tools. Topics will include basic structure manipulation, querying data from MP using the API, automating DFT calculations, exploring new chemical systems and machine learning. A optional one-day python and MongoDB primer is provided for anyone new to python programming and using databases. We'll also provide a virtual poster-session for anyone interested in networking with other participants.","title":"Materials Project Workshop 2020 (July 28 - 30)"},{"location":"#registration","text":"Registration is currently closed.","title":"Registration"},{"location":"#location","text":"The 2020 Materials Project Workshop will be fully virtual due to COVID related travel and congregation restrictions. We'll use a cloud-based python environment to enable interactive tutorials where we provide close support.","title":"Location"},{"location":"#primer-optional","text":"All times are in Pacific Daylight Time.","title":"Primer (optional)"},{"location":"#tuesday-morning-pythonjupyter-primer","text":"09:00-09:20 Intro - Logistics 09:20-10:20 Basics - Variables, Lists, Loops 10:20-10:40 Break 10:40-11:40 Control: Conditions, Funtions, Sets/Dictionaries 11:40-12:00 Open Discussion 12:00-13:00 Lunch","title":"Tuesday Morning -- Python/Jupyter Primer"},{"location":"#tuesday-afternoon-mongodb-using-python-primer","text":"13:00-13:20 Data Modeling - Python Types to JSON to MongoDB 13:20-14:00 Listing, Counting, Finding, and Dot Notation 14:00-14:20 Break 14:20-15:20 Advanced Filtering, Basic Aggregation, and Indexing 15:20-15:40 Open Discussion 15:40-16:00 Wrap-Up","title":"Tuesday Afternoon -- MongoDB using Python primer"},{"location":"#main-workshop","text":"All times are in Pacific Daylight Time.","title":"Main Workshop"},{"location":"#wednesday-morning","text":"09:00-09:20 Overview of the Materials Project 09:20-10:20 Using the Website Effectively 10:20-10:40 Break 10:40-11:40 Pymatgen Foundations 11:40-12:00 Open Discussion 12:00-13:00 Lunch","title":"Wednesday Morning"},{"location":"#wednesday-afternoon","text":"13:00-14:00 Working with Surfaces in Pymatgen 14:00-14:20 Break 14:20-15:20 Using the Materials API 15:20-15:40 Open Discussion 15:40-16:00 Wrap-up","title":"Wednesday Afternoon"},{"location":"#thursday-morning","text":"09:00-09:20 Intro 09:20-10:20 Automating DFT 10:20-10:40 Break 10:40-11:40 Exploring New Systems with Pymatgen 11:40-12:00 Open Discussion 12:00-13:00 Lunch","title":"Thursday Morning"},{"location":"#thursday-afternoon","text":"13:00-14:00 MPContribs : Share You Data via MPContribs 14:00-14:20 Break 14:20-15:40 Machine Learning with Matminer 15:40-16:00 Wrap-Up","title":"Thursday Afternoon"},{"location":"#still-have-questions","text":"If you have any further questions, you can find some more helpful info and confact information here","title":"Still have questions?"},{"location":"code_of_conduct/","text":"Code of Conduct \u00b6 This is a Civilized Place for Public Discussion \u00b6 Please treat this workshop with the same respect you would a public park. We, too, are a shared community resource \u2014 a place to share skills, knowledge, and interests through ongoing conversation. These are not hard and fast rules, merely aids to the human judgment of our community. Use these guidelines to keep this a clean, well-lighted place for civilized public discourse. Inclusivity \u00b6 We want to be unequivocal in recognizing that the scientific community has serious issues with representation, with people being excluded or marginalized on the basis of sex, race, and other personal characteristics. There is absolutely no place for sexism, racism, or any other kind of discrimination or prejudice in modern science, and we want to take an active role to ensure our community is a fair, equitable, and welcoming place. Our community is stronger and more effective when it recognizes all voices equally and treats everyone with respect. There will be zero tolerance for harassment and any behavior that is discriminatory on the basis of age, disability, gender, relationship status, maternity, race, ethnicity, religion, sex or sexual orientation, or other personal characteristics. If any such behavior is noticed, members of the workshop are encouraged to let us know so that appropriate action can be taken. Improve the Discussion \u00b6 Help us make this a great place for discussion by always working to improve the discussion in some way, however small. If you are not sure your response adds to the conversation, think over what you want to say and try again later. The topics discussed here matter to us, and we want you to act as if they matter to you, too. Be respectful of the topics and the people discussing them, even if you disagree with some of what is being said. Be Agreeable, Even When You Disagree \u00b6 You may wish to respond to something by disagreeing with it. That\u2019s fine. But, remember to criticize ideas, not people. Please avoid: Name-calling. Ad hominem attacks. Responding to a post\u2019s tone instead of its actual content. Knee-jerk contradiction. Instead, provide reasoned counter-arguments that improve the conversation. Your Participation Counts \u00b6 The conversations we have here set the tone for everyone. Help us influence the future of this community by choosing to engage in discussions that make this workshop an interesting place to be \u2014 and avoiding those that do not. Let\u2019s try to leave our park better than we found it. If You See a Problem, Report It \u00b6 Instructors have special authority; they are responsible for this workshop. But so are you. With your help, moderators can be community facilitators, not just janitors or police. When you see bad behavior, don\u2019t reply. It encourages bad behavior by acknowledging it, consumes your energy, and wastes everyone\u2019s time. Just report it. In order to maintain our community, instructors reserve the right to remove any content and any user account for any reason at any time. Instructors do not preview new attendee material in any way; the instructors and site operators take no responsibility for any content posted by the community. Always Be Civil \u00b6 Nothing sabotages a healthy conversation like rudeness: Be civil . Don\u2019t post anything that a reasonable person would consider offensive, abusive, or hate speech. Keep it clean . Don\u2019t post anything obscene or sexually explicit. Respect each other . Don\u2019t harass or grief anyone, impersonate people, or expose their private information. Respect our workshop . Don\u2019t post spam or otherwise vandalize the Slack. These are not concrete terms with precise definitions \u2014 avoid even the appearance of any of these things. If you\u2019re unsure, ask yourself how you would feel if your post was featured on the front page of the New York Times. Keep the language, links, and images safe for family and friends.","title":"Code of Conduct"},{"location":"code_of_conduct/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"code_of_conduct/#this-is-a-civilized-place-for-public-discussion","text":"Please treat this workshop with the same respect you would a public park. We, too, are a shared community resource \u2014 a place to share skills, knowledge, and interests through ongoing conversation. These are not hard and fast rules, merely aids to the human judgment of our community. Use these guidelines to keep this a clean, well-lighted place for civilized public discourse.","title":"This is a Civilized Place for Public Discussion"},{"location":"code_of_conduct/#inclusivity","text":"We want to be unequivocal in recognizing that the scientific community has serious issues with representation, with people being excluded or marginalized on the basis of sex, race, and other personal characteristics. There is absolutely no place for sexism, racism, or any other kind of discrimination or prejudice in modern science, and we want to take an active role to ensure our community is a fair, equitable, and welcoming place. Our community is stronger and more effective when it recognizes all voices equally and treats everyone with respect. There will be zero tolerance for harassment and any behavior that is discriminatory on the basis of age, disability, gender, relationship status, maternity, race, ethnicity, religion, sex or sexual orientation, or other personal characteristics. If any such behavior is noticed, members of the workshop are encouraged to let us know so that appropriate action can be taken.","title":"Inclusivity"},{"location":"code_of_conduct/#improve-the-discussion","text":"Help us make this a great place for discussion by always working to improve the discussion in some way, however small. If you are not sure your response adds to the conversation, think over what you want to say and try again later. The topics discussed here matter to us, and we want you to act as if they matter to you, too. Be respectful of the topics and the people discussing them, even if you disagree with some of what is being said.","title":"Improve the Discussion"},{"location":"code_of_conduct/#be-agreeable-even-when-you-disagree","text":"You may wish to respond to something by disagreeing with it. That\u2019s fine. But, remember to criticize ideas, not people. Please avoid: Name-calling. Ad hominem attacks. Responding to a post\u2019s tone instead of its actual content. Knee-jerk contradiction. Instead, provide reasoned counter-arguments that improve the conversation.","title":"Be Agreeable, Even When You Disagree"},{"location":"code_of_conduct/#your-participation-counts","text":"The conversations we have here set the tone for everyone. Help us influence the future of this community by choosing to engage in discussions that make this workshop an interesting place to be \u2014 and avoiding those that do not. Let\u2019s try to leave our park better than we found it.","title":"Your Participation Counts"},{"location":"code_of_conduct/#if-you-see-a-problem-report-it","text":"Instructors have special authority; they are responsible for this workshop. But so are you. With your help, moderators can be community facilitators, not just janitors or police. When you see bad behavior, don\u2019t reply. It encourages bad behavior by acknowledging it, consumes your energy, and wastes everyone\u2019s time. Just report it. In order to maintain our community, instructors reserve the right to remove any content and any user account for any reason at any time. Instructors do not preview new attendee material in any way; the instructors and site operators take no responsibility for any content posted by the community.","title":"If You See a Problem, Report It"},{"location":"code_of_conduct/#always-be-civil","text":"Nothing sabotages a healthy conversation like rudeness: Be civil . Don\u2019t post anything that a reasonable person would consider offensive, abusive, or hate speech. Keep it clean . Don\u2019t post anything obscene or sexually explicit. Respect each other . Don\u2019t harass or grief anyone, impersonate people, or expose their private information. Respect our workshop . Don\u2019t post spam or otherwise vandalize the Slack. These are not concrete terms with precise definitions \u2014 avoid even the appearance of any of these things. If you\u2019re unsure, ask yourself how you would feel if your post was featured on the front page of the New York Times. Keep the language, links, and images safe for family and friends.","title":"Always Be Civil"},{"location":"logistics/logistics/","text":"Logistics \u00b6 Before the Workshop \u00b6 Virtual Poster-Session \u00b6 We'll host a virtual poster-session via a YouTube video for lightning summaries and a FigShare repository with associated DOI for citation. Please email : your poster PDF a 1-minute lighting video explaining the main concept behind your poster. This shouldn't be detailed summary of your work, but rather a high-level description that everyone can listen to and then decide which posters they want to focus on such as an elevator-pitch. We'll host the lightning-videos on our YouTube Channel and publish the PDFs on FigShare with a DOI that everyone can cite for this poster session. Setup Instructions \u00b6 Sign in to your MP account online. Register for an account first if needed. Sign in to an account on CoCalc using the same email address you registered with. This will be the online python service we'll use to work interactively. If you don't use the email you registered for the workshop with to register on CoCalc.com, please send me an email so that I know. We'll use CoCalc as an interactive python environment where you can code alongside the lessons, work on exercises, and get live-help and feedback from our helpers. Lesson Format \u00b6 Lessons will be broadcast via Zoom with live audio + screencast from the instructor. You won't need a microphone or camera. Please make sure audio works via Zoom. We'll use CoCalc for all our collaborative work. An in-notebook chat will allow attendees to ask for help. Instructors and helpers will be able We'll set up a Slack channel for group chat. This will allow attendees to ask general questions and chat amongst each other as well. Finding your API Key: \u00b6 An important aspect of the Materials Project API is the use of API keys to ensure we can control the amount of traffic that comes to the API. Otherwise, it's very easy for someone to take down the MP servers, making them unavailable for anyone. Your API key can be accessed via the Dashboard: Login to your Materials Project account and find the dashboard in the top right hand corner Your API is displayed in the middle under the Generate API Key button. Keep this to yourself. You can reset your API key at any time. Finding your MPContribs API Key: \u00b6 Currently the API key for MPContribs is separate from Materials Project. In order to get your MPContribs API key. Login to portal.mpcontribs.org Hover over the More drop-down in the top right hand corner Click the API Key button to copy your API key to your clipboard. You can now paste this into your notebook during the MPContribs lesson. During the Workshop \u00b6 Start of the Day Instructions \u00b6 Sign in to CoCalc Sign in to the Zoom Link Sign in to the MP Workshop slack Lesson Format \u00b6 The lessons will be taught in 20-minute sessions as 10-minutes of lesson followed by 10-minutes of a hands-on exercise. You're welcome to follow along with the already filled in hand-out notebook or by typing in to an empty notebook as we go along in the lesson. If you need help \u00b6 Click the chat icon at the top right corner your CoCalc browser window. Type in a message in the new chat window followed by Shift + Enter to send the message and our helpers will be notified. If you have a General Question \u00b6 Feel free to ask a question in the MP Workshop Slack #workshop2020 channel","title":"Logistics"},{"location":"logistics/logistics/#logistics","text":"","title":"Logistics"},{"location":"logistics/logistics/#before-the-workshop","text":"","title":"Before the Workshop"},{"location":"logistics/logistics/#virtual-poster-session","text":"We'll host a virtual poster-session via a YouTube video for lightning summaries and a FigShare repository with associated DOI for citation. Please email : your poster PDF a 1-minute lighting video explaining the main concept behind your poster. This shouldn't be detailed summary of your work, but rather a high-level description that everyone can listen to and then decide which posters they want to focus on such as an elevator-pitch. We'll host the lightning-videos on our YouTube Channel and publish the PDFs on FigShare with a DOI that everyone can cite for this poster session.","title":"Virtual Poster-Session"},{"location":"logistics/logistics/#setup-instructions","text":"Sign in to your MP account online. Register for an account first if needed. Sign in to an account on CoCalc using the same email address you registered with. This will be the online python service we'll use to work interactively. If you don't use the email you registered for the workshop with to register on CoCalc.com, please send me an email so that I know. We'll use CoCalc as an interactive python environment where you can code alongside the lessons, work on exercises, and get live-help and feedback from our helpers.","title":"Setup Instructions"},{"location":"logistics/logistics/#lesson-format","text":"Lessons will be broadcast via Zoom with live audio + screencast from the instructor. You won't need a microphone or camera. Please make sure audio works via Zoom. We'll use CoCalc for all our collaborative work. An in-notebook chat will allow attendees to ask for help. Instructors and helpers will be able We'll set up a Slack channel for group chat. This will allow attendees to ask general questions and chat amongst each other as well.","title":"Lesson Format"},{"location":"logistics/logistics/#finding-your-api-key","text":"An important aspect of the Materials Project API is the use of API keys to ensure we can control the amount of traffic that comes to the API. Otherwise, it's very easy for someone to take down the MP servers, making them unavailable for anyone. Your API key can be accessed via the Dashboard: Login to your Materials Project account and find the dashboard in the top right hand corner Your API is displayed in the middle under the Generate API Key button. Keep this to yourself. You can reset your API key at any time.","title":"Finding your API Key:"},{"location":"logistics/logistics/#finding-your-mpcontribs-api-key","text":"Currently the API key for MPContribs is separate from Materials Project. In order to get your MPContribs API key. Login to portal.mpcontribs.org Hover over the More drop-down in the top right hand corner Click the API Key button to copy your API key to your clipboard. You can now paste this into your notebook during the MPContribs lesson.","title":"Finding your MPContribs API Key:"},{"location":"logistics/logistics/#during-the-workshop","text":"","title":"During the Workshop"},{"location":"logistics/logistics/#start-of-the-day-instructions","text":"Sign in to CoCalc Sign in to the Zoom Link Sign in to the MP Workshop slack","title":"Start of the Day Instructions"},{"location":"logistics/logistics/#lesson-format_1","text":"The lessons will be taught in 20-minute sessions as 10-minutes of lesson followed by 10-minutes of a hands-on exercise. You're welcome to follow along with the already filled in hand-out notebook or by typing in to an empty notebook as we go along in the lesson.","title":"Lesson Format"},{"location":"logistics/logistics/#if-you-need-help","text":"Click the chat icon at the top right corner your CoCalc browser window. Type in a message in the new chat window followed by Shift + Enter to send the message and our helpers will be notified.","title":"If you need help"},{"location":"logistics/logistics/#if-you-have-a-general-question","text":"Feel free to ask a question in the MP Workshop Slack #workshop2020 channel","title":"If you have a General Question"},{"location":"materials_api/MAPI%20Exercise%201/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Materials API - Exercise 1 \u00b6 In this excercise, your task is to plot the distribution of crystal systems (cubic, tetragonal, monoclinic, etc) within all SiO _2 _2 compounds. You will do this through the following 3 steps: Retrieve the spacegroup entries in the MP database with the formula SiO _2 _2 Collect their crystal systems Plot a bar chart with the data Step 1: Retrieve the spacegroup entries in the MP database with the formula SiO _2 _2 \u00b6 Use the Materials API to get the \"structure\" property for all SiO _2 _2 compounds. Hint: use the query method of the MPRester . # Your code here Step 2: Extract the crystal_system property for the entries we retrieved into a list \u00b6 Hint: \"crystal_system\" is a subkey of the spacegroup property. # Your code here Step 3: Process the data and plot the results \u00b6 Our data is currently a list of crystal systems. Your task now is to create a \"count_dict\" where each key is the name of the crystal system and it's value is the count for that crystal system. Once you have written code to create count_dict , you the cell beneath it will plot the data for you. Hint: Iterate through the list of crystal_systems you just created using a for loop and check if they are already in the dictionary before updating any entries. count_dict = {} # Your code here import matplotlib.pyplot as plt % matplotlib inline # The code below plots the distribution plt . bar ( range ( len ( count_dict )), count_dict . values (), align = 'center' ) plt . xticks ( range ( len ( count_dict )), [ key [ 0 : 5 ] for key in list ( count_dict . keys ())]) plt . title ( 'Distribution of crystal systems within SiO2 compounds' ) plt . show ()","title":"MAPI Exercise 1"},{"location":"materials_api/MAPI%20Exercise%201/#materials-api-exercise-1","text":"In this excercise, your task is to plot the distribution of crystal systems (cubic, tetragonal, monoclinic, etc) within all SiO _2 _2 compounds. You will do this through the following 3 steps: Retrieve the spacegroup entries in the MP database with the formula SiO _2 _2 Collect their crystal systems Plot a bar chart with the data","title":"Materials API - Exercise 1"},{"location":"materials_api/MAPI%20Exercise%201/#step-1-retrieve-the-spacegroup-entries-in-the-mp-database-with-the-formula-sio_2_2","text":"Use the Materials API to get the \"structure\" property for all SiO _2 _2 compounds. Hint: use the query method of the MPRester . # Your code here","title":"Step 1: Retrieve the spacegroup entries in the MP database with the formula SiO_2_2"},{"location":"materials_api/MAPI%20Exercise%201/#step-2-extract-the-crystal_system-property-for-the-entries-we-retrieved-into-a-list","text":"Hint: \"crystal_system\" is a subkey of the spacegroup property. # Your code here","title":"Step 2: Extract the crystal_system property for the entries we retrieved into a list"},{"location":"materials_api/MAPI%20Exercise%201/#step-3-process-the-data-and-plot-the-results","text":"Our data is currently a list of crystal systems. Your task now is to create a \"count_dict\" where each key is the name of the crystal system and it's value is the count for that crystal system. Once you have written code to create count_dict , you the cell beneath it will plot the data for you. Hint: Iterate through the list of crystal_systems you just created using a for loop and check if they are already in the dictionary before updating any entries. count_dict = {} # Your code here import matplotlib.pyplot as plt % matplotlib inline # The code below plots the distribution plt . bar ( range ( len ( count_dict )), count_dict . values (), align = 'center' ) plt . xticks ( range ( len ( count_dict )), [ key [ 0 : 5 ] for key in list ( count_dict . keys ())]) plt . title ( 'Distribution of crystal systems within SiO2 compounds' ) plt . show ()","title":"Step 3: Process the data and plot the results"},{"location":"materials_api/MAPI%20Exercise%202/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Materials API - Exercise 2: Using the MPRester and Pymatgen to Find Materials With Exotic Mechanical Properties \u00b6 The tetragonal SiO _2 _2 polymorph \\alpha \\alpha -cristobalite is one of the very few crystalline materials known to have a negative average Poisson's ratio, which means that its cross-section expands under tensile strain rather than contracting. This property can be extremely useful in a variety of applications such as scratch-resistant coatings and high-toughness ceramics. Why does \\alpha \\alpha -cristobalite exhibit this property while other materials do not? The prevailing hypothesis is that \\alpha \\alpha -cristobalite's negative Poisson's ratio is a result of its crystal structure. If that's the case, then perhaps we can find other materials with this exotic property by looking for materials with similar structures and then calculating their Poisson's ratios. Step 1: Retrieve the structure of \\alpha \\alpha -cristobalite \u00b6 First, we should find the ground state structure for \\alpha \\alpha -cristobalite, which has the spacegroup P4_12_12 P4_12_12 [92]. Remember, stable materials have low energy above hull ( e_above_hull ). Hint: Query for the formula and spacegroup for the desired compound and then select the one with the lowest e_above_hull if there are multiple results. ac_structure = < YOUR CODE HERE > Step 2: Build a structure comparison engine and test it out \u00b6 The code below creates a structure matcher object that can be used to compare if two structures are simlar (loose tolerances = similar, tight tolerances = identical). Please verify that the structure matcher works for identical structure by comparing the structure of AC with itself. Hint: Replace with the two structures you want to compare, separated by a comma. ##### Don't edit code below ##### from pymatgen.analysis.structure_matcher import StructureMatcher from pymatgen.analysis.structure_matcher import FrameworkComparator # This line initializes our comparator. Please don't play with its tolerances until after you are done comparison_engine = StructureMatcher ( ltol =. 2 , stol =. 5 , angle_tol = 10 , primitive_cell = True , scale = True , attempt_supercell = True , comparator = FrameworkComparator ()) ##### Don't edit code above ##### print ( sm . fit ( < YOUR CODE HERE > )) We know that the high-temperature phase of cristobalite, \\beta \\beta -cristobalite (mp-546794) , has a very similar structure to \\alpha \\alpha -cristobalite. Let's see if the structure matcher agrees. Please retreive the structure for mp-546794 and then compare it with our prototype structure. Hint: No need to re-initialize the structure matcher. Just call it's fit function again. # Your code here Just to make sure we haven't increased the tolerances too much, please try it against a random compound to make sure it's not matching dissimilar structures. Hint: \"mp-4991\" is a good random MPID you can use # Your code here Step 3: Get a set of candidate structures to compare \u00b6 Now that we have our comparator, we need some candidates to screen! Imagine that we have an experimental colleague, Soren Tsarpinski, who is an expert at synthesizing vanadate compounds. We have a hunch that some of the vanadates coming out of Dr. Tsarpinski's lab might have similar structures to \\alpha \\alpha -cristobalite and therefore might have negative Poisson's ratios. Let's see if we're right: For our search, we want to start with a set of structures that are: * Computationally tractable, so not too many sites (i.e nsites <50 is a good number) * Not too unlikely to be synthesizable (energy above hull <100 meV, i.e. {e_above_hull: {\"$lt\": 0.1} ) * Have a \"vanadate\" composition, i.e. \"*V3O8\" Construct and execute a query to get the structure, MPID, and pretty_formula for all materials that match these criteria: Aside; Soren Tsarpinski is an anagram. There is a prize for the first workshop atendee that can guess the original phrase it comes from. (Submit your anwswers on Slack, please.) # Your code here Step 4: Screen the vanadates for similar structures to \\alpha \\alpha -cristobalite and then check if our hypothesis is valid by querying for their Poisson's ratios. \u00b6 Now that we have a list of vanadates, let's screen it for similar structures. After we have the similar structures, make one final query to the Materials API to retrieve the pretty_formula and elasticity.homogenious_poisson property for each one. Hint: Create an empty list for matches and then iterate through the vanadate entries with a for loop. If its structure is similar to \\alpha \\alpha -cristobalite, append its material_id to a list of matches. After you have a match list, query the Materials API for entries with a material_id that is in your matches list using the $in mongodb operator (e.g {\"material_id\": {\"$in$: matches}} ) # Your code here","title":"MAPI Exercise 2"},{"location":"materials_api/MAPI%20Exercise%202/#materials-api-exercise-2-using-the-mprester-and-pymatgen-to-find-materials-with-exotic-mechanical-properties","text":"The tetragonal SiO _2 _2 polymorph \\alpha \\alpha -cristobalite is one of the very few crystalline materials known to have a negative average Poisson's ratio, which means that its cross-section expands under tensile strain rather than contracting. This property can be extremely useful in a variety of applications such as scratch-resistant coatings and high-toughness ceramics. Why does \\alpha \\alpha -cristobalite exhibit this property while other materials do not? The prevailing hypothesis is that \\alpha \\alpha -cristobalite's negative Poisson's ratio is a result of its crystal structure. If that's the case, then perhaps we can find other materials with this exotic property by looking for materials with similar structures and then calculating their Poisson's ratios.","title":"Materials API - Exercise 2: Using the MPRester and Pymatgen to Find Materials With Exotic Mechanical Properties"},{"location":"materials_api/MAPI%20Exercise%202/#step-1-retrieve-the-structure-of-alphaalpha-cristobalite","text":"First, we should find the ground state structure for \\alpha \\alpha -cristobalite, which has the spacegroup P4_12_12 P4_12_12 [92]. Remember, stable materials have low energy above hull ( e_above_hull ). Hint: Query for the formula and spacegroup for the desired compound and then select the one with the lowest e_above_hull if there are multiple results. ac_structure = < YOUR CODE HERE >","title":"Step 1: Retrieve the structure of \\alpha\\alpha-cristobalite"},{"location":"materials_api/MAPI%20Exercise%202/#step-2-build-a-structure-comparison-engine-and-test-it-out","text":"The code below creates a structure matcher object that can be used to compare if two structures are simlar (loose tolerances = similar, tight tolerances = identical). Please verify that the structure matcher works for identical structure by comparing the structure of AC with itself. Hint: Replace with the two structures you want to compare, separated by a comma. ##### Don't edit code below ##### from pymatgen.analysis.structure_matcher import StructureMatcher from pymatgen.analysis.structure_matcher import FrameworkComparator # This line initializes our comparator. Please don't play with its tolerances until after you are done comparison_engine = StructureMatcher ( ltol =. 2 , stol =. 5 , angle_tol = 10 , primitive_cell = True , scale = True , attempt_supercell = True , comparator = FrameworkComparator ()) ##### Don't edit code above ##### print ( sm . fit ( < YOUR CODE HERE > )) We know that the high-temperature phase of cristobalite, \\beta \\beta -cristobalite (mp-546794) , has a very similar structure to \\alpha \\alpha -cristobalite. Let's see if the structure matcher agrees. Please retreive the structure for mp-546794 and then compare it with our prototype structure. Hint: No need to re-initialize the structure matcher. Just call it's fit function again. # Your code here Just to make sure we haven't increased the tolerances too much, please try it against a random compound to make sure it's not matching dissimilar structures. Hint: \"mp-4991\" is a good random MPID you can use # Your code here","title":"Step 2: Build a structure comparison engine and test it out"},{"location":"materials_api/MAPI%20Exercise%202/#step-3-get-a-set-of-candidate-structures-to-compare","text":"Now that we have our comparator, we need some candidates to screen! Imagine that we have an experimental colleague, Soren Tsarpinski, who is an expert at synthesizing vanadate compounds. We have a hunch that some of the vanadates coming out of Dr. Tsarpinski's lab might have similar structures to \\alpha \\alpha -cristobalite and therefore might have negative Poisson's ratios. Let's see if we're right: For our search, we want to start with a set of structures that are: * Computationally tractable, so not too many sites (i.e nsites <50 is a good number) * Not too unlikely to be synthesizable (energy above hull <100 meV, i.e. {e_above_hull: {\"$lt\": 0.1} ) * Have a \"vanadate\" composition, i.e. \"*V3O8\" Construct and execute a query to get the structure, MPID, and pretty_formula for all materials that match these criteria: Aside; Soren Tsarpinski is an anagram. There is a prize for the first workshop atendee that can guess the original phrase it comes from. (Submit your anwswers on Slack, please.) # Your code here","title":"Step 3: Get a set of candidate structures to compare"},{"location":"materials_api/MAPI%20Exercise%202/#step-4-screen-the-vanadates-for-similar-structures-to-alphaalpha-cristobalite-and-then-check-if-our-hypothesis-is-valid-by-querying-for-their-poissons-ratios","text":"Now that we have a list of vanadates, let's screen it for similar structures. After we have the similar structures, make one final query to the Materials API to retrieve the pretty_formula and elasticity.homogenious_poisson property for each one. Hint: Create an empty list for matches and then iterate through the vanadate entries with a for loop. If its structure is similar to \\alpha \\alpha -cristobalite, append its material_id to a list of matches. After you have a match list, query the Materials API for entries with a material_id that is in your matches list using the $in mongodb operator (e.g {\"material_id\": {\"$in$: matches}} ) # Your code here","title":"Step 4: Screen the vanadates for similar structures to \\alpha\\alpha-cristobalite and then check if our hypothesis is valid by querying for their Poisson's ratios."},{"location":"materials_api/api_use/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); The Materials API \u00b6 Presented by: John Dagdelen \u00b6 In this lesson, we cover: * The Materials Project API (MAPI) and its documentation, the mapidoc . * Getting your Materials Project API key. * Using the MPRester to access the MP database. * A hands-on example of using the API and pymatgen to screen the MP database for interesting materials. # This supresses warnings. import warnings warnings . filterwarnings ( 'ignore' ) # This is a helper function to shorten lists during the # live presentation of this lesson for better readability. # You can ignore it. def shortlist ( long_list , n = 5 ): print ( \"First {} of {} items:\" . format ( min ( n , 5 ), len ( long_list ))) for item in long_list [ 0 : n ]: print ( item ) Section 0: Getting an API key \u00b6 The first step to getting started with the API is to get an API key. We do this on the Materials Project website (https://materialsproject.org/dashboard.) Click the Generate API key button copy your shiny new key Paste your key in the line below and run the cell. ! pmg config -- add PMG_MAPI_KEY < your API key > Existing /Users/jdagdelen/.pmgrc.yaml backed up to /Users/jdagdelen/.pmgrc.yaml.bak New /Users/jdagdelen/.pmgrc.yaml written! Section 1: The MAPIDOC \u00b6 The mapidoc is a key source of information regarding the Materials Project API. It should be the first thing you consult whenever you are having trouble with the API. Let's take a look! Section 2: Basic Queries In the Web Browser \u00b6 To request data from the Materials Project, you will need to make requests to our API. To do this, you could simply make a GET request through your web browser, providing your API key as an argument. For example, https://www.materialsproject.org/rest/v2/materials/mp-1234/vasp?API_KEY=<your api key> For example, https://www.materialsproject.org/rest/v2/materials/mp-1234/vasp?API_KEY=<your api key> returns the following JSON document: {\"response\": [{\"energy\": -26.94573468, \"energy_per_atom\": -4.49095578, \"volume\": 116.92375473740876, \"formation_energy_per_atom\": -0.4835973866666663, \"nsites\": 6, \"unit_cell_formula\": {\"Al\": 4.0, \"Lu\": 2.0}, \"pretty_formula\": \"LuAl2\", \"is_hubbard\": false, \"elements\": [\"Al\", \"Lu\"], \"nelements\": 2, \"e_above_hull\": 0, \"hubbards\": {}, \"is_compatible\": true, \"spacegroup\": {\"source\": \"spglib\", \"symbol\": \"Fd-3m\", \"number\": 227, \"point_group\": \"m-3m\", \"crystal_system\": \"cubic\", \"hall\": \"F 4d 2 3 -1d\"}, \"task_ids\": [\"mp-1234\", \"mp-925833\", \"mp-940234\", \"mp-940654\"], \"band_gap\": 0.0, \"density\": 6.502482433523648, \"icsd_id\": null, \"icsd_ids\": [608375, 57958, 608376, 608372, 608371, 608370], \"cif\": \"# generated using pymatgen\\ndata_LuAl2\\n_symmetry_space_group_name_H-M 'P 1'\\n_cell_length_a 5.48873905\\n_cell_length_b 5.48873905\\n_cell_length_c 5.48873905\\n_cell_angle_alpha 60.00000005\\n_cell_angle_beta 60.00000003\\n_cell_angle_gamma 60.00000007\\n_symmetry_Int_Tables_number 1\\n_chemical_formula_structural LuAl2\\n_chemical_formula_sum 'Lu2 Al4'\\n_cell_volume 116.92375474\\n_cell_formula_units_Z 2\\nloop_\\n _symmetry_equiv_pos_site_id\\n _symmetry_equiv_pos_as_xyz\\n 1 'x, y, z'\\nloop_\\n _atom_site_type_symbol\\n _atom_site_label\\n _atom_site_symmetry_multiplicity\\n _atom_site_fract_x\\n _atom_site_fract_y\\n _atom_site_fract_z\\n _atom_site_occupancy\\n Al Al1 1 0.500000 0.500000 0.500000 1\\n Al Al2 1 0.500000 0.500000 0.000000 1\\n Al Al3 1 0.000000 0.500000 0.500000 1\\n Al Al4 1 0.500000 0.000000 0.500000 1\\n Lu Lu5 1 0.875000 0.875000 0.875000 1\\n Lu Lu6 1 0.125000 0.125000 0.125000 1\\n\", \"total_magnetization\": 0.0012519, \"material_id\": \"mp-1234\", \"oxide_type\": \"None\", \"tags\": [\"High pressure experimental phase\", \"Aluminium lutetium (2/1)\"], \"elasticity\": null, \"full_formula\": \"Lu2Al4\"}], \"valid_response\": true, \"created_at\": \"2018-08-08T18:52:53.042666\", \"version\": {\"db\": \"3.0.0\", \"pymatgen\": \"2018.7.23\", \"rest\": \"2.0\"}, \"copyright\": \"Materials Project, 2018\"} For obvious reasons, typing these kinds of urls into your web browser is not an ideal way to request MP data. Instead, we should try to access the API programatically with python. Let's do the same request that we did above using Python's requests library. Making Requests With Python \u00b6 import requests response = requests . get ( \"https://www.materialsproject.org/rest/v2/materials/mp-1234/vasp\" , { \"API_KEY\" : \"<your API key>\" }) print ( response . text ) Section 3: The MPRester \u00b6 In this section we will: Open the pymatgen.MPRester web documentation. Create our first instance of an MPRester object. Get our feet wet with calling a few of the MPRester's \"specialty\" methods. Background and Documentation \u00b6 Code connects to the MP Database through REST requests. Pymatgen's MPRester class is helpful for accessing our API in python. The documentation for the MPRester is very helpful. Let's take a look! Background and Documentation \u00b6 REST is a widely used type of standardization that allows different computer systems to work together. In RESTful systems, information is organized into resources, each of which is uniquely identified via a uniform resource identifier (URI). Since MAPI is a RESTful system, users can interact with the MP database regardless of their computer system or programming language (as long as it supports basic http requests.) To facilitate researchers in using our API, we implemented a convenient wrapper for it in the Python Materials Genomics (pymatgen) library called the MPRester . You can find the relevant pymatgen documentation for it here . Starting up an instance of the MPRester \u00b6 We'll import the MPRester and create an instance of it. Note: You may need to use your API key as an input argument if it has not been pre-configured. from pymatgen import MPRester mpr = MPRester () print ( mpr . supported_properties ) ('energy', 'energy_per_atom', 'volume', 'formation_energy_per_atom', 'nsites', 'unit_cell_formula', 'pretty_formula', 'is_hubbard', 'elements', 'nelements', 'e_above_hull', 'hubbards', 'is_compatible', 'spacegroup', 'task_ids', 'band_gap', 'density', 'icsd_id', 'icsd_ids', 'cif', 'total_magnetization', 'material_id', 'oxide_type', 'tags', 'elasticity') However, we recommend that you use the \u201cwith\u201d context manager to ensure that sessions are properly closed after usage: with MPRester () as mpr : print ( mpr . supported_properties ) ('energy', 'energy_per_atom', 'volume', 'formation_energy_per_atom', 'nsites', 'unit_cell_formula', 'pretty_formula', 'is_hubbard', 'elements', 'nelements', 'e_above_hull', 'hubbards', 'is_compatible', 'spacegroup', 'task_ids', 'band_gap', 'density', 'icsd_id', 'icsd_ids', 'cif', 'total_magnetization', 'material_id', 'oxide_type', 'tags', 'elasticity') MPRester Methods: \u00b6 The MPRester has many methods that you might want to use in your research. For example, there is a method to get the bandstructure for a material, get_bandstructure_by_material_id . Let's use this method and the following bandstructure plotting function to get and plot a bandstructure for mp-1234: ### Don't edit this code #### from pymatgen.electronic_structure.plotter import BSPlotter # Helpful function for plotting a bandstructure. def plot_bandstructure ( bs ): BSPlotter ( bs ) . get_plot () . show () ############################# # Excercise: Use the MPRester's get_bandstructure_by_material_id method to # get a bandstructure from the MP Database and plot it using the # plot_bandstructure functin defined above. with MPRester () as mpr : bs = mpr . get_bandstructure_by_material_id ( \"mp-1234\" ) plot_bandstructure ( bs ) There's also a method to get MPIDs for a formula or chemical system called get_materials_ids . with MPRester () as mpr : # You can pass in a formula to get_materials_ids shortlist ( mpr . get_materials_ids ( \"LiFePO4\" )) # Or you can pass in a \"chemsys\" such as \"Li-Fe-P-O\" shortlist ( mpr . get_materials_ids ( \"Li-Fe-P-O\" )) First 5 of 67 items: mp-765593 mp-757182 mp-1662030 mp-772409 mp-765604 First 5 of 908 items: mp-1245108 mp-1271693 mp-1194030 mp-1271562 mp-136 Using the API to achieve research goals: \u00b6 Imagine you want to get the structure for the multiferroic material BiFeO3 ( mp-24932 ) and suggest some substrates for growing it. We can use methods of the MPRester to get this information from the Materials Project API. Hints: * MPRester.get_structure_by_material_id * MPRester.get_substrates # Get the structure for BiFeO3 (mp-23501) and # suggest some substrates for growing it. with MPRester () as mpr : structure = mpr . get_structure_by_material_id ( \"mp-23501\" ) substrates = mpr . get_substrates ( \"mp-23501\" ) print ( structure ) print ([ s [ \"sub_form\" ] for s in substrates ]) Full Formula (Fe2 Bi2 O6) Reduced Formula: FeBiO3 abc : 5.615643 5.615629 5.705140 angles: 60.510834 119.489364 120.001015 Sites (10) # SP a b c magmom --- ---- -------- -------- -------- -------- 0 Fe 0.219028 0.780969 0.657065 -4.256 1 Fe 0.719032 0.28097 0.15707 4.256 2 Bi 0.498595 0.501425 0.495716 -0.001 3 Bi 0.998575 0.001404 0.995717 0.001 4 O 0.436045 0.111857 0.359395 0.034 5 O 0.035218 0.563986 0.359413 0.034 6 O 0.888122 0.964774 0.359409 0.034 7 O 0.388142 0.063955 0.859394 -0.034 8 O 0.535228 0.61188 0.859409 -0.034 9 O 0.936013 0.46478 0.859414 -0.034 ['AlN', 'LaAlO3', 'LiGaO2', 'WS2', 'MoS2', 'C', 'TbScO3', 'MgF2', 'NdGaO3', 'BaTiO3', 'Ag', 'C', 'DyScO3', 'GdScO3', 'Mg', 'LiAlO2', 'Au', 'BaTiO3', 'AlN', 'TiO2', 'ZnO', 'NaCl', 'MgF2', 'Bi2Te3', 'SrTiO3', 'KTaO3', 'GaN', 'NaCl', 'Al', 'C', 'ZnO', 'TeO2', 'Ni', 'C', 'SrTiO3', 'GaN', 'TiO2', 'DyScO3', 'Te2W', 'GdScO3', 'SiC', 'BaTiO3', 'ZnSe', 'SiC', 'WS2', 'WS2', 'ZnO', 'WS2', 'MoS2', 'MoS2'] At this point, you should be comfortable with: Finding documentation on the MPRester. Creating an instance of the MPRester. Using methods of the MPRester. Section 4: Using the MPRester.query method. \u00b6 The MPRester also has a very powerful method called query , which allows us to perform sophisticated searches on the database. The query method uses MongoDB's query syntax . In this syntax, query submissions have two parts: a set of criteria that you want to base the search on (in the form of a python dict), and a set of properties that you want the database to return (in the form of either a list or dict). You will probably find yourself using the MPRester's query method frequently. The general structure of a MPRester query is: mpr.query(criteria, properties) The general structure of a MPRester query is: mpr.query(criteria, properties) criteria is usually a string or a dict. properties is always a list of strings Let's try out some queries to learn how it works! First, we'll query for SiO_2 SiO_2 compounds by chemical formula through 'pretty_formula'. with MPRester () as mpr : results = mpr . query ({ 'pretty_formula' : \"SiO2\" }, properties = [ 'material_id' , 'pretty_formula' ]) print ( len ( results )) If we investigate the object that the query method returns, we find that it is a list of dicts. Furthermore, we find that the keys of the dictionaries are the very same keywords that we passed to the query method as the properties argument. print ( 'Results are returned as a {} of {} . \\n ' . format ( type ( results ), type ( results [ 0 ]))) for r in results [ 0 : 5 ]: print ( r ) In fact, if you are just looking for materials based on formula/composition/stoichiometry, there is an easier way to use the query method: just pass in a string as the criteria! You can even use wildcard characters in your searches. For example, if we want to find all ABO_3 ABO_3 compounds in the Materials Project: with MPRester () as mpr : results = mpr . query ( '**O3' , properties = [ \"material_id\" , \"pretty_formula\" ]) shortlist ( results ) Putting it into practice: \u00b6 There are 296 variants of SiO_2 SiO_2 in the MP database, but how many Si_xO_y Si_xO_y compounds are there in the Materials Project? Hint: * Query using a chemsys string instead of a formula. with MPRester () as mpr : print ( len ( mpr . query ( \"Si-O\" , [ \"material_id\" ]))) 331 EXCERCISE 1 \u00b6 MongoDB Operators \u00b6 Above, we specified the chemical formula SiO _2 _2 for our query. This is an example of, the \"specify\" operator. However, MongoDB's syntax also includes other query operators , allowing us to bulid complex conditionals into our queries. These all start with the \"$\" character. Some important MongoDB operators you should be familiar with are: * $in (in) * $ nin ( not in ) * $ gt ( greater than ) * $ gte ( greater than or equal to ) * $ lt ( less than ) * $ lte ( less than or equal to ) * $ not ( is not ) We used these more advanced operators as follows: {\"field_name\": {\"$op\": value}} For example, \"entries with e_above_hull that is less than 0.25 eV\" would be: {\"e_above_hull\": {\"$lt\": 0.25}} A paper by McEnany et. al. proposes a novel ammonia synthesis process based on the electrochemical cycling of lithium ( link ). As an exercise, let's use some of MongoDB's operators and ask the database for nitrides of alkali metals. # Find all nitrides of alkali metals alkali_metals = [ 'Li' , 'Na' , 'K' , 'Rb' , 'Cs' ] criteria = { \"elements\" :{ \"$in\" : alkali_metals , \"$all\" : [ \"N\" ]}, \"nelements\" : 2 } properties = [ 'material_id' , 'pretty_formula' ] shortlist ( mpr . query ( criteria , properties )) #Bonus short way to do this with wildcards shortlist ( mpr . query ( '{Li,Na,K,Rb,Cs}-N' , [ 'material_id' , 'pretty_formula' ])) We can also perform the same query, but ask the database to only return compounds with energies above the hull less than 10 meV/atom by using the \"less than\" operator, \" $lt \". (The energy above the convex hull gives us a sense of how stable a compound is relative to other compounds with the same composition.) criteria = { \"elements\" :{ \"$in\" : alkali_metals , \"$all\" :[ \"N\" ]}, \"nelements\" : 2 , 'e_above_hull' :{ \"$lt\" : 0.010 }} properties = [ 'material_id' , 'pretty_formula' ] mpr . query ( criteria , properties ) In this lesson, we have covered: * The Materials Project API (MAPI) and its documentation, the mapidoc . * Getting your Materials Project API key. * Using the MPRester to access the MP database. * Hands-on examples of using the API and pymatgen to screen the MP database for interesting materials.","title":"Api use"},{"location":"materials_api/api_use/#the-materials-api","text":"","title":"The Materials API"},{"location":"materials_api/api_use/#presented-by-john-dagdelen","text":"In this lesson, we cover: * The Materials Project API (MAPI) and its documentation, the mapidoc . * Getting your Materials Project API key. * Using the MPRester to access the MP database. * A hands-on example of using the API and pymatgen to screen the MP database for interesting materials. # This supresses warnings. import warnings warnings . filterwarnings ( 'ignore' ) # This is a helper function to shorten lists during the # live presentation of this lesson for better readability. # You can ignore it. def shortlist ( long_list , n = 5 ): print ( \"First {} of {} items:\" . format ( min ( n , 5 ), len ( long_list ))) for item in long_list [ 0 : n ]: print ( item )","title":"Presented by: John Dagdelen"},{"location":"materials_api/api_use/#section-0-getting-an-api-key","text":"The first step to getting started with the API is to get an API key. We do this on the Materials Project website (https://materialsproject.org/dashboard.) Click the Generate API key button copy your shiny new key Paste your key in the line below and run the cell. ! pmg config -- add PMG_MAPI_KEY < your API key > Existing /Users/jdagdelen/.pmgrc.yaml backed up to /Users/jdagdelen/.pmgrc.yaml.bak New /Users/jdagdelen/.pmgrc.yaml written!","title":"Section 0: Getting an API key"},{"location":"materials_api/api_use/#section-1-the-mapidoc","text":"The mapidoc is a key source of information regarding the Materials Project API. It should be the first thing you consult whenever you are having trouble with the API. Let's take a look!","title":"Section 1: The MAPIDOC"},{"location":"materials_api/api_use/#section-2-basic-queries-in-the-web-browser","text":"To request data from the Materials Project, you will need to make requests to our API. To do this, you could simply make a GET request through your web browser, providing your API key as an argument. For example, https://www.materialsproject.org/rest/v2/materials/mp-1234/vasp?API_KEY=<your api key> For example, https://www.materialsproject.org/rest/v2/materials/mp-1234/vasp?API_KEY=<your api key> returns the following JSON document: {\"response\": [{\"energy\": -26.94573468, \"energy_per_atom\": -4.49095578, \"volume\": 116.92375473740876, \"formation_energy_per_atom\": -0.4835973866666663, \"nsites\": 6, \"unit_cell_formula\": {\"Al\": 4.0, \"Lu\": 2.0}, \"pretty_formula\": \"LuAl2\", \"is_hubbard\": false, \"elements\": [\"Al\", \"Lu\"], \"nelements\": 2, \"e_above_hull\": 0, \"hubbards\": {}, \"is_compatible\": true, \"spacegroup\": {\"source\": \"spglib\", \"symbol\": \"Fd-3m\", \"number\": 227, \"point_group\": \"m-3m\", \"crystal_system\": \"cubic\", \"hall\": \"F 4d 2 3 -1d\"}, \"task_ids\": [\"mp-1234\", \"mp-925833\", \"mp-940234\", \"mp-940654\"], \"band_gap\": 0.0, \"density\": 6.502482433523648, \"icsd_id\": null, \"icsd_ids\": [608375, 57958, 608376, 608372, 608371, 608370], \"cif\": \"# generated using pymatgen\\ndata_LuAl2\\n_symmetry_space_group_name_H-M 'P 1'\\n_cell_length_a 5.48873905\\n_cell_length_b 5.48873905\\n_cell_length_c 5.48873905\\n_cell_angle_alpha 60.00000005\\n_cell_angle_beta 60.00000003\\n_cell_angle_gamma 60.00000007\\n_symmetry_Int_Tables_number 1\\n_chemical_formula_structural LuAl2\\n_chemical_formula_sum 'Lu2 Al4'\\n_cell_volume 116.92375474\\n_cell_formula_units_Z 2\\nloop_\\n _symmetry_equiv_pos_site_id\\n _symmetry_equiv_pos_as_xyz\\n 1 'x, y, z'\\nloop_\\n _atom_site_type_symbol\\n _atom_site_label\\n _atom_site_symmetry_multiplicity\\n _atom_site_fract_x\\n _atom_site_fract_y\\n _atom_site_fract_z\\n _atom_site_occupancy\\n Al Al1 1 0.500000 0.500000 0.500000 1\\n Al Al2 1 0.500000 0.500000 0.000000 1\\n Al Al3 1 0.000000 0.500000 0.500000 1\\n Al Al4 1 0.500000 0.000000 0.500000 1\\n Lu Lu5 1 0.875000 0.875000 0.875000 1\\n Lu Lu6 1 0.125000 0.125000 0.125000 1\\n\", \"total_magnetization\": 0.0012519, \"material_id\": \"mp-1234\", \"oxide_type\": \"None\", \"tags\": [\"High pressure experimental phase\", \"Aluminium lutetium (2/1)\"], \"elasticity\": null, \"full_formula\": \"Lu2Al4\"}], \"valid_response\": true, \"created_at\": \"2018-08-08T18:52:53.042666\", \"version\": {\"db\": \"3.0.0\", \"pymatgen\": \"2018.7.23\", \"rest\": \"2.0\"}, \"copyright\": \"Materials Project, 2018\"} For obvious reasons, typing these kinds of urls into your web browser is not an ideal way to request MP data. Instead, we should try to access the API programatically with python. Let's do the same request that we did above using Python's requests library.","title":"Section 2: Basic Queries In the Web Browser"},{"location":"materials_api/api_use/#making-requests-with-python","text":"import requests response = requests . get ( \"https://www.materialsproject.org/rest/v2/materials/mp-1234/vasp\" , { \"API_KEY\" : \"<your API key>\" }) print ( response . text )","title":"Making Requests With Python"},{"location":"materials_api/api_use/#section-3-the-mprester","text":"In this section we will: Open the pymatgen.MPRester web documentation. Create our first instance of an MPRester object. Get our feet wet with calling a few of the MPRester's \"specialty\" methods.","title":"Section 3: The MPRester"},{"location":"materials_api/api_use/#background-and-documentation","text":"Code connects to the MP Database through REST requests. Pymatgen's MPRester class is helpful for accessing our API in python. The documentation for the MPRester is very helpful. Let's take a look!","title":"Background and Documentation"},{"location":"materials_api/api_use/#background-and-documentation_1","text":"REST is a widely used type of standardization that allows different computer systems to work together. In RESTful systems, information is organized into resources, each of which is uniquely identified via a uniform resource identifier (URI). Since MAPI is a RESTful system, users can interact with the MP database regardless of their computer system or programming language (as long as it supports basic http requests.) To facilitate researchers in using our API, we implemented a convenient wrapper for it in the Python Materials Genomics (pymatgen) library called the MPRester . You can find the relevant pymatgen documentation for it here .","title":"Background and Documentation"},{"location":"materials_api/api_use/#starting-up-an-instance-of-the-mprester","text":"We'll import the MPRester and create an instance of it. Note: You may need to use your API key as an input argument if it has not been pre-configured. from pymatgen import MPRester mpr = MPRester () print ( mpr . supported_properties ) ('energy', 'energy_per_atom', 'volume', 'formation_energy_per_atom', 'nsites', 'unit_cell_formula', 'pretty_formula', 'is_hubbard', 'elements', 'nelements', 'e_above_hull', 'hubbards', 'is_compatible', 'spacegroup', 'task_ids', 'band_gap', 'density', 'icsd_id', 'icsd_ids', 'cif', 'total_magnetization', 'material_id', 'oxide_type', 'tags', 'elasticity') However, we recommend that you use the \u201cwith\u201d context manager to ensure that sessions are properly closed after usage: with MPRester () as mpr : print ( mpr . supported_properties ) ('energy', 'energy_per_atom', 'volume', 'formation_energy_per_atom', 'nsites', 'unit_cell_formula', 'pretty_formula', 'is_hubbard', 'elements', 'nelements', 'e_above_hull', 'hubbards', 'is_compatible', 'spacegroup', 'task_ids', 'band_gap', 'density', 'icsd_id', 'icsd_ids', 'cif', 'total_magnetization', 'material_id', 'oxide_type', 'tags', 'elasticity')","title":"Starting up an instance of the MPRester"},{"location":"materials_api/api_use/#mprester-methods","text":"The MPRester has many methods that you might want to use in your research. For example, there is a method to get the bandstructure for a material, get_bandstructure_by_material_id . Let's use this method and the following bandstructure plotting function to get and plot a bandstructure for mp-1234: ### Don't edit this code #### from pymatgen.electronic_structure.plotter import BSPlotter # Helpful function for plotting a bandstructure. def plot_bandstructure ( bs ): BSPlotter ( bs ) . get_plot () . show () ############################# # Excercise: Use the MPRester's get_bandstructure_by_material_id method to # get a bandstructure from the MP Database and plot it using the # plot_bandstructure functin defined above. with MPRester () as mpr : bs = mpr . get_bandstructure_by_material_id ( \"mp-1234\" ) plot_bandstructure ( bs ) There's also a method to get MPIDs for a formula or chemical system called get_materials_ids . with MPRester () as mpr : # You can pass in a formula to get_materials_ids shortlist ( mpr . get_materials_ids ( \"LiFePO4\" )) # Or you can pass in a \"chemsys\" such as \"Li-Fe-P-O\" shortlist ( mpr . get_materials_ids ( \"Li-Fe-P-O\" )) First 5 of 67 items: mp-765593 mp-757182 mp-1662030 mp-772409 mp-765604 First 5 of 908 items: mp-1245108 mp-1271693 mp-1194030 mp-1271562 mp-136","title":"MPRester Methods:"},{"location":"materials_api/api_use/#using-the-api-to-achieve-research-goals","text":"Imagine you want to get the structure for the multiferroic material BiFeO3 ( mp-24932 ) and suggest some substrates for growing it. We can use methods of the MPRester to get this information from the Materials Project API. Hints: * MPRester.get_structure_by_material_id * MPRester.get_substrates # Get the structure for BiFeO3 (mp-23501) and # suggest some substrates for growing it. with MPRester () as mpr : structure = mpr . get_structure_by_material_id ( \"mp-23501\" ) substrates = mpr . get_substrates ( \"mp-23501\" ) print ( structure ) print ([ s [ \"sub_form\" ] for s in substrates ]) Full Formula (Fe2 Bi2 O6) Reduced Formula: FeBiO3 abc : 5.615643 5.615629 5.705140 angles: 60.510834 119.489364 120.001015 Sites (10) # SP a b c magmom --- ---- -------- -------- -------- -------- 0 Fe 0.219028 0.780969 0.657065 -4.256 1 Fe 0.719032 0.28097 0.15707 4.256 2 Bi 0.498595 0.501425 0.495716 -0.001 3 Bi 0.998575 0.001404 0.995717 0.001 4 O 0.436045 0.111857 0.359395 0.034 5 O 0.035218 0.563986 0.359413 0.034 6 O 0.888122 0.964774 0.359409 0.034 7 O 0.388142 0.063955 0.859394 -0.034 8 O 0.535228 0.61188 0.859409 -0.034 9 O 0.936013 0.46478 0.859414 -0.034 ['AlN', 'LaAlO3', 'LiGaO2', 'WS2', 'MoS2', 'C', 'TbScO3', 'MgF2', 'NdGaO3', 'BaTiO3', 'Ag', 'C', 'DyScO3', 'GdScO3', 'Mg', 'LiAlO2', 'Au', 'BaTiO3', 'AlN', 'TiO2', 'ZnO', 'NaCl', 'MgF2', 'Bi2Te3', 'SrTiO3', 'KTaO3', 'GaN', 'NaCl', 'Al', 'C', 'ZnO', 'TeO2', 'Ni', 'C', 'SrTiO3', 'GaN', 'TiO2', 'DyScO3', 'Te2W', 'GdScO3', 'SiC', 'BaTiO3', 'ZnSe', 'SiC', 'WS2', 'WS2', 'ZnO', 'WS2', 'MoS2', 'MoS2'] At this point, you should be comfortable with: Finding documentation on the MPRester. Creating an instance of the MPRester. Using methods of the MPRester.","title":"Using the API to achieve research goals:"},{"location":"materials_api/api_use/#section-4-using-the-mpresterquery-method","text":"The MPRester also has a very powerful method called query , which allows us to perform sophisticated searches on the database. The query method uses MongoDB's query syntax . In this syntax, query submissions have two parts: a set of criteria that you want to base the search on (in the form of a python dict), and a set of properties that you want the database to return (in the form of either a list or dict). You will probably find yourself using the MPRester's query method frequently. The general structure of a MPRester query is: mpr.query(criteria, properties) The general structure of a MPRester query is: mpr.query(criteria, properties) criteria is usually a string or a dict. properties is always a list of strings Let's try out some queries to learn how it works! First, we'll query for SiO_2 SiO_2 compounds by chemical formula through 'pretty_formula'. with MPRester () as mpr : results = mpr . query ({ 'pretty_formula' : \"SiO2\" }, properties = [ 'material_id' , 'pretty_formula' ]) print ( len ( results )) If we investigate the object that the query method returns, we find that it is a list of dicts. Furthermore, we find that the keys of the dictionaries are the very same keywords that we passed to the query method as the properties argument. print ( 'Results are returned as a {} of {} . \\n ' . format ( type ( results ), type ( results [ 0 ]))) for r in results [ 0 : 5 ]: print ( r ) In fact, if you are just looking for materials based on formula/composition/stoichiometry, there is an easier way to use the query method: just pass in a string as the criteria! You can even use wildcard characters in your searches. For example, if we want to find all ABO_3 ABO_3 compounds in the Materials Project: with MPRester () as mpr : results = mpr . query ( '**O3' , properties = [ \"material_id\" , \"pretty_formula\" ]) shortlist ( results )","title":"Section 4: Using the MPRester.query method."},{"location":"materials_api/api_use/#putting-it-into-practice","text":"There are 296 variants of SiO_2 SiO_2 in the MP database, but how many Si_xO_y Si_xO_y compounds are there in the Materials Project? Hint: * Query using a chemsys string instead of a formula. with MPRester () as mpr : print ( len ( mpr . query ( \"Si-O\" , [ \"material_id\" ]))) 331","title":"Putting it into practice:"},{"location":"materials_api/api_use/#excercise-1","text":"","title":"EXCERCISE 1"},{"location":"materials_api/api_use/#mongodb-operators","text":"Above, we specified the chemical formula SiO _2 _2 for our query. This is an example of, the \"specify\" operator. However, MongoDB's syntax also includes other query operators , allowing us to bulid complex conditionals into our queries. These all start with the \"$\" character. Some important MongoDB operators you should be familiar with are: * $in (in) * $ nin ( not in ) * $ gt ( greater than ) * $ gte ( greater than or equal to ) * $ lt ( less than ) * $ lte ( less than or equal to ) * $ not ( is not ) We used these more advanced operators as follows: {\"field_name\": {\"$op\": value}} For example, \"entries with e_above_hull that is less than 0.25 eV\" would be: {\"e_above_hull\": {\"$lt\": 0.25}} A paper by McEnany et. al. proposes a novel ammonia synthesis process based on the electrochemical cycling of lithium ( link ). As an exercise, let's use some of MongoDB's operators and ask the database for nitrides of alkali metals. # Find all nitrides of alkali metals alkali_metals = [ 'Li' , 'Na' , 'K' , 'Rb' , 'Cs' ] criteria = { \"elements\" :{ \"$in\" : alkali_metals , \"$all\" : [ \"N\" ]}, \"nelements\" : 2 } properties = [ 'material_id' , 'pretty_formula' ] shortlist ( mpr . query ( criteria , properties )) #Bonus short way to do this with wildcards shortlist ( mpr . query ( '{Li,Na,K,Rb,Cs}-N' , [ 'material_id' , 'pretty_formula' ])) We can also perform the same query, but ask the database to only return compounds with energies above the hull less than 10 meV/atom by using the \"less than\" operator, \" $lt \". (The energy above the convex hull gives us a sense of how stable a compound is relative to other compounds with the same composition.) criteria = { \"elements\" :{ \"$in\" : alkali_metals , \"$all\" :[ \"N\" ]}, \"nelements\" : 2 , 'e_above_hull' :{ \"$lt\" : 0.010 }} properties = [ 'material_id' , 'pretty_formula' ] mpr . query ( criteria , properties ) In this lesson, we have covered: * The Materials Project API (MAPI) and its documentation, the mapidoc . * Getting your Materials Project API key. * Using the MPRester to access the MP database. * Hands-on examples of using the API and pymatgen to screen the MP database for interesting materials.","title":"MongoDB Operators"},{"location":"people/people/","text":"People \u00b6 The annual MP Workshop would not be possible without all the people that contribute. In particular, several critical people step up each year to plan, organize, develop lessons, run the workshop, teach, collect post-workshop surveys, and begin planning again. This page highlights those individuals who have contributed significantly to this workshop each year. 2020 \u00b6 2020 is particularly important as the transition from an in-person 40-person workshop to an online 100-person workshop represents a significant effort. The workshop lesson plan changes a little bit each year, but these individuals stepped up and reworked the lessons for a virtual teaching environment. This represents 100's, if not well over 1000+ combined hours of effort. Organizers \u00b6 Shyam Dwaraknath Matthew Horton Patrick Huck Alice Muller Kristin Persson Instructors \u00b6 Ryan Kingbury Guy Moore Jason Munro Sam Blau Evan Spotte-Smith Oxana Andriuc John Dagdelen Rachel Woods-Robinson Alex Ganose Helpers \u00b6 Mingjian Wen Jianli Cheng Ann Rutt Hetal Patel Kara Fong Matt McDermott Jimmy Shen Eric Sivonxay","title":"People"},{"location":"people/people/#people","text":"The annual MP Workshop would not be possible without all the people that contribute. In particular, several critical people step up each year to plan, organize, develop lessons, run the workshop, teach, collect post-workshop surveys, and begin planning again. This page highlights those individuals who have contributed significantly to this workshop each year.","title":"People"},{"location":"people/people/#2020","text":"2020 is particularly important as the transition from an in-person 40-person workshop to an online 100-person workshop represents a significant effort. The workshop lesson plan changes a little bit each year, but these individuals stepped up and reworked the lessons for a virtual teaching environment. This represents 100's, if not well over 1000+ combined hours of effort.","title":"2020"},{"location":"people/people/#organizers","text":"Shyam Dwaraknath Matthew Horton Patrick Huck Alice Muller Kristin Persson","title":"Organizers"},{"location":"people/people/#instructors","text":"Ryan Kingbury Guy Moore Jason Munro Sam Blau Evan Spotte-Smith Oxana Andriuc John Dagdelen Rachel Woods-Robinson Alex Ganose","title":"Instructors"},{"location":"people/people/#helpers","text":"Mingjian Wen Jianli Cheng Ann Rutt Hetal Patel Kara Fong Matt McDermott Jimmy Shen Eric Sivonxay","title":"Helpers"},{"location":"primer/01_basic_python/0%20-%20Introduction%20and%20Jupyter%20Use/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Introduction to Python and Using Jupyter notebooks \u00b6 The Jupyter notebook is a platform for using and writing code in a dynamic way that allows users to combine cells of code snippets that are executed with a persistent namespace and kernel alongside markdown text for facilitating readability and visualization. In this notebook, we cover some basics of Jupyter functionality along with a discussion of some details of how you can use python in this environment and elsewhere. Installation \u00b6 For this workshop, we've constructed an online environment for everyone to use in order to smooth out any platform-dependent installation issues, but you'll probably want to install the tools we use today locally on your own machine. To do this, we recommend Anaconda , which is an effective tool for python package management that can create virtual environments, comes with a pre-installed IDE, and includes all of the Jupyter functionality that you'll see here. The Anaconda installer should be detailed on the page linked above, but here's another resource for installation that might be helpful. Code vs. Markdown \u00b6 Jupyter notebooks are broken down into \"cells\" which might contain either code or markdown. If you select a cell with your mouse, it should be highlighted with a green border indicating that you are in \"edit,\" mode and can edit the contents of the cell. If text reading In [ ]: is on the left hand side of the cell, it's a \"code\" cell. For example, type the following and press \"Shift + Enter\" print ( \"Hello world!\" ) Hello world! Pressing \"Shift + Enter\" executes the code in the cell, prints the output below the cell, and creates a new cell below that one. In addition to code cells, you can also write your own markdown cells by converting a cell using either the dropdown menu in the toolbar or pressing \"Esc + m\". In general, pressing escape enters \"command mode\" for which you can issue a number of commands, including f - find and replace m - convert to markdown y - convert to code h - open the help menu Right now, trying typing \"Esc + h\" to open the help/shortcut menu and peruse it. Spend a minute testing out some of the shortcuts. Note that markdown cells are quite flexible and can basically do anything wikipedia does, including adding \\LaTeX \\LaTeX -formatted equations. \\hat{H}\\psi = E \\psi \\hat{H}\\psi = E \\psi Shell commands, magic, and where to learn more \u00b6 Jupyter notebooks can also issue commands to the shell, which can be achieved using the ! symbol at the beginning of the cell: ! ls . 0 - Introduction and Jupyter Use.ipynb Exercises.ipynb 1 - Python Primer.ipynb inflammation-01.csv Exercise_Solutions.ipynb ! date Mon Jul 27 14:57:00 PDT 2020 In addition, certain things can be achieved in Jupyter notebooks using what are called \"magic\" commands, which are demarcated using the % sign. The most common of these are the magic function to enable inline plotting: % matplotlib inline and to invoke the debugger in a particular cell on an error: % pdb Automatic pdb calling has been turned ON These functions set up special functionality in the notebook. Lastly, note that Jupyter notebooks are becoming increasingly popular as tools to supplement publication. As a computational researcher, you can provide explicit documentation of your methods with embedded code that actually works for a person who wants to understand better what you're working on. In my own work, I've begun making all my plots and collecting all of my data in Jupyter notebooks to provide as supporting info for each of my recent papers. It's a bit more work, but you'll find that having this level of organization and being this transparent about your methods goes a long way. There are great resources for IPython notebooks online, and here are a few of them: Jupyter website A gallery of interesting notebooks","title":"Intro"},{"location":"primer/01_basic_python/0%20-%20Introduction%20and%20Jupyter%20Use/#introduction-to-python-and-using-jupyter-notebooks","text":"The Jupyter notebook is a platform for using and writing code in a dynamic way that allows users to combine cells of code snippets that are executed with a persistent namespace and kernel alongside markdown text for facilitating readability and visualization. In this notebook, we cover some basics of Jupyter functionality along with a discussion of some details of how you can use python in this environment and elsewhere.","title":"Introduction to Python and Using Jupyter notebooks"},{"location":"primer/01_basic_python/0%20-%20Introduction%20and%20Jupyter%20Use/#installation","text":"For this workshop, we've constructed an online environment for everyone to use in order to smooth out any platform-dependent installation issues, but you'll probably want to install the tools we use today locally on your own machine. To do this, we recommend Anaconda , which is an effective tool for python package management that can create virtual environments, comes with a pre-installed IDE, and includes all of the Jupyter functionality that you'll see here. The Anaconda installer should be detailed on the page linked above, but here's another resource for installation that might be helpful.","title":"Installation"},{"location":"primer/01_basic_python/0%20-%20Introduction%20and%20Jupyter%20Use/#code-vs-markdown","text":"Jupyter notebooks are broken down into \"cells\" which might contain either code or markdown. If you select a cell with your mouse, it should be highlighted with a green border indicating that you are in \"edit,\" mode and can edit the contents of the cell. If text reading In [ ]: is on the left hand side of the cell, it's a \"code\" cell. For example, type the following and press \"Shift + Enter\" print ( \"Hello world!\" ) Hello world! Pressing \"Shift + Enter\" executes the code in the cell, prints the output below the cell, and creates a new cell below that one. In addition to code cells, you can also write your own markdown cells by converting a cell using either the dropdown menu in the toolbar or pressing \"Esc + m\". In general, pressing escape enters \"command mode\" for which you can issue a number of commands, including f - find and replace m - convert to markdown y - convert to code h - open the help menu Right now, trying typing \"Esc + h\" to open the help/shortcut menu and peruse it. Spend a minute testing out some of the shortcuts. Note that markdown cells are quite flexible and can basically do anything wikipedia does, including adding \\LaTeX \\LaTeX -formatted equations. \\hat{H}\\psi = E \\psi \\hat{H}\\psi = E \\psi","title":"Code vs. Markdown"},{"location":"primer/01_basic_python/0%20-%20Introduction%20and%20Jupyter%20Use/#shell-commands-magic-and-where-to-learn-more","text":"Jupyter notebooks can also issue commands to the shell, which can be achieved using the ! symbol at the beginning of the cell: ! ls . 0 - Introduction and Jupyter Use.ipynb Exercises.ipynb 1 - Python Primer.ipynb inflammation-01.csv Exercise_Solutions.ipynb ! date Mon Jul 27 14:57:00 PDT 2020 In addition, certain things can be achieved in Jupyter notebooks using what are called \"magic\" commands, which are demarcated using the % sign. The most common of these are the magic function to enable inline plotting: % matplotlib inline and to invoke the debugger in a particular cell on an error: % pdb Automatic pdb calling has been turned ON These functions set up special functionality in the notebook. Lastly, note that Jupyter notebooks are becoming increasingly popular as tools to supplement publication. As a computational researcher, you can provide explicit documentation of your methods with embedded code that actually works for a person who wants to understand better what you're working on. In my own work, I've begun making all my plots and collecting all of my data in Jupyter notebooks to provide as supporting info for each of my recent papers. It's a bit more work, but you'll find that having this level of organization and being this transparent about your methods goes a long way. There are great resources for IPython notebooks online, and here are a few of them: Jupyter website A gallery of interesting notebooks","title":"Shell commands, magic, and where to learn more"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Basic Python \u00b6 Lesson 1: Expressions, variables and built-in functions \u00b6 Expressions \u00b6 An expression describes a computation. Python evaluates expressions and generates a value. We say that expressions \"evaluate to\" their result. 2019 2019 Python's arithmetic operators allows you to use a Python command line or Jupyter notebook cell as a \"calculator\" 2000 + 19 2019 2000 - 19 1981 Multiplication is done with an asterisk * 1 * 2 * ( 3 * 4 ) 24 Normal or \"true\" division is done with / . This operation will always return a float 10 / 2 5.0 Python has two other division operators. \"Floor\" division // , which returns the division rounded down to the lowest integer, and the modulo operator % , which returns the remainder of a division after substracting the next lowest integer. These are easier to understand by example: 10 // 6 1 10 % 6 4 6 // 2 3 6 % 3 0 To take an exponent, use two asterisks ** (NOT ^ ) 2 ** 3 8 Variables \u00b6 * Variables are names for values. * In Python the = symbol assigns the value on the right to the name on the left. * The variable is created when a value is assigned to it. * Every variable has a type that describes what sort of data it contains. Some of the most common types are int (integer), float (floating point number), and string (text) * Unlike many other languages, in Python you do not have to specify the type when you create a variable. Python infers the data type based on the context. This is called 'duck typing'. int variables are simply numbers. Let's assign 27 to a variable 'age'. If the variable age does not already exist, this assignment expression will create it age = 27 You can find the type of a variable using the type() function. Let's examine the type of age . type ( age ) int float variables are created by adding a decimal point to a number. Let's redefine age as 27.0 and check the type age = 27.0 type ( age ) float string variables contain text and are created using quotation marks. Both single and double quotation marks are OK. Let's try making age a string first_name = \"Ryan\" type ( first_name ) str Note that it's possible to create a string that contains only numbers age = \"27\" type ( age ) str In the Jupyter notebook, variable names are preserved between cells. In more formal language, the namespace of a notebook is preserved unless the kernel is reset, which resets all of the variable names. You can see this if you execute the following cells out of sequence. Try it out. Also try resetting the kernel and executing just the latter half. age = 42 age 42 Assigning a new value to an existing variable will replace the value of that variable age = 29 age 29 Built-in functions \u00b6 Now that we understand how Python and Jupyter handle variables, let's talk about built-in functions . These functions are available by default without issuing any special instructions. One such function is type , which we've already used. Functions are called using the function name and parentheses, which enclose the function arguments . In the example below, print is the function, and the string \"Hello world!\" is the argument. print ( \"Hello world!\" ) Hello world! print can accept multiple arguments, separate by commas, and will combine them together to generate its output, like this: print ( \"Age is\" , age , \"years\" ) Age is 29 years One of the most important things you can know when learning programming is where to access help on the things you're trying to use. There are a number of ways to access information on a function. Three of the easiest ways in Jupyter are Place your cursor inside the name of any function, and press SHIFT+TAB. This will open a small box with function information, which can be expanded by pressing tab again. Use the built-in help function, where the argument to help is the name of the function you want to know more about. Type the name of the function followed by ? , which will show the functions documentation or 'docstring' Finding help \u00b6 ## click your cursor inside 'print' and press SHIFT+TAB print ( \"this is cool\" ) this is cool help ( print ) Help on built-in function print in module builtins: print(...) print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. print ? Importing other modules and functions \u00b6 To get a function that's not built in to Python, we use the import statement. In this example, we're going to import a module called math that contains a number of functions that can be accessed by using math.FUNCTION_NAME_HERE . print ( \"I\" , \"am\" , \"a\" , \"penguin\" ) I am a penguin import math math . exp ( 2 ) 7.38905609893065 print ( \"Exponent of 2:\" , math . exp ( 2 )) print ( \"Sine of 3.1415:\" , math . sin ( 3.1415 )) Exponent of 2: 7.38905609893065 Sine of 3.1415: 9.265358966049024e-05 The Standard library includes a number of modules that come pre-installed with the python programming language itself, which is summarized in this documentation . Python's real power, however, comes in how extensible it is. Python has an ecosystem of external libraries that provide special functions for many different tasks. Three of the most common external libraries in python are: numpy - for efficient numerical array manipulation and operation scipy - for a number of tools related to scientific computing matplotlib - for plotting data and creating figures Let's use some functions from numpy and matplotlib to create a plot import numpy as np from matplotlib import pyplot inflammation = np . loadtxt ( \"inflammation-01.csv\" , delimiter = ',' ) % matplotlib inline average = np . average ( inflammation , axis = 0 ) pyplot . plot ( average ) [<matplotlib.lines.Line2D at 0x7f97f8648580>] Lesson 2: Lists and Strings \u00b6 A list stores many values in a single structure. \u00b6 A list stores many values together. Contained within square brackets [...] . Values separated by commas , . Use len to find out how many values are in a list. pressures = [ 0.273 , 0.275 , 0.277 , 0.275 , 0.276 ] print ( 'pressures:' , pressures ) pressures: [0.273, 0.275, 0.277, 0.275, 0.276] Use the built-in function len to find the length of a list \u00b6 len ( pressures ) 5 Lists may be heterogeneous \u00b6 Values can have different types goals = [ 1 , 'Create lists.' , 2 , 'Extract items from lists.' , 3 , 'Modify lists.' ] Index and slice to get information out of a string/list \u00b6 Locations are numbered from 0 rather than 1 Negative indices count backward from the end of the string Slices include the lower bound but exclude the upper bound, so (upper - lower) is the slice's length numbers = [ \"one\" , \"two\" , \"three\" , \"four\" , \"five\" ] print ( 'first element:' , numbers [ 0 ]) print ( 'last element:' , numbers [ - 1 ]) print ( 'middle elemnets:' , numbers [ 2 : 5 ]) first element: one last element: five middle elemnets: ['three', 'four', 'five'] Indexing beyond the end of a collection is an error # NBVAL_RAISES_EXCEPTION ## This code will fail print ( '99th element of numbers is:' , numbers [ 99 ]) --------------------------------------------------------------------------- IndexError Traceback (most recent call last) <ipython-input-38-89d4ca35c24b> in <module> 1 # NBVAL_RAISES_EXCEPTION 2 ## This code will fail ----> 3 print ( '99th element of numbers is:' , numbers [ 99 ] ) IndexError : list index out of range List values can be replaced by assigning to them \u00b6 Use an index expression on the left of assignment to replace a value. We say that lists are mutable because their contents can be changed after they are created pressures [ 0 ] = 0.265 print ( 'pressures is now:' , pressures ) pressures is now: [0.265, 0.275, 0.277, 0.275, 0.276] Appending items to a list lengthens it \u00b6 use list_name.append to add items to the end of a list. primes = [ 2 , 3 , 5 ] print ( 'primes is initially:' , primes ) primes . append ( 7 ) primes . append ( 9 ) print ( 'primes has become:' , primes ) primes is initially: [2, 3, 5] primes has become: [2, 3, 5, 7, 9] * append is a method of lists * like a function, but tied to a particular object Use object_name.method_name to call methods deliberately resembles the way we refer to things in a library We will meet other methods of lists as we go along Use help(list) for a preview Extending a list adds another list to it \u00b6 extend is similar to append , but it allows you to combine two lists. teen_primes = [ 11 , 13 , 17 , 19 ] older_primes = [ 23 , 31 , 47 , 59 ] print ( 'primes is currently:' , primes ) primes . extend ( teen_primes ) print ( 'primes has now become:' , primes ) primes . append ( older_primes ) print ( 'primes has finally become:' , primes ) primes is currently: [2, 3, 5, 7, 9] primes has now become: [2, 3, 5, 7, 9, 11, 13, 17, 19] primes has finally become: [2, 3, 5, 7, 9, 11, 13, 17, 19, [23, 31, 47, 59]] Note that while extend maintains the \"flat\" structure of the list, appending a list to a list makes the result two-dimensional. Use del to remove items from a list entirely \u00b6 del list_name[index] removes an item from a list and shortens the list. Not a function or method, but a statement in the language. print ( 'primes before removing last item:' , primes ) del primes [ 4 ] print ( 'primes after removing last item:' , primes ) primes before removing last item: [2, 3, 5, 7, 9, 11, 13, 17, 19, [23, 31, 47, 59]] primes after removing last item: [2, 3, 5, 7, 11, 13, 17, 19, [23, 31, 47, 59]] The empty list contains no values \u00b6 [] is \"the zero of lists\" Helpful as a starting point for collecting values NEVER use an empty list as a default argument in a function! Strings can be sliced and indexed just like lists \u00b6 You can think of strings as lists of characters greeting = \"My name is Ryan\" print ( 'first character:' , greeting [ 0 ]) print ( 'last character:' , greeting [ - 1 ]) print ( 'middle character:' , greeting [ 2 : 5 ]) first character: M last character: n middle character: na Unlike lists, strings are immutable \u00b6 Cannot change the characters in a string after it has been created. Python considers the string to be a single value with parts, not a collection of values. # NBVAL_RAISES_EXCEPTION element = 'helium' ## This code will fail element [ 0 ] = 'C' --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-44-789481aab7e2> in <module> 2 element = 'helium' 3 ## This code will fail ----> 4 element [ 0 ] = 'C' TypeError : 'str' object does not support item assignment Lesson 3: For loops \u00b6 A for loop can be used to repeat actions over a set of values. Let's print each letter in this list: name = [ 'J' , 'i' , 'm' , 'm' , 'y' ] for letter in name : print ( letter ) J i m m y For loop syntax \u00b6 For loops are constructed via the syntax for LOOP_VARIABLE in ITERABLE. The loop variable in the above example I've used is letter and the iterable I've used is the list name , which was defined as '['J', 'i', 'm', 'm', 'y']' . Other iterables include strings and dictionary keys, among others. For example, we could make name a string and iterate through it in the same way we iterated through the list: name = 'Jimmy' for letter in name : print ( letter ) J i m m y You can also use list indexing notation to limit iteration to a certain portion of an iterable. name = 'Jimmy' for letter in name [ 0 : 3 ]: print ( letter ) J i m Iterables have a length, and you can find this length using the len function. print ( \"Length of\" , name , \"is\" , len ( name )) Length of Jimmy is 5 Use enumerate() to get both an index and an item \u00b6 The enumerate function assigns an index (or counter) to each value of an iterable. It returns a tuple of (counter, value) that can be useful in for loops. For example, here we assign the index to the variable n and the value of the iterable to letter : for n , letter in enumerate ( name ): print ( \"Letter\" , n , \"-\" , letter ) Letter 0 - J Letter 1 - i Letter 2 - m Letter 3 - m Letter 4 - y Use zip() to loop over two iterables simultaneously \u00b6 The zip function can be used to loop through two iterables simultaneously (like two sides of a zipper). Here, we use zip to iterate through two strings that have the same length for letter1 , letter2 in zip ( \"Jimmy\" , \"Heath\" ): print ( letter1 , letter2 ) J H i e m a m t y h Use range() to iterate ranges of numbers \u00b6 The range function is used to construct an iterable corresponding to a set of numbers beginning at 0 and ending at a certain number: for number in range ( 6 ): print ( number ) 0 1 2 3 4 5 Logic within for loops \u00b6 range can take multiple arguments, where the first argument is interpreted as the beginning of the range. In the example below, we combine a for loop with an if statement to print only the even numbers. This makes use of the modulo % operator we covered in the Variables lesson. for number in range ( 2 , 10 ): if number % 2 == 0 : print ( number , \"is even\" ) 2 is even 4 is even 6 is even 8 is even break stops the loop \u00b6 The break statement is used to stop iterating through an iterable if some condition is met. Here, we will end our loop as soon as we encouter the number 6: for number in range ( 2 , 10 ): if number == 6 : break else : print ( number ) 2 3 4 5 A common use of for loops is to keep track of a running total of numbers. In this pattern, it's important to declare the variable that you're adding to outside the scope of the for loop. The example below makes use of the \"in place addition\" += operator, which says \"add the value on the right of the operator to the value of the variable on the left\". So x += 5 means \"add 5 to the current value of variable x . Python has similar \"in place\" operators for several other operations, including -= , *= , and /= for subtraction, multiplication, and division, respectively. my_sum = 0 for number in range ( 6 ): my_sum += number print ( \"Sum of numbers from 0 to 5 is\" , my_sum ) Sum of numbers from 0 to 5 is 15","title":"Basic Python"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#basic-python","text":"","title":"Basic Python"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#lesson-1-expressions-variables-and-built-in-functions","text":"","title":"Lesson 1: Expressions, variables and built-in functions"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#expressions","text":"An expression describes a computation. Python evaluates expressions and generates a value. We say that expressions \"evaluate to\" their result. 2019 2019 Python's arithmetic operators allows you to use a Python command line or Jupyter notebook cell as a \"calculator\" 2000 + 19 2019 2000 - 19 1981 Multiplication is done with an asterisk * 1 * 2 * ( 3 * 4 ) 24 Normal or \"true\" division is done with / . This operation will always return a float 10 / 2 5.0 Python has two other division operators. \"Floor\" division // , which returns the division rounded down to the lowest integer, and the modulo operator % , which returns the remainder of a division after substracting the next lowest integer. These are easier to understand by example: 10 // 6 1 10 % 6 4 6 // 2 3 6 % 3 0 To take an exponent, use two asterisks ** (NOT ^ ) 2 ** 3 8","title":"Expressions"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#variables","text":"* Variables are names for values. * In Python the = symbol assigns the value on the right to the name on the left. * The variable is created when a value is assigned to it. * Every variable has a type that describes what sort of data it contains. Some of the most common types are int (integer), float (floating point number), and string (text) * Unlike many other languages, in Python you do not have to specify the type when you create a variable. Python infers the data type based on the context. This is called 'duck typing'. int variables are simply numbers. Let's assign 27 to a variable 'age'. If the variable age does not already exist, this assignment expression will create it age = 27 You can find the type of a variable using the type() function. Let's examine the type of age . type ( age ) int float variables are created by adding a decimal point to a number. Let's redefine age as 27.0 and check the type age = 27.0 type ( age ) float string variables contain text and are created using quotation marks. Both single and double quotation marks are OK. Let's try making age a string first_name = \"Ryan\" type ( first_name ) str Note that it's possible to create a string that contains only numbers age = \"27\" type ( age ) str In the Jupyter notebook, variable names are preserved between cells. In more formal language, the namespace of a notebook is preserved unless the kernel is reset, which resets all of the variable names. You can see this if you execute the following cells out of sequence. Try it out. Also try resetting the kernel and executing just the latter half. age = 42 age 42 Assigning a new value to an existing variable will replace the value of that variable age = 29 age 29","title":"Variables"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#built-in-functions","text":"Now that we understand how Python and Jupyter handle variables, let's talk about built-in functions . These functions are available by default without issuing any special instructions. One such function is type , which we've already used. Functions are called using the function name and parentheses, which enclose the function arguments . In the example below, print is the function, and the string \"Hello world!\" is the argument. print ( \"Hello world!\" ) Hello world! print can accept multiple arguments, separate by commas, and will combine them together to generate its output, like this: print ( \"Age is\" , age , \"years\" ) Age is 29 years One of the most important things you can know when learning programming is where to access help on the things you're trying to use. There are a number of ways to access information on a function. Three of the easiest ways in Jupyter are Place your cursor inside the name of any function, and press SHIFT+TAB. This will open a small box with function information, which can be expanded by pressing tab again. Use the built-in help function, where the argument to help is the name of the function you want to know more about. Type the name of the function followed by ? , which will show the functions documentation or 'docstring'","title":"Built-in functions"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#finding-help","text":"## click your cursor inside 'print' and press SHIFT+TAB print ( \"this is cool\" ) this is cool help ( print ) Help on built-in function print in module builtins: print(...) print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. print ?","title":"Finding help"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#importing-other-modules-and-functions","text":"To get a function that's not built in to Python, we use the import statement. In this example, we're going to import a module called math that contains a number of functions that can be accessed by using math.FUNCTION_NAME_HERE . print ( \"I\" , \"am\" , \"a\" , \"penguin\" ) I am a penguin import math math . exp ( 2 ) 7.38905609893065 print ( \"Exponent of 2:\" , math . exp ( 2 )) print ( \"Sine of 3.1415:\" , math . sin ( 3.1415 )) Exponent of 2: 7.38905609893065 Sine of 3.1415: 9.265358966049024e-05 The Standard library includes a number of modules that come pre-installed with the python programming language itself, which is summarized in this documentation . Python's real power, however, comes in how extensible it is. Python has an ecosystem of external libraries that provide special functions for many different tasks. Three of the most common external libraries in python are: numpy - for efficient numerical array manipulation and operation scipy - for a number of tools related to scientific computing matplotlib - for plotting data and creating figures Let's use some functions from numpy and matplotlib to create a plot import numpy as np from matplotlib import pyplot inflammation = np . loadtxt ( \"inflammation-01.csv\" , delimiter = ',' ) % matplotlib inline average = np . average ( inflammation , axis = 0 ) pyplot . plot ( average ) [<matplotlib.lines.Line2D at 0x7f97f8648580>]","title":"Importing other modules and functions"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#lesson-2-lists-and-strings","text":"","title":"Lesson 2: Lists and Strings"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#a-list-stores-many-values-in-a-single-structure","text":"A list stores many values together. Contained within square brackets [...] . Values separated by commas , . Use len to find out how many values are in a list. pressures = [ 0.273 , 0.275 , 0.277 , 0.275 , 0.276 ] print ( 'pressures:' , pressures ) pressures: [0.273, 0.275, 0.277, 0.275, 0.276]","title":"A list stores many values in a single structure."},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#use-the-built-in-function-len-to-find-the-length-of-a-list","text":"len ( pressures ) 5","title":"Use the built-in function len to find the length of a list"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#lists-may-be-heterogeneous","text":"Values can have different types goals = [ 1 , 'Create lists.' , 2 , 'Extract items from lists.' , 3 , 'Modify lists.' ]","title":"Lists may be heterogeneous"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#index-and-slice-to-get-information-out-of-a-stringlist","text":"Locations are numbered from 0 rather than 1 Negative indices count backward from the end of the string Slices include the lower bound but exclude the upper bound, so (upper - lower) is the slice's length numbers = [ \"one\" , \"two\" , \"three\" , \"four\" , \"five\" ] print ( 'first element:' , numbers [ 0 ]) print ( 'last element:' , numbers [ - 1 ]) print ( 'middle elemnets:' , numbers [ 2 : 5 ]) first element: one last element: five middle elemnets: ['three', 'four', 'five'] Indexing beyond the end of a collection is an error # NBVAL_RAISES_EXCEPTION ## This code will fail print ( '99th element of numbers is:' , numbers [ 99 ]) --------------------------------------------------------------------------- IndexError Traceback (most recent call last) <ipython-input-38-89d4ca35c24b> in <module> 1 # NBVAL_RAISES_EXCEPTION 2 ## This code will fail ----> 3 print ( '99th element of numbers is:' , numbers [ 99 ] ) IndexError : list index out of range","title":"Index and slice to get information out of a string/list"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#list-values-can-be-replaced-by-assigning-to-them","text":"Use an index expression on the left of assignment to replace a value. We say that lists are mutable because their contents can be changed after they are created pressures [ 0 ] = 0.265 print ( 'pressures is now:' , pressures ) pressures is now: [0.265, 0.275, 0.277, 0.275, 0.276]","title":"List values can be replaced by assigning to them"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#appending-items-to-a-list-lengthens-it","text":"use list_name.append to add items to the end of a list. primes = [ 2 , 3 , 5 ] print ( 'primes is initially:' , primes ) primes . append ( 7 ) primes . append ( 9 ) print ( 'primes has become:' , primes ) primes is initially: [2, 3, 5] primes has become: [2, 3, 5, 7, 9] * append is a method of lists * like a function, but tied to a particular object Use object_name.method_name to call methods deliberately resembles the way we refer to things in a library We will meet other methods of lists as we go along Use help(list) for a preview","title":"Appending items to a list lengthens it"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#extending-a-list-adds-another-list-to-it","text":"extend is similar to append , but it allows you to combine two lists. teen_primes = [ 11 , 13 , 17 , 19 ] older_primes = [ 23 , 31 , 47 , 59 ] print ( 'primes is currently:' , primes ) primes . extend ( teen_primes ) print ( 'primes has now become:' , primes ) primes . append ( older_primes ) print ( 'primes has finally become:' , primes ) primes is currently: [2, 3, 5, 7, 9] primes has now become: [2, 3, 5, 7, 9, 11, 13, 17, 19] primes has finally become: [2, 3, 5, 7, 9, 11, 13, 17, 19, [23, 31, 47, 59]] Note that while extend maintains the \"flat\" structure of the list, appending a list to a list makes the result two-dimensional.","title":"Extending a list adds another list to it"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#use-del-to-remove-items-from-a-list-entirely","text":"del list_name[index] removes an item from a list and shortens the list. Not a function or method, but a statement in the language. print ( 'primes before removing last item:' , primes ) del primes [ 4 ] print ( 'primes after removing last item:' , primes ) primes before removing last item: [2, 3, 5, 7, 9, 11, 13, 17, 19, [23, 31, 47, 59]] primes after removing last item: [2, 3, 5, 7, 11, 13, 17, 19, [23, 31, 47, 59]]","title":"Use del to remove items from a list entirely"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#the-empty-list-contains-no-values","text":"[] is \"the zero of lists\" Helpful as a starting point for collecting values NEVER use an empty list as a default argument in a function!","title":"The empty list contains no values"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#strings-can-be-sliced-and-indexed-just-like-lists","text":"You can think of strings as lists of characters greeting = \"My name is Ryan\" print ( 'first character:' , greeting [ 0 ]) print ( 'last character:' , greeting [ - 1 ]) print ( 'middle character:' , greeting [ 2 : 5 ]) first character: M last character: n middle character: na","title":"Strings can be sliced and indexed just like lists"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#unlike-lists-strings-are-immutable","text":"Cannot change the characters in a string after it has been created. Python considers the string to be a single value with parts, not a collection of values. # NBVAL_RAISES_EXCEPTION element = 'helium' ## This code will fail element [ 0 ] = 'C' --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-44-789481aab7e2> in <module> 2 element = 'helium' 3 ## This code will fail ----> 4 element [ 0 ] = 'C' TypeError : 'str' object does not support item assignment","title":"Unlike lists, strings are immutable"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#lesson-3-for-loops","text":"A for loop can be used to repeat actions over a set of values. Let's print each letter in this list: name = [ 'J' , 'i' , 'm' , 'm' , 'y' ] for letter in name : print ( letter ) J i m m y","title":"Lesson 3: For loops"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#for-loop-syntax","text":"For loops are constructed via the syntax for LOOP_VARIABLE in ITERABLE. The loop variable in the above example I've used is letter and the iterable I've used is the list name , which was defined as '['J', 'i', 'm', 'm', 'y']' . Other iterables include strings and dictionary keys, among others. For example, we could make name a string and iterate through it in the same way we iterated through the list: name = 'Jimmy' for letter in name : print ( letter ) J i m m y You can also use list indexing notation to limit iteration to a certain portion of an iterable. name = 'Jimmy' for letter in name [ 0 : 3 ]: print ( letter ) J i m Iterables have a length, and you can find this length using the len function. print ( \"Length of\" , name , \"is\" , len ( name )) Length of Jimmy is 5","title":"For loop syntax"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#use-enumerate-to-get-both-an-index-and-an-item","text":"The enumerate function assigns an index (or counter) to each value of an iterable. It returns a tuple of (counter, value) that can be useful in for loops. For example, here we assign the index to the variable n and the value of the iterable to letter : for n , letter in enumerate ( name ): print ( \"Letter\" , n , \"-\" , letter ) Letter 0 - J Letter 1 - i Letter 2 - m Letter 3 - m Letter 4 - y","title":"Use enumerate() to get both an index and an item"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#use-zip-to-loop-over-two-iterables-simultaneously","text":"The zip function can be used to loop through two iterables simultaneously (like two sides of a zipper). Here, we use zip to iterate through two strings that have the same length for letter1 , letter2 in zip ( \"Jimmy\" , \"Heath\" ): print ( letter1 , letter2 ) J H i e m a m t y h","title":"Use zip() to loop over two iterables simultaneously"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#use-range-to-iterate-ranges-of-numbers","text":"The range function is used to construct an iterable corresponding to a set of numbers beginning at 0 and ending at a certain number: for number in range ( 6 ): print ( number ) 0 1 2 3 4 5","title":"Use range() to iterate ranges of numbers"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#logic-within-for-loops","text":"range can take multiple arguments, where the first argument is interpreted as the beginning of the range. In the example below, we combine a for loop with an if statement to print only the even numbers. This makes use of the modulo % operator we covered in the Variables lesson. for number in range ( 2 , 10 ): if number % 2 == 0 : print ( number , \"is even\" ) 2 is even 4 is even 6 is even 8 is even","title":"Logic within for loops"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#break-stops-the-loop","text":"The break statement is used to stop iterating through an iterable if some condition is met. Here, we will end our loop as soon as we encouter the number 6: for number in range ( 2 , 10 ): if number == 6 : break else : print ( number ) 2 3 4 5 A common use of for loops is to keep track of a running total of numbers. In this pattern, it's important to declare the variable that you're adding to outside the scope of the for loop. The example below makes use of the \"in place addition\" += operator, which says \"add the value on the right of the operator to the value of the variable on the left\". So x += 5 means \"add 5 to the current value of variable x . Python has similar \"in place\" operators for several other operations, including -= , *= , and /= for subtraction, multiplication, and division, respectively. my_sum = 0 for number in range ( 6 ): my_sum += number print ( \"Sum of numbers from 0 to 5 is\" , my_sum ) Sum of numbers from 0 to 5 is 15","title":"break stops the loop"},{"location":"primer/01_basic_python/Exercise_Solutions/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Python Primer Exercises (with Solutions) \u00b6 Lesson 1 - Variables, Expressions, and Functions \u00b6 Exercise: Types \u00b6 Consider the following code: var1 = 1 var2 = 1. var3 = \"one\" var4 = \"3.14159\" What is the type of var1 ? int What is the type of var2 ? float What is the type of var3 ? str What is the type of var4 ? str Exercise: Find the type \u00b6 Determine the type of the variable mystery using a built-in function mystery = { \"a\" : 1 , \"b\" : 2 } mystery = { \"a\" : 1 , \"b\" : 2 } type ( mystery ) Exercise: Converting types \u00b6 Given this: var2 = 1. var4 = \"1.0\" Explain in simple terms what float(var4) does. Explain in simple terms what str(var2) does. var2 = 1. var4 = \"1.0\" ## float(var4) turns var4 from a str to a float float ( var4 ) ## str(var2) turns var2 from a float to a str str ( var2 ) Exercise: Imports \u00b6 Fill in the blanks so that the two programs below run without errors. import __ print ( \"The current directory is {} \" . format ( os . getcwd ())) import ____ print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 ))) import os print ( \"The current directory is {} \" . format ( os . getcwd ())) import math print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 ))) Lesson 2: Lists and Strings \u00b6 Exercise: Slicing \u00b6 What does the following print: material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) In words, explain what does material[low:high] do? (where low and high are arbitrary numbers) material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) ## it returns a slice of element from position low to position high (starting from 0), e.g. material [ 2 : 4 ] In words, explain what does material[low:] do? (where low is an arbitrary number) ## it returns everything in element starting from position low, e.g. material [ 2 :] In words, explain what does material[:high] do? (where low is an arbitrary number) ## it returns everything in element before position high, e.g. material [: 2 ] What does material[:] do? ## it returns the entire string material [:] What about material[::2] ? material[::-1] ? ## material[::2] returns every second character of material material [:: 2 ] ## material[:-1] returns every character, in reverse order material [:: - 1 ] Exercise: Fill in the blanks \u00b6 Fill in the blanks so that the program below produces the output shown. values = ____ values . ____ ( 1 ) values . ____ ( 3 ) values . ____ ( 5 ) print ( 'first time:' , values ) values = values [ ____ ] print ( 'second time:' , values ) \u00b6 first time: [1, 3, 5] second time: [3, 5] values = [] values . append ( 1 ) values . append ( 3 ) values . append ( 5 ) print ( 'first time:' , values ) values = values [ 1 :] print ( 'second time:' , values ) Exercise: From strings to lists and back \u00b6 Given this: print ( 'string to list:' , list ( 'tin' )) print ( 'list to string:' , '-' . join ([ 'g' , 'o' , 'l' , 'd' ])) \u00b6 ['t', 'i', 'n'] 'g-o-l-d' Explain in simple terms what list('some string') does. ## list('some string') returns a list, where each element of the list is one character of the string (including spaces), e.g. list ( 'some string' ) 2. What does ' <=> '.join(['x', 'y']) generate? ## '.'.join(list) returns the string of every element in a list, separated by the str that precedes 'join' ' <=> ' . join ([ 'x' , 'y' , 'z' ]) Exercise: Sort and Sorted \u00b6 What do these two programs print? In simple terms, explain the difference between sorted(letters) and letters.sort() . ## Program A letters = list ( 'gold' ) result = sorted ( letters ) print ( 'letters is' , letters , 'and result is' , result ) \u00b6 ## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result ) sorted(letters) returns a new list containing the elements of letters sorted alphebetically ## Program A letters = list ( 'gold' ) result = sorted ( letters ) print ( 'letters is' , letters , 'and result is' , result ) letters.sort() sorts letters alphabetically and doesn't return anyting ( result is None ) ## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result ) Exercise: Copying (or Not) \u00b6 What do these two programs print? In simple terms, explain the difference between new = old and new = old[:] . ## Program A old = list ( 'gold' ) new = old # simple assignment new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) \u00b6 ## Program B old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) Because list is a mutable type, assignment of a list to another variable creates a reference from new to old in memory. Therefore, modifying new also modifies old old = list ( 'gold' ) new = old # simple assignment new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) On the other hand, a slice of a list is immutable , so assigning a slice of old to new creates a copy that can be modified independently of old old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) Lesson 3: For loops \u00b6 Exercise: write a for loop that computes the sum of all of the squares from 2 to 11. \u00b6 s = 0 for i in range ( 10 ): s += pow ( i + 2 , 2 ) print ( s ) Exercise: write a for loop that prints each item in the list friends , but stops when it encounters the third value \u00b6 friends = [\"Rachel\", \"Monica\", \"Chandler\", \"Ross\", \"Joey\"] friends = [ \"Rachel\" , \"Monica\" , \"Chandler\" , \"Ross\" , \"Joey\" ] for i , friend in enumerate ( friends ): if i == 3 : break else : print ( friend ) Exercise: Explain in a few words what happens when you call zip on two iterables that have different lengths \u00b6 zip will stop when it reaches the end of the shorter iterable s1 = 'Jim' s2 = 'Spock' for a , b in zip ( s1 , s2 ): print ( a , b ) Exercise (bonus): Write a Python program to construct the following pattern, using a nested for loop. \u00b6 * * * * * * * * * * * * * * * * * * * * * * * * * Hint: by default the print function inserts a newline character at the end of every line it prints. To suppress this, set the end argument to \"\", like print(\"something\", end=\"\") Hint: you can iterate through a range of numbers in reverse order by passing a negative number as a third argument to range , e.g. range(0,10,-1) n = 5 for i in range ( n ): # rows for j in range ( i ): # columns print ( '* ' , end = \"\" ) print ( '' ) for i in range ( n , 0 , - 1 ): for j in range ( i ): print ( '* ' , end = \"\" ) print ( '' )","title":"Exercise Solutions"},{"location":"primer/01_basic_python/Exercise_Solutions/#python-primer-exercises-with-solutions","text":"","title":"Python Primer Exercises (with Solutions)"},{"location":"primer/01_basic_python/Exercise_Solutions/#lesson-1-variables-expressions-and-functions","text":"","title":"Lesson 1 - Variables, Expressions, and Functions"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-types","text":"Consider the following code: var1 = 1 var2 = 1. var3 = \"one\" var4 = \"3.14159\" What is the type of var1 ? int What is the type of var2 ? float What is the type of var3 ? str What is the type of var4 ? str","title":"Exercise: Types"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-find-the-type","text":"Determine the type of the variable mystery using a built-in function mystery = { \"a\" : 1 , \"b\" : 2 } mystery = { \"a\" : 1 , \"b\" : 2 } type ( mystery )","title":"Exercise: Find the type"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-converting-types","text":"Given this: var2 = 1. var4 = \"1.0\" Explain in simple terms what float(var4) does. Explain in simple terms what str(var2) does. var2 = 1. var4 = \"1.0\" ## float(var4) turns var4 from a str to a float float ( var4 ) ## str(var2) turns var2 from a float to a str str ( var2 )","title":"Exercise: Converting types"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-imports","text":"Fill in the blanks so that the two programs below run without errors. import __ print ( \"The current directory is {} \" . format ( os . getcwd ())) import ____ print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 ))) import os print ( \"The current directory is {} \" . format ( os . getcwd ())) import math print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 )))","title":"Exercise: Imports"},{"location":"primer/01_basic_python/Exercise_Solutions/#lesson-2-lists-and-strings","text":"","title":"Lesson 2: Lists and Strings"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-slicing","text":"What does the following print: material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) In words, explain what does material[low:high] do? (where low and high are arbitrary numbers) material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) ## it returns a slice of element from position low to position high (starting from 0), e.g. material [ 2 : 4 ] In words, explain what does material[low:] do? (where low is an arbitrary number) ## it returns everything in element starting from position low, e.g. material [ 2 :] In words, explain what does material[:high] do? (where low is an arbitrary number) ## it returns everything in element before position high, e.g. material [: 2 ] What does material[:] do? ## it returns the entire string material [:] What about material[::2] ? material[::-1] ? ## material[::2] returns every second character of material material [:: 2 ] ## material[:-1] returns every character, in reverse order material [:: - 1 ]","title":"Exercise: Slicing"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-fill-in-the-blanks","text":"Fill in the blanks so that the program below produces the output shown.","title":"Exercise: Fill in the blanks"},{"location":"primer/01_basic_python/Exercise_Solutions/#values-____-values____1-values____3-values____5-printfirst-time-values-values-values____-printsecond-time-values","text":"first time: [1, 3, 5] second time: [3, 5] values = [] values . append ( 1 ) values . append ( 3 ) values . append ( 5 ) print ( 'first time:' , values ) values = values [ 1 :] print ( 'second time:' , values )","title":"values = ____\nvalues.____(1)\nvalues.____(3)\nvalues.____(5)\nprint(&#39;first time:&#39;, values)\nvalues = values[____]\nprint(&#39;second time:&#39;, values)\n"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-from-strings-to-lists-and-back","text":"Given this:","title":"Exercise: From strings to lists and back"},{"location":"primer/01_basic_python/Exercise_Solutions/#printstring-to-list-listtin-printlist-to-string-joing-o-l-d","text":"['t', 'i', 'n'] 'g-o-l-d' Explain in simple terms what list('some string') does. ## list('some string') returns a list, where each element of the list is one character of the string (including spaces), e.g. list ( 'some string' ) 2. What does ' <=> '.join(['x', 'y']) generate? ## '.'.join(list) returns the string of every element in a list, separated by the str that precedes 'join' ' <=> ' . join ([ 'x' , 'y' , 'z' ])","title":"print(&#39;string to list:&#39;, list(&#39;tin&#39;))\nprint(&#39;list to string:&#39;, &#39;-&#39;.join([&#39;g&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;]))\n"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-sort-and-sorted","text":"What do these two programs print? In simple terms, explain the difference between sorted(letters) and letters.sort() .","title":"Exercise: Sort and Sorted"},{"location":"primer/01_basic_python/Exercise_Solutions/#program-a-letters-listgold-result-sortedletters-printletters-is-letters-and-result-is-result","text":"## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result ) sorted(letters) returns a new list containing the elements of letters sorted alphebetically ## Program A letters = list ( 'gold' ) result = sorted ( letters ) print ( 'letters is' , letters , 'and result is' , result ) letters.sort() sorts letters alphabetically and doesn't return anyting ( result is None ) ## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result )","title":"## Program A\nletters = list(&#39;gold&#39;)\nresult = sorted(letters)\nprint(&#39;letters is&#39;, letters, &#39;and result is&#39;, result)\n"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-copying-or-not","text":"What do these two programs print? In simple terms, explain the difference between new = old and new = old[:] .","title":"Exercise: Copying (or Not)"},{"location":"primer/01_basic_python/Exercise_Solutions/#program-a-old-listgold-new-old-simple-assignment-new0-d-printnew-is-new-and-old-is-old","text":"## Program B old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) Because list is a mutable type, assignment of a list to another variable creates a reference from new to old in memory. Therefore, modifying new also modifies old old = list ( 'gold' ) new = old # simple assignment new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) On the other hand, a slice of a list is immutable , so assigning a slice of old to new creates a copy that can be modified independently of old old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old )","title":"## Program A\nold = list(&#39;gold&#39;)\nnew = old      # simple assignment\nnew[0] = &#39;D&#39;\nprint(&#39;new is&#39;, new, &#39;and old is&#39;, old)\n"},{"location":"primer/01_basic_python/Exercise_Solutions/#lesson-3-for-loops","text":"","title":"Lesson 3: For loops"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-write-a-for-loop-that-computes-the-sum-of-all-of-the-squares-from-2-to-11","text":"s = 0 for i in range ( 10 ): s += pow ( i + 2 , 2 ) print ( s )","title":"Exercise: write a for loop that computes the sum of all of the squares from 2 to 11."},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-write-a-for-loop-that-prints-each-item-in-the-list-friends-but-stops-when-it-encounters-the-third-value","text":"friends = [\"Rachel\", \"Monica\", \"Chandler\", \"Ross\", \"Joey\"] friends = [ \"Rachel\" , \"Monica\" , \"Chandler\" , \"Ross\" , \"Joey\" ] for i , friend in enumerate ( friends ): if i == 3 : break else : print ( friend )","title":"Exercise: write a for loop that prints each item in the list friends, but stops when it encounters the third value"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-explain-in-a-few-words-what-happens-when-you-call-zip-on-two-iterables-that-have-different-lengths","text":"zip will stop when it reaches the end of the shorter iterable s1 = 'Jim' s2 = 'Spock' for a , b in zip ( s1 , s2 ): print ( a , b )","title":"Exercise: Explain in a few words what happens when you call zip on two iterables that have different lengths"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-bonus-write-a-python-program-to-construct-the-following-pattern-using-a-nested-for-loop","text":"* * * * * * * * * * * * * * * * * * * * * * * * * Hint: by default the print function inserts a newline character at the end of every line it prints. To suppress this, set the end argument to \"\", like print(\"something\", end=\"\") Hint: you can iterate through a range of numbers in reverse order by passing a negative number as a third argument to range , e.g. range(0,10,-1) n = 5 for i in range ( n ): # rows for j in range ( i ): # columns print ( '* ' , end = \"\" ) print ( '' ) for i in range ( n , 0 , - 1 ): for j in range ( i ): print ( '* ' , end = \"\" ) print ( '' )","title":"Exercise (bonus): Write a Python program to construct the following pattern, using a nested for loop."},{"location":"primer/01_basic_python/Exercises/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Python Primer Exercises (with Solutions) \u00b6 Lesson 1 - Variables, Expressions, and Functions \u00b6 Exercise: Types \u00b6 Consider the following code: var1 = 1 var2 = 1. var3 = \"one\" var4 = \"3.14159\" What is the type of var1 ? What is the type of var2 ? What is the type of var3 ? What is the type of var4 ? Exercise: Find the type \u00b6 Determine the type of the variable mystery using a built-in function mystery = { \"a\" : 1 , \"b\" : 2 } Exercise: Converting types \u00b6 Given this: var2 = 1. var4 = \"1.0\" Explain in simple terms what float(var4) does. Explain in simple terms what str(var2) does. Exercise: Imports \u00b6 Fill in the blanks so that the two programs below run without errors. import __ print ( \"The current directory is {} \" . format ( os . getcwd ())) import ____ print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 ))) Lesson 2: Lists and Strings \u00b6 Exercise: Slicing \u00b6 What does the following print: material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) In words, explain what does material[low:high] do? (where low and high are arbitrary numbers) In words, explain what does material[low:] do? (where low is an arbitrary number) In words, explain what does material[:high] do? (where low is an arbitrary number) What does material[:] do? What about material[::2] ? material[::-1] ? Exercise: Fill in the blanks \u00b6 Fill in the blanks so that the program below produces the output shown. values = ____ values . ____ ( 1 ) values . ____ ( 3 ) values . ____ ( 5 ) print ( 'first time:' , values ) values = values [ ____ ] print ( 'second time:' , values ) \u00b6 first time: [1, 3, 5] second time: [3, 5] Exercise: From strings to lists and back \u00b6 Given this: print ( 'string to list:' , list ( 'tin' )) print ( 'list to string:' , '-' . join ([ 'g' , 'o' , 'l' , 'd' ])) \u00b6 ['t', 'i', 'n'] 'g-o-l-d' Explain in simple terms what list('some string') does. 2. What does ' <=> '.join(['x', 'y']) generate? Exercise: Sort and Sorted \u00b6 What do these two programs print? In simple terms, explain the difference between sorted(letters) and letters.sort() . ## Program A letters = list ( 'gold' ) result = sorted ( letters ) print ( 'letters is' , letters , 'and result is' , result ) \u00b6 ## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result ) Exercise: Copying (or Not) \u00b6 What do these two programs print? In simple terms, explain the difference between new = old and new = old[:] . ## Program A old = list ( 'gold' ) new = old # simple assignment new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) \u00b6 ## Program B old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) Lesson 3: For loops \u00b6 Exercise: write a for loop that computes the sum of all of the squares from 2 to 11. \u00b6 Exercise: write a for loop that prints each item in the list friends , but stops when it encounters the third value \u00b6 friends = [\"Rachel\", \"Monica\", \"Chandler\", \"Ross\", \"Joey\"] Exercise: Explain in a few words what happens when you call zip on two iterables that have different lengths \u00b6 zip will stop when it reaches the end of the shorter iterable Exercise (bonus): Write a Python program to construct the following pattern, using a nested for loop. \u00b6 * * * * * * * * * * * * * * * * * * * * * * * * * Hint: by default the print function inserts a newline character at the end of every line it prints. To suppress this, set the end argument to \"\", like print(\"something\", end=\"\") Hint: you can iterate through a range of numbers in reverse order by passing a negative number as a third argument to range , e.g. range(0,10,-1)","title":"Exercises"},{"location":"primer/01_basic_python/Exercises/#python-primer-exercises-with-solutions","text":"","title":"Python Primer Exercises (with Solutions)"},{"location":"primer/01_basic_python/Exercises/#lesson-1-variables-expressions-and-functions","text":"","title":"Lesson 1 - Variables, Expressions, and Functions"},{"location":"primer/01_basic_python/Exercises/#exercise-types","text":"Consider the following code: var1 = 1 var2 = 1. var3 = \"one\" var4 = \"3.14159\" What is the type of var1 ? What is the type of var2 ? What is the type of var3 ? What is the type of var4 ?","title":"Exercise: Types"},{"location":"primer/01_basic_python/Exercises/#exercise-find-the-type","text":"Determine the type of the variable mystery using a built-in function mystery = { \"a\" : 1 , \"b\" : 2 }","title":"Exercise: Find the type"},{"location":"primer/01_basic_python/Exercises/#exercise-converting-types","text":"Given this: var2 = 1. var4 = \"1.0\" Explain in simple terms what float(var4) does. Explain in simple terms what str(var2) does.","title":"Exercise: Converting types"},{"location":"primer/01_basic_python/Exercises/#exercise-imports","text":"Fill in the blanks so that the two programs below run without errors. import __ print ( \"The current directory is {} \" . format ( os . getcwd ())) import ____ print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 )))","title":"Exercise: Imports"},{"location":"primer/01_basic_python/Exercises/#lesson-2-lists-and-strings","text":"","title":"Lesson 2: Lists and Strings"},{"location":"primer/01_basic_python/Exercises/#exercise-slicing","text":"What does the following print: material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) In words, explain what does material[low:high] do? (where low and high are arbitrary numbers) In words, explain what does material[low:] do? (where low is an arbitrary number) In words, explain what does material[:high] do? (where low is an arbitrary number) What does material[:] do? What about material[::2] ? material[::-1] ?","title":"Exercise: Slicing"},{"location":"primer/01_basic_python/Exercises/#exercise-fill-in-the-blanks","text":"Fill in the blanks so that the program below produces the output shown.","title":"Exercise: Fill in the blanks"},{"location":"primer/01_basic_python/Exercises/#values-____-values____1-values____3-values____5-printfirst-time-values-values-values____-printsecond-time-values","text":"first time: [1, 3, 5] second time: [3, 5]","title":"values = ____\nvalues.____(1)\nvalues.____(3)\nvalues.____(5)\nprint(&#39;first time:&#39;, values)\nvalues = values[____]\nprint(&#39;second time:&#39;, values)\n"},{"location":"primer/01_basic_python/Exercises/#exercise-from-strings-to-lists-and-back","text":"Given this:","title":"Exercise: From strings to lists and back"},{"location":"primer/01_basic_python/Exercises/#printstring-to-list-listtin-printlist-to-string-joing-o-l-d","text":"['t', 'i', 'n'] 'g-o-l-d' Explain in simple terms what list('some string') does. 2. What does ' <=> '.join(['x', 'y']) generate?","title":"print(&#39;string to list:&#39;, list(&#39;tin&#39;))\nprint(&#39;list to string:&#39;, &#39;-&#39;.join([&#39;g&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;]))\n"},{"location":"primer/01_basic_python/Exercises/#exercise-sort-and-sorted","text":"What do these two programs print? In simple terms, explain the difference between sorted(letters) and letters.sort() .","title":"Exercise: Sort and Sorted"},{"location":"primer/01_basic_python/Exercises/#program-a-letters-listgold-result-sortedletters-printletters-is-letters-and-result-is-result","text":"## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result )","title":"## Program A\nletters = list(&#39;gold&#39;)\nresult = sorted(letters)\nprint(&#39;letters is&#39;, letters, &#39;and result is&#39;, result)\n"},{"location":"primer/01_basic_python/Exercises/#exercise-copying-or-not","text":"What do these two programs print? In simple terms, explain the difference between new = old and new = old[:] .","title":"Exercise: Copying (or Not)"},{"location":"primer/01_basic_python/Exercises/#program-a-old-listgold-new-old-simple-assignment-new0-d-printnew-is-new-and-old-is-old","text":"## Program B old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old )","title":"## Program A\nold = list(&#39;gold&#39;)\nnew = old      # simple assignment\nnew[0] = &#39;D&#39;\nprint(&#39;new is&#39;, new, &#39;and old is&#39;, old)\n"},{"location":"primer/01_basic_python/Exercises/#lesson-3-for-loops","text":"","title":"Lesson 3: For loops"},{"location":"primer/01_basic_python/Exercises/#exercise-write-a-for-loop-that-computes-the-sum-of-all-of-the-squares-from-2-to-11","text":"","title":"Exercise: write a for loop that computes the sum of all of the squares from 2 to 11."},{"location":"primer/01_basic_python/Exercises/#exercise-write-a-for-loop-that-prints-each-item-in-the-list-friends-but-stops-when-it-encounters-the-third-value","text":"friends = [\"Rachel\", \"Monica\", \"Chandler\", \"Ross\", \"Joey\"]","title":"Exercise: write a for loop that prints each item in the list friends, but stops when it encounters the third value"},{"location":"primer/01_basic_python/Exercises/#exercise-explain-in-a-few-words-what-happens-when-you-call-zip-on-two-iterables-that-have-different-lengths","text":"zip will stop when it reaches the end of the shorter iterable","title":"Exercise: Explain in a few words what happens when you call zip on two iterables that have different lengths"},{"location":"primer/01_basic_python/Exercises/#exercise-bonus-write-a-python-program-to-construct-the-following-pattern-using-a-nested-for-loop","text":"* * * * * * * * * * * * * * * * * * * * * * * * * Hint: by default the print function inserts a newline character at the end of every line it prints. To suppress this, set the end argument to \"\", like print(\"something\", end=\"\") Hint: you can iterate through a range of numbers in reverse order by passing a negative number as a third argument to range , e.g. range(0,10,-1)","title":"Exercise (bonus): Write a Python program to construct the following pattern, using a nested for loop."},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Building Basic Logic in Python \u00b6 Lesson 5: Conditionals \u00b6 In our work, we often want to our programs to be make decisions based on what's going on at the time. Like most other programming languages, python supports conditional statements . The way in which we make decisions in our code based on conditions is through the if statement. Booleans \u00b6 The boolean, or bool , datatype in Python is useful for logic expressions, and can either be True or False . print ( 3 == 2 ) False mybool = 3 > 2 print ( \"My boolean type = \" , type ( mybool )) print ( \"My boolean value = \" , mybool ) My boolean type = <class 'bool'> My boolean value = True The if Statement \u00b6 Let's start with an illustrative example of the state of matter of water (H 2 O) based on the temperature: water_temperature = - 1 # degrees celsius Below is the simple if statement: \"if the temperature of the water is greater than 100 \u00b0C, it must be boiling\" if water_temperature > 100 : print ( 'Boiling!' ) Now, let's add an else catch to our if statement: \"if ... greater than ..., __otherwise__, the water is not boiling\" if water_temperature > 100 : print ( 'Boiling!' ) else : print ( 'Not boiling!' ) Not boiling! We can increase the number of levels of if statement in the following manner: if (condition #1): execute code for case #1 ... . . . elif (condition #k): execute code for case #k ... . . . elif (condition #n): execute code for case #n ... else: execute \"catch all\" case ... In principle, there is no limit to the number of intermediate elif or \"else, if\" checks. water_temperature = - 5 if water_temperature > 100 : print ( 'Boiling!' ) elif water_temperature > 0 : print ( 'Liquid!' ) else : print ( 'Solid!' ) Solid! Note that conditions are demarcated using indentation . This is a contentious property of Python, but is implemented primarily because it makes code much easier to read. Note also that the indentation level can be almost any combination of whitespace characters (tabs and spaces), but elements of the same indentation block must use the same type of indentation. Because it gets confusing to use multiple types, the python style guide strongly recommends using 4 spaces to indent, which is the default in the jupyter notebook for example. This is sometimes more difficult to toggle in text editors, but most of them have online resources for setting up your text editor to use tabs and indentation in a way that conforms to python's style. What is truth? \u00b6 We can typecast another datatype as bool using bool() (we can do this for other fundamental datatypes such as int and float ). The results of some of these casting examples are quite interesting! bool ( 5 ) True bool ( \"beauty\" ) True bool ( \"\" ) False bool ([]) False bool ({}) False bool ( 0 ) False bool ( None ) False Be very careful with this! Python's \"falsy\" functionality makes code fun to write and easier to read, but can cause problems. For example, many people will put a simple if statement as a conditional on whether the variable is stored as a falsy value (e. g. None). Part of the reason we're mentioning this today is that this is often the case in codes that use a lot of serialization like pymatgen. temperature = 0 # store the temperature as a number if you want it to do something if temperature : print ( \"Temperature is\" , temperature ) Lesson 6: Sets and Dictionaries \u00b6 Use a set to store unique values \u00b6 Possible to initialize a set with {...} But must use set() to create an empty set primes = { 2 , 3 , 5 , 7 } print ( 'is 3 prime?' , 3 in primes ) print ( 'is 9 prime?' , 9 in primes ) is 3 prime? True is 9 prime? False * Intersection, union, etc. odds = { 3 , 5 , 7 , 9 } print ( 'intersection' , odds & primes ) print ( 'union' , odds | primes ) intersection {3, 5, 7} union {2, 3, 5, 7, 9} Sets are mutable \u00b6 But only store unique values primes . add ( 11 ) print ( 'primes becomes' , primes ) primes . discard ( 7 ) print ( 'after removal' , primes ) primes . add ( 11 ) print ( 'after adding 11 again' , primes ) primes becomes {2, 3, 5, 7, 11} after removal {2, 3, 5, 11} after adding 11 again {2, 3, 5, 11} Sets are unordered \u00b6 Values are stored by hashing , which is intentionally as random as possible names = { 'Hopper' , 'Cori' , 'Kohn' } for n in names : print ( n ) Kohn Cori Hopper Use a dictionary to store key/value pairs \u00b6 Equivalently, store extra information with elements of a set. birthdays = { 'Hopper' : 1906 , 'Cori' : 1896 } print ( birthdays [ 'Hopper' ]) birthdays [ 'Kohn' ] = 1823 # oops birthdays [ 'Kohn' ] = 1923 # that's better print ( birthdays ) 1906 {'Hopper': 1906, 'Cori': 1896, 'Kohn': 1923} * Just an accident that keys are in order of when entered. * Like sets, dictionaries store keys by hashing, which is as random as possible Set values and dictionary keys must be immutable \u00b6 Changing them after insertion would leave data in the wrong place Use a tuple for multi-valued keys people = {( 'Grace' , 'Hopper' ): 1906 , ( 'Gerty' , 'Cory' ): 1896 , ( 'Walter' , 'Kohn' ): 1923 } You can destructure a tuple in the heading of a for loop: for ( first , last ) in people : print ( first , 'was born in' , people [( first , last )]) Grace was born in 1906 Gerty was born in 1896 Walter was born in 1923 Lesson 7: Writing Functions \u00b6 Break down programs into functions \u00b6 Readability: human beings can only keep a few items in working memory at a time. Encapsulate complexity so that we can treat it as a single \u201cthing\u201d. Reuse: write one time, use many times. Testing: components with well-defined boundaries are easier to test. Define a function using def with a name, parameters, and a block of code \u00b6 Function name must obey the same rules as variable names Put parameters in parentheses Then a colon, then an indented code block # Empty parentheses if the function doesn't take any inputs: def print_greeting (): print ( 'Hello!' ) Arguments in call are matched to parameters in definition \u00b6 def print_date ( year , month , day ): joined = str ( year ) + '/' + str ( month ) + '/' + str ( day ) print ( joined ) print_date ( 1871 , 3 , 19 ) 1871/3/19 Functions may return a result to their caller using return \u00b6 May occur anywhere in the function But functions are easier to understand if return occurs At the start, to handle special cases At the very end, with a final result Functions without explicit return produce None def average ( values ): if len ( values ) == 0 : return None return sum ( values ) / len ( values ) a = average ([ 1 , 3 , 4 ]) print ( 'average of actual values:' , a ) average of actual values: 2.6666666666666665 print ( 'average of empty list:' , average ([])) average of empty list: None result = print_date ( 1871 , 3 , 19 ) print ( 'result of call is:' , result ) 1871/3/19 result of call is: None Can specify default values for parameters \u00b6 All paramters with defaults must come after all parameters without. Otherwise, argument-to-parameter matching would be ambigious. Makes common cases simpler, and signals intent def my_sum ( values , scale = 1.0 ): result = 0.0 for v in values : result += v * scale return result print ( 'my_sum with default:' , my_sum ([ 1 , 2 , 3 ])) print ( 'sum with factor:' , my_sum ([ 1 , 2 , 3 ], 0.5 )) my_sum with default: 6.0 sum with factor: 3.0 # Succinctly... def my_sum ( values , scale = 1.0 ): return sum ( v * scale for v in values ) Can pass parameters by name \u00b6 Helpful when functions have lots of options If you have a procedure with ten parameters, you probably missed some. -- from \"Epigrams in Programming\", by Alan J. Perlis print ( 'out of order:' , my_sum ( scale = 0.25 , values = [ 1 , 2 , 3 ])) out of order: 1.5 Functions can take a variable number of arguments \u00b6 Prefix at most one parameter's name with * . By convention, everyone calls the parameters *args . All \"extra\" paramters are put in a list-like structure assigned to that parameter def total ( scale , * args ): return sum ( a * scale for a in args ) print ( 'with one value:' , total ( 0.5 , 1 )) print ( 'with two values:' , total ( 0.5 , 1 , 3 )) with one value: 0.5 with two values: 2.0 Functions can return multiple values \u00b6 This is just a special case of many-to-many assignment red , green , blue = 10 , 50 , 180 def order ( a , b ): if a < b : return a , b else : return b , a low , high = order ( 10 , 5 ) print ( 'order(10, 5):' , low , high ) order(10, 5): 5 10","title":"Advanced Python"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#building-basic-logic-in-python","text":"","title":"Building Basic Logic in Python"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#lesson-5-conditionals","text":"In our work, we often want to our programs to be make decisions based on what's going on at the time. Like most other programming languages, python supports conditional statements . The way in which we make decisions in our code based on conditions is through the if statement.","title":"Lesson 5: Conditionals"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#booleans","text":"The boolean, or bool , datatype in Python is useful for logic expressions, and can either be True or False . print ( 3 == 2 ) False mybool = 3 > 2 print ( \"My boolean type = \" , type ( mybool )) print ( \"My boolean value = \" , mybool ) My boolean type = <class 'bool'> My boolean value = True","title":"Booleans"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#the-if-statement","text":"Let's start with an illustrative example of the state of matter of water (H 2 O) based on the temperature: water_temperature = - 1 # degrees celsius Below is the simple if statement: \"if the temperature of the water is greater than 100 \u00b0C, it must be boiling\" if water_temperature > 100 : print ( 'Boiling!' ) Now, let's add an else catch to our if statement: \"if ... greater than ..., __otherwise__, the water is not boiling\" if water_temperature > 100 : print ( 'Boiling!' ) else : print ( 'Not boiling!' ) Not boiling! We can increase the number of levels of if statement in the following manner: if (condition #1): execute code for case #1 ... . . . elif (condition #k): execute code for case #k ... . . . elif (condition #n): execute code for case #n ... else: execute \"catch all\" case ... In principle, there is no limit to the number of intermediate elif or \"else, if\" checks. water_temperature = - 5 if water_temperature > 100 : print ( 'Boiling!' ) elif water_temperature > 0 : print ( 'Liquid!' ) else : print ( 'Solid!' ) Solid! Note that conditions are demarcated using indentation . This is a contentious property of Python, but is implemented primarily because it makes code much easier to read. Note also that the indentation level can be almost any combination of whitespace characters (tabs and spaces), but elements of the same indentation block must use the same type of indentation. Because it gets confusing to use multiple types, the python style guide strongly recommends using 4 spaces to indent, which is the default in the jupyter notebook for example. This is sometimes more difficult to toggle in text editors, but most of them have online resources for setting up your text editor to use tabs and indentation in a way that conforms to python's style.","title":"The if Statement"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#what-is-truth","text":"We can typecast another datatype as bool using bool() (we can do this for other fundamental datatypes such as int and float ). The results of some of these casting examples are quite interesting! bool ( 5 ) True bool ( \"beauty\" ) True bool ( \"\" ) False bool ([]) False bool ({}) False bool ( 0 ) False bool ( None ) False Be very careful with this! Python's \"falsy\" functionality makes code fun to write and easier to read, but can cause problems. For example, many people will put a simple if statement as a conditional on whether the variable is stored as a falsy value (e. g. None). Part of the reason we're mentioning this today is that this is often the case in codes that use a lot of serialization like pymatgen. temperature = 0 # store the temperature as a number if you want it to do something if temperature : print ( \"Temperature is\" , temperature )","title":"What is truth?"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#lesson-6-sets-and-dictionaries","text":"","title":"Lesson 6: Sets and Dictionaries"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#use-a-set-to-store-unique-values","text":"Possible to initialize a set with {...} But must use set() to create an empty set primes = { 2 , 3 , 5 , 7 } print ( 'is 3 prime?' , 3 in primes ) print ( 'is 9 prime?' , 9 in primes ) is 3 prime? True is 9 prime? False * Intersection, union, etc. odds = { 3 , 5 , 7 , 9 } print ( 'intersection' , odds & primes ) print ( 'union' , odds | primes ) intersection {3, 5, 7} union {2, 3, 5, 7, 9}","title":"Use a set to store unique values"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#sets-are-mutable","text":"But only store unique values primes . add ( 11 ) print ( 'primes becomes' , primes ) primes . discard ( 7 ) print ( 'after removal' , primes ) primes . add ( 11 ) print ( 'after adding 11 again' , primes ) primes becomes {2, 3, 5, 7, 11} after removal {2, 3, 5, 11} after adding 11 again {2, 3, 5, 11}","title":"Sets are mutable"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#sets-are-unordered","text":"Values are stored by hashing , which is intentionally as random as possible names = { 'Hopper' , 'Cori' , 'Kohn' } for n in names : print ( n ) Kohn Cori Hopper","title":"Sets are unordered"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#use-a-dictionary-to-store-keyvalue-pairs","text":"Equivalently, store extra information with elements of a set. birthdays = { 'Hopper' : 1906 , 'Cori' : 1896 } print ( birthdays [ 'Hopper' ]) birthdays [ 'Kohn' ] = 1823 # oops birthdays [ 'Kohn' ] = 1923 # that's better print ( birthdays ) 1906 {'Hopper': 1906, 'Cori': 1896, 'Kohn': 1923} * Just an accident that keys are in order of when entered. * Like sets, dictionaries store keys by hashing, which is as random as possible","title":"Use a dictionary to store key/value pairs"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#set-values-and-dictionary-keys-must-be-immutable","text":"Changing them after insertion would leave data in the wrong place Use a tuple for multi-valued keys people = {( 'Grace' , 'Hopper' ): 1906 , ( 'Gerty' , 'Cory' ): 1896 , ( 'Walter' , 'Kohn' ): 1923 } You can destructure a tuple in the heading of a for loop: for ( first , last ) in people : print ( first , 'was born in' , people [( first , last )]) Grace was born in 1906 Gerty was born in 1896 Walter was born in 1923","title":"Set values and dictionary keys must be immutable"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#lesson-7-writing-functions","text":"","title":"Lesson 7: Writing Functions"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#break-down-programs-into-functions","text":"Readability: human beings can only keep a few items in working memory at a time. Encapsulate complexity so that we can treat it as a single \u201cthing\u201d. Reuse: write one time, use many times. Testing: components with well-defined boundaries are easier to test.","title":"Break down programs into functions"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#define-a-function-using-def-with-a-name-parameters-and-a-block-of-code","text":"Function name must obey the same rules as variable names Put parameters in parentheses Then a colon, then an indented code block # Empty parentheses if the function doesn't take any inputs: def print_greeting (): print ( 'Hello!' )","title":"Define a function using def with a name, parameters, and a block of code"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#arguments-in-call-are-matched-to-parameters-in-definition","text":"def print_date ( year , month , day ): joined = str ( year ) + '/' + str ( month ) + '/' + str ( day ) print ( joined ) print_date ( 1871 , 3 , 19 ) 1871/3/19","title":"Arguments in call are matched to parameters in definition"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#functions-may-return-a-result-to-their-caller-using-return","text":"May occur anywhere in the function But functions are easier to understand if return occurs At the start, to handle special cases At the very end, with a final result Functions without explicit return produce None def average ( values ): if len ( values ) == 0 : return None return sum ( values ) / len ( values ) a = average ([ 1 , 3 , 4 ]) print ( 'average of actual values:' , a ) average of actual values: 2.6666666666666665 print ( 'average of empty list:' , average ([])) average of empty list: None result = print_date ( 1871 , 3 , 19 ) print ( 'result of call is:' , result ) 1871/3/19 result of call is: None","title":"Functions may return a result to their caller using return"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#can-specify-default-values-for-parameters","text":"All paramters with defaults must come after all parameters without. Otherwise, argument-to-parameter matching would be ambigious. Makes common cases simpler, and signals intent def my_sum ( values , scale = 1.0 ): result = 0.0 for v in values : result += v * scale return result print ( 'my_sum with default:' , my_sum ([ 1 , 2 , 3 ])) print ( 'sum with factor:' , my_sum ([ 1 , 2 , 3 ], 0.5 )) my_sum with default: 6.0 sum with factor: 3.0 # Succinctly... def my_sum ( values , scale = 1.0 ): return sum ( v * scale for v in values )","title":"Can specify default values for parameters"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#can-pass-parameters-by-name","text":"Helpful when functions have lots of options If you have a procedure with ten parameters, you probably missed some. -- from \"Epigrams in Programming\", by Alan J. Perlis print ( 'out of order:' , my_sum ( scale = 0.25 , values = [ 1 , 2 , 3 ])) out of order: 1.5","title":"Can pass parameters by name"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#functions-can-take-a-variable-number-of-arguments","text":"Prefix at most one parameter's name with * . By convention, everyone calls the parameters *args . All \"extra\" paramters are put in a list-like structure assigned to that parameter def total ( scale , * args ): return sum ( a * scale for a in args ) print ( 'with one value:' , total ( 0.5 , 1 )) print ( 'with two values:' , total ( 0.5 , 1 , 3 )) with one value: 0.5 with two values: 2.0","title":"Functions can take a variable number of arguments"},{"location":"primer/02_building_logic/2%20-%20Python%20Primer%20-%20Part%20II/#functions-can-return-multiple-values","text":"This is just a special case of many-to-many assignment red , green , blue = 10 , 50 , 180 def order ( a , b ): if a < b : return a , b else : return b , a low , high = order ( 10 , 5 ) print ( 'order(10, 5):' , low , high ) order(10, 5): 5 10","title":"Functions can return multiple values"},{"location":"primer/02_building_logic/Exercise_Solutions/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Python Primer Part II Exercises (with Solutions) \u00b6 Lesson 5: Conditionals \u00b6 Exercise: \u00b6 Write a Python program to convert temperatures to and from celsius, fahrenheit. Formula : c/5 = f-32/9 (where c = temperature in celsius and f = temperature in fahrenheit ) Expected Output : 60\u00b0C is 140 in Fahrenheit 45\u00b0F is 7 in Celsius # gather input from the user temp = input ( \"Input the temperature you like to convert? (e.g., 45F, 102C etc.) : \" ) # parse the string of input from the user degree = int ( temp [: - 1 ]) i_convention = temp [ - 1 ] if i_convention . upper () == 'F' : result = int ( round (( 9 * degree ) / 5 + 32 )) o_convention = \"Fahrenheit\" elif i_convention . upper () == 'C' : result = int ( round (( degree - 32 ) * 5 / 9 )) o_convention = \"Celsius\" else : print ( \"Input proper convention.\" ) quit () print ( \"The temperature in\" , o_convention , \"is\" , result , \"degrees.\" ) Input the temperature you like to convert? (e.g., 45F, 102C etc.) : 100C The temperature in Celsius is 38 degrees. Exercise: \u00b6 Who discovered your favorite elements? Let's write a simple test to see which elements were discovered by discoverer A, discoverer B, and both! import os from monty.serialization import loadfn data_dir = \"./data/\" # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) from pymatgen.core import Element # The discoverers we want to explore... discover0 = \"Berkeley\" #discover0 = \"Ghiorso\" discover1 = \"Russia\" # Loop through discoverers to find which elements they discovered for element_name in discovery_dict : names = discovery_dict [ element_name ][ 'discovered_by' ] A , B = False , False for name in names : if discover0 in name : A = True if discover1 in name : B = True if A and B : print ( \"For \" , element_name , \", A and B is true!\" ) elif A : print ( \"For \" , element_name , \", A is true!\" ) elif B : print ( \"For \" , element_name , \", B is true!\" ) For Bohrium , B is true! For Dubnium , A and B is true! For Flerovium , B is true! For Livermorium , B is true! For Rutherfordium , B is true! Lesson 6: Sets and Dictionaries \u00b6 Exercise: create a histogram \u00b6 numbers = [ 1 , 0 , 1 , 2 , 0 , 0 , 1 , 2 , 1 , 3 , 1 , 0 , 2 ] count = {} for n in numbers : if n not in count : count [ n ] = 1 else : count [ n ] = count [ n ] + 1 print ( count ) {1: 5, 0: 4, 2: 3, 3: 1} Reminder: there are lots of useful Python libraries, especially the \"standard library\" that comes with Python: from collections import Counter print ( Counter ( numbers )) print ( dict ( Counter ( numbers ))) Counter({1: 5, 0: 4, 2: 3, 3: 1}) {1: 5, 0: 4, 2: 3, 3: 1} Exercise: How heavy is this molecule? \u00b6 You are given two things: a dictionary mapping atomic symbols to atomic weights ( mp_workshop.data.atomic_weights ), and a list of (atomic_symbol, count) pairs for a molecule. # Example molecules: methane = [( 'C' , 1 ), ( 'H' , 4 )] aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] Print that molecule's molecular weight. import os from monty.serialization import loadfn data_dir = \"./data/\" atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # atomic weight is 16.0423 methane = [( 'C' , 1 ), ( 'H' , 4 )] # atomic weight is 100.1421 aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] # 2. Pick a molecule to test molecule = methane # 3. Do stuff to calculate `mol_weight` mol_weight = 0.0 for specie , number in methane : mol_weight += number * atomic_weights [ specie ] print ( mol_weight ) 16.04246 Lesson 7: Writing Functions \u00b6 Exercise: Find the first \u00b6 Fill in the blanks to create a function that takes a list of numbers as an argument and returns the first negative value in the list. What does your function do if the list is empty? def first_negative ( values ): for v in values : if v < 0 : return v Exercise : Running sum \u00b6 Write a function that calculates the running sum of any number of input arguments, returning the result as a list. For example: running(1, 2) => [1, 3] running(-5, 2, 7) => [-5, -3, 4] What should running() return, and why? Exercise: How's your phase-change memory? \u00b6 A chalcogenide is a chemical compound consisting of at least one chalcogen anion (commonly restricted to \u2018S\u2019, \u2018Se\u2019, or \u2018Te\u2019) and at least one more electropositive element. Generalize the halide function below as compound_class , a function that takes a crystal and function as parameters and returns whether or not the compound is of that class. # %load code/phase_change_memory.py import random from pymatgen import Element import os from monty.serialization import loadfn data_dir = \"./data/\" crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) def halogen ( element ): return element . is_halogen def halide ( crystal ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return halogen ( anion ) def chalcogen ( element ): return element . is_chalogen def compound_class ( crystal , predicate ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return predicate ( anion ) my_crystal = random . sample ( [ c for c in crystals if halide ( c )], 1 )[ 0 ] print ( compound_class ( my_crystal , halogen ) == halide ( my_crystal )) True Lesson 8: Test your Skills \u00b6 Now it's time to put your skills to the test! \u00b6 Exercise: As a materials investigator, your team has just finished running calculations for a large number of crystal structures. Now, you want to analyze the dataset by writing functions that utilize logic (in the form of conditionals ) to parse through the datasets in the forms of dictionaries and lists . First, load the relevant datasets import os from monty.serialization import loadfn data_dir = \"./data/\" # Our crystal structures, in addition to useful elemental information crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) atomic_numbers = loadfn ( os . path . join ( data_dir , \"atomic_numbers.json\" )) atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # Names of elements associated with an element symbol (e.g. {\"Al\": \"Aluminium\"}) element_names = loadfn ( os . path . join ( data_dir , \"element_names.json\" )) # Elemental mass fraction of Earth's crust (source: https://en.wikipedia.org/wiki/Abundances_of_the_elements_(data_page)) mass_frac_earth_crust = loadfn ( os . path . join ( data_dir , \"mass_frac_earth_crust.json\" )) # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) We have the mapping from symbol \\rightarrow \\rightarrow name , now let's obtain name \\rightarrow \\rightarrow symbol (we'll need it later) print ( element_names [ \"Ag\" ]) element_symbols = { v : k for k , v in element_names . items ()} print ( element_symbols [ \"Silver\" ]) Silver Ag Next, we'll choose the set of elements that we would like to start with. Each element has a unique story associated with it. We can explore these stories with the information from the element discovery timeline. Our task: Build a function that takes a list of element symbols as input. In addition, if we want to add the elements associated with a particular materials discoverer, we can include some regex (or \"regular expression\") strings corresponding to the discoverers we would like to feature. from pymatgen.core import Element , Composition def my_element_discoverer ( elements : list = [], discoverers : list = [], prior_to : int = 2020 ): # Start with elements provided by user # (use copy() to not modify list passed to function) all_elements = elements . copy () # Loop through discoverers to find which elements they discovered # and then add them to your list for discoverer in discoverers : for element_name in discovery_dict : for name in discovery_dict [ element_name ][ 'discovered_by' ]: if discoverer in name : elem = Element ( element_symbols [ element_name ]) all_elements . append ( elem ) # Create a new list that will contain only the elements discovered # before the year you provide elements_pruned = [] for elem in all_elements : element_name = element_names [ str ( elem )] if discovery_dict [ element_name ][ 'year' ] != '?' : year_discovered = int ( discovery_dict [ element_name ][ 'year' ]) else : # Unknown discovery date (known since ancient times) year_discovered = - 2000 if year_discovered < prior_to : elem = Element ( elem ) elements_pruned . append ( elem ) all_elements = elements_pruned # Use set() to convert your list into a unique set # then recast as a list() all_elements = list ( set ( all_elements )) return all_elements Let's test out our function! Say we want to use oxygen in addition to elements discovered by scientists with Curie in their name (Marie and Pierre), as well as elements discovered by scientists in Berkeley my_elements = my_element_discoverer ( elements = [ \"O\" ], discoverers = [ \"Curie\" , \"Lawrence Berkeley\" ], prior_to = 2020 ) print ( my_elements ) [Element O, Element Db, Element Ra, Element Po] Can you spot which elements are missing? (Hint below) # Discovered by scientists at UC Berkeley my_elements = my_element_discoverer ( discoverers = [ \"Ghiorso\" ], prior_to = 2020 ) print ( my_elements ) [Element Cm, Element Bk, Element Cf, Element Es, Element Fm, Element Md, Element No, Element Lr, Element Rf, Element Sg, Element Am] Platinum was found in gold alloys in present day Columbia dating as far back as 800 BC my_elements = my_element_discoverer ( elements = [ \"Ni\" ], discoverers = [ \"Indigenous People of South America\" ], prior_to = 1800 ) print ( my_elements ) [Element Ni, Element Pt] Next, our goal is to find all of the crystals that contain the elements in our list. Once we obtain this list, it is often useful to sort these materials based on a particular metric, depending on which properties that we would like to assess. The two criteria we will use in this study are the molar mass and abundance: Molar mass = \\sum_{i=1}^N x_i n_i \\sum_{i=1}^N x_i n_i , where n_i n_i is the elemental molar mass, and x_i x_i is the molar fraction Abundance metric = \\prod_{i=1}^N a_i^{y_i} \\prod_{i=1}^N a_i^{y_i} , where a_i a_i is the mass abundance of the element i i , and y_i y_i is the mass fraction in the material import numpy as np def compute_molar_weight ( crystal ): # Obtain atomic fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) atomic_fractions = [ comp . get_atomic_fraction ( Element ( elem )) for elem in crystal [ 'elements' ]] # Obtain atomic weights of elements in material weights = [ atomic_weights [ elem ] for elem in crystal [ 'elements' ]] # Compute molar weight of material (weighted mean) molar_weight = 0.0 for elem , frac , weight in zip ( crystal [ \"elements\" ], atomic_fractions , weights ): molar_weight += frac * weight return molar_weight def compute_abundance_metric ( crystal ): # Obtain mass fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) molar_weight = compute_molar_weight ( crystal ) mass_fractions = [ comp . get_atomic_fraction ( Element ( elem )) * ( atomic_weights [ elem ] / molar_weight ) for elem in crystal [ 'elements' ]] # Obtain atomic abundances of elements in material abundances = [ mass_frac_earth_crust [ elem ] for elem in crystal [ 'elements' ]] # Compute abundance metric (geometric mean) abundance_metric = 1.0 for elem , frac , abundance in zip ( crystal [ \"elements\" ], mass_fractions , abundances ): abundance_metric *= ( 100 * abundance ) ** frac return abundance_metric crystal = crystals [ 0 ] print ( \"Material:\" , crystal [ \"pretty_formula\" ]) print ( \"Molar weight (g / mol / # atoms per formula unit) = \" , compute_molar_weight ( crystal )) print ( \"Abundance metric (% kg/kg) = \" , compute_abundance_metric ( crystal )) Material: Ca3Ge3(MoO6)2 Molar weight (g / mol / # atoms per formula unit) = 36.10134 Abundance metric (% kg/kg) = 0.022347289066530374 Now that we have our sorting metrics, let's find the materials in our dataset that contain the elements we have provided, and sort them based on the criteria above. A helpful relation: For finite sets A A and B B , B \\subseteq A B \\subseteq A if and only if B = A \\cap B B = A \\cap B def get_crystals_from_elements ( elements : list , crystals : list , sort_scheme : int = 0 ): crystals_matched = [] for crystal in crystals : crystal_elems = [ Element ( elem ) for elem in crystal [ 'elements' ]] # We can check if the material contains the elements that we have provided # (set B in A) by checking if B = intersection(A,B) intersection = set ( elements ) & set ( crystal_elems ) if set ( elements ) == intersection : crystals_matched . append ( crystal ) if sort_scheme == 0 : # Sort by molar weight sort_key = \"Molar weight (g / mol / # atoms per formula unit)\" sortable_values = [ compute_molar_weight ( crystal ) for crystal in crystals_matched ] elif sort_scheme == 1 : # Sort by abundance metric sort_key = \"Abundance metric (% kg/kg)\" sortable_values = [ compute_abundance_metric ( crystal ) for crystal in crystals_matched ] else : # Catch all case - no sorting provided sortable_values = [] print ( \"Warning: Invalid sort scheme!\" ) return [], [], \"\" if sortable_values : #print(sortable_values) # Sort crystals based on sorting metric (reverse to descending order) value_map = [{ \"value\" : v , \"crystal\" : c } for v , c in zip ( sortable_values , crystals_matched )] value_map = sorted ( value_map , key = lambda x : x [ \"value\" ], reverse = True ) #sortable_values, crystals_matched = zip(*sorted(zip(sortable_values, crystals_matched), reverse=True)) # Extract desired values after sorting sortable_values = [ x [ 'value' ] for x in value_map ] crystals_matched = [ x [ 'crystal' ] for x in value_map ] #print(sortable_values) return crystals_matched , sortable_values , sort_key We've built our functions! Now let's test them to search the materials in our dataset # The elements we would like to search our dataset elements = [ Element ( elem ) for elem in [ 'Ca' , 'O' ]] # Testing our function crystals_matched , sorted_values , sort_key = get_crystals_from_elements ( elements , crystals , sort_scheme = 0 ) # The formulas of the crystals that we searched for formulas = [ crystal [ 'pretty_formula' ] for crystal in crystals_matched ] print ( \"Number of crystals found: \" , len ( crystals_matched )) # print(formulas) Number of crystals found: 445 For a large number of materials, we often gain the most information by perfoming an analysis of how the sorting criteria is distributed. In this case, we can create a histogram of the data using the matplotlib package. import matplotlib.pyplot as plt number_of_bins = 20 plt . hist ( sorted_values , number_of_bins ) plt . ylabel ( 'Counts' ) plt . xlabel ( sort_key ) plt . show ()","title":"Exercise Solutions"},{"location":"primer/02_building_logic/Exercise_Solutions/#python-primer-part-ii-exercises-with-solutions","text":"","title":"Python Primer Part II Exercises (with Solutions)"},{"location":"primer/02_building_logic/Exercise_Solutions/#lesson-5-conditionals","text":"","title":"Lesson 5: Conditionals"},{"location":"primer/02_building_logic/Exercise_Solutions/#exercise","text":"Write a Python program to convert temperatures to and from celsius, fahrenheit. Formula : c/5 = f-32/9 (where c = temperature in celsius and f = temperature in fahrenheit ) Expected Output : 60\u00b0C is 140 in Fahrenheit 45\u00b0F is 7 in Celsius # gather input from the user temp = input ( \"Input the temperature you like to convert? (e.g., 45F, 102C etc.) : \" ) # parse the string of input from the user degree = int ( temp [: - 1 ]) i_convention = temp [ - 1 ] if i_convention . upper () == 'F' : result = int ( round (( 9 * degree ) / 5 + 32 )) o_convention = \"Fahrenheit\" elif i_convention . upper () == 'C' : result = int ( round (( degree - 32 ) * 5 / 9 )) o_convention = \"Celsius\" else : print ( \"Input proper convention.\" ) quit () print ( \"The temperature in\" , o_convention , \"is\" , result , \"degrees.\" ) Input the temperature you like to convert? (e.g., 45F, 102C etc.) : 100C The temperature in Celsius is 38 degrees.","title":"Exercise:"},{"location":"primer/02_building_logic/Exercise_Solutions/#exercise_1","text":"Who discovered your favorite elements? Let's write a simple test to see which elements were discovered by discoverer A, discoverer B, and both! import os from monty.serialization import loadfn data_dir = \"./data/\" # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) from pymatgen.core import Element # The discoverers we want to explore... discover0 = \"Berkeley\" #discover0 = \"Ghiorso\" discover1 = \"Russia\" # Loop through discoverers to find which elements they discovered for element_name in discovery_dict : names = discovery_dict [ element_name ][ 'discovered_by' ] A , B = False , False for name in names : if discover0 in name : A = True if discover1 in name : B = True if A and B : print ( \"For \" , element_name , \", A and B is true!\" ) elif A : print ( \"For \" , element_name , \", A is true!\" ) elif B : print ( \"For \" , element_name , \", B is true!\" ) For Bohrium , B is true! For Dubnium , A and B is true! For Flerovium , B is true! For Livermorium , B is true! For Rutherfordium , B is true!","title":"Exercise:"},{"location":"primer/02_building_logic/Exercise_Solutions/#lesson-6-sets-and-dictionaries","text":"","title":"Lesson 6: Sets and Dictionaries"},{"location":"primer/02_building_logic/Exercise_Solutions/#exercise-create-a-histogram","text":"numbers = [ 1 , 0 , 1 , 2 , 0 , 0 , 1 , 2 , 1 , 3 , 1 , 0 , 2 ] count = {} for n in numbers : if n not in count : count [ n ] = 1 else : count [ n ] = count [ n ] + 1 print ( count ) {1: 5, 0: 4, 2: 3, 3: 1} Reminder: there are lots of useful Python libraries, especially the \"standard library\" that comes with Python: from collections import Counter print ( Counter ( numbers )) print ( dict ( Counter ( numbers ))) Counter({1: 5, 0: 4, 2: 3, 3: 1}) {1: 5, 0: 4, 2: 3, 3: 1}","title":"Exercise: create a histogram"},{"location":"primer/02_building_logic/Exercise_Solutions/#exercise-how-heavy-is-this-molecule","text":"You are given two things: a dictionary mapping atomic symbols to atomic weights ( mp_workshop.data.atomic_weights ), and a list of (atomic_symbol, count) pairs for a molecule. # Example molecules: methane = [( 'C' , 1 ), ( 'H' , 4 )] aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] Print that molecule's molecular weight. import os from monty.serialization import loadfn data_dir = \"./data/\" atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # atomic weight is 16.0423 methane = [( 'C' , 1 ), ( 'H' , 4 )] # atomic weight is 100.1421 aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] # 2. Pick a molecule to test molecule = methane # 3. Do stuff to calculate `mol_weight` mol_weight = 0.0 for specie , number in methane : mol_weight += number * atomic_weights [ specie ] print ( mol_weight ) 16.04246","title":"Exercise: How heavy is this molecule?"},{"location":"primer/02_building_logic/Exercise_Solutions/#lesson-7-writing-functions","text":"","title":"Lesson 7: Writing Functions"},{"location":"primer/02_building_logic/Exercise_Solutions/#exercise-find-the-first","text":"Fill in the blanks to create a function that takes a list of numbers as an argument and returns the first negative value in the list. What does your function do if the list is empty? def first_negative ( values ): for v in values : if v < 0 : return v","title":"Exercise: Find the first"},{"location":"primer/02_building_logic/Exercise_Solutions/#exercise-running-sum","text":"Write a function that calculates the running sum of any number of input arguments, returning the result as a list. For example: running(1, 2) => [1, 3] running(-5, 2, 7) => [-5, -3, 4] What should running() return, and why?","title":"Exercise : Running sum"},{"location":"primer/02_building_logic/Exercise_Solutions/#exercise-hows-your-phase-change-memory","text":"A chalcogenide is a chemical compound consisting of at least one chalcogen anion (commonly restricted to \u2018S\u2019, \u2018Se\u2019, or \u2018Te\u2019) and at least one more electropositive element. Generalize the halide function below as compound_class , a function that takes a crystal and function as parameters and returns whether or not the compound is of that class. # %load code/phase_change_memory.py import random from pymatgen import Element import os from monty.serialization import loadfn data_dir = \"./data/\" crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) def halogen ( element ): return element . is_halogen def halide ( crystal ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return halogen ( anion ) def chalcogen ( element ): return element . is_chalogen def compound_class ( crystal , predicate ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return predicate ( anion ) my_crystal = random . sample ( [ c for c in crystals if halide ( c )], 1 )[ 0 ] print ( compound_class ( my_crystal , halogen ) == halide ( my_crystal )) True","title":"Exercise: How's your phase-change memory?"},{"location":"primer/02_building_logic/Exercise_Solutions/#lesson-8-test-your-skills","text":"","title":"Lesson 8: Test your Skills"},{"location":"primer/02_building_logic/Exercise_Solutions/#now-its-time-to-put-your-skills-to-the-test","text":"Exercise: As a materials investigator, your team has just finished running calculations for a large number of crystal structures. Now, you want to analyze the dataset by writing functions that utilize logic (in the form of conditionals ) to parse through the datasets in the forms of dictionaries and lists . First, load the relevant datasets import os from monty.serialization import loadfn data_dir = \"./data/\" # Our crystal structures, in addition to useful elemental information crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) atomic_numbers = loadfn ( os . path . join ( data_dir , \"atomic_numbers.json\" )) atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # Names of elements associated with an element symbol (e.g. {\"Al\": \"Aluminium\"}) element_names = loadfn ( os . path . join ( data_dir , \"element_names.json\" )) # Elemental mass fraction of Earth's crust (source: https://en.wikipedia.org/wiki/Abundances_of_the_elements_(data_page)) mass_frac_earth_crust = loadfn ( os . path . join ( data_dir , \"mass_frac_earth_crust.json\" )) # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) We have the mapping from symbol \\rightarrow \\rightarrow name , now let's obtain name \\rightarrow \\rightarrow symbol (we'll need it later) print ( element_names [ \"Ag\" ]) element_symbols = { v : k for k , v in element_names . items ()} print ( element_symbols [ \"Silver\" ]) Silver Ag Next, we'll choose the set of elements that we would like to start with. Each element has a unique story associated with it. We can explore these stories with the information from the element discovery timeline. Our task: Build a function that takes a list of element symbols as input. In addition, if we want to add the elements associated with a particular materials discoverer, we can include some regex (or \"regular expression\") strings corresponding to the discoverers we would like to feature. from pymatgen.core import Element , Composition def my_element_discoverer ( elements : list = [], discoverers : list = [], prior_to : int = 2020 ): # Start with elements provided by user # (use copy() to not modify list passed to function) all_elements = elements . copy () # Loop through discoverers to find which elements they discovered # and then add them to your list for discoverer in discoverers : for element_name in discovery_dict : for name in discovery_dict [ element_name ][ 'discovered_by' ]: if discoverer in name : elem = Element ( element_symbols [ element_name ]) all_elements . append ( elem ) # Create a new list that will contain only the elements discovered # before the year you provide elements_pruned = [] for elem in all_elements : element_name = element_names [ str ( elem )] if discovery_dict [ element_name ][ 'year' ] != '?' : year_discovered = int ( discovery_dict [ element_name ][ 'year' ]) else : # Unknown discovery date (known since ancient times) year_discovered = - 2000 if year_discovered < prior_to : elem = Element ( elem ) elements_pruned . append ( elem ) all_elements = elements_pruned # Use set() to convert your list into a unique set # then recast as a list() all_elements = list ( set ( all_elements )) return all_elements Let's test out our function! Say we want to use oxygen in addition to elements discovered by scientists with Curie in their name (Marie and Pierre), as well as elements discovered by scientists in Berkeley my_elements = my_element_discoverer ( elements = [ \"O\" ], discoverers = [ \"Curie\" , \"Lawrence Berkeley\" ], prior_to = 2020 ) print ( my_elements ) [Element O, Element Db, Element Ra, Element Po] Can you spot which elements are missing? (Hint below) # Discovered by scientists at UC Berkeley my_elements = my_element_discoverer ( discoverers = [ \"Ghiorso\" ], prior_to = 2020 ) print ( my_elements ) [Element Cm, Element Bk, Element Cf, Element Es, Element Fm, Element Md, Element No, Element Lr, Element Rf, Element Sg, Element Am] Platinum was found in gold alloys in present day Columbia dating as far back as 800 BC my_elements = my_element_discoverer ( elements = [ \"Ni\" ], discoverers = [ \"Indigenous People of South America\" ], prior_to = 1800 ) print ( my_elements ) [Element Ni, Element Pt] Next, our goal is to find all of the crystals that contain the elements in our list. Once we obtain this list, it is often useful to sort these materials based on a particular metric, depending on which properties that we would like to assess. The two criteria we will use in this study are the molar mass and abundance: Molar mass = \\sum_{i=1}^N x_i n_i \\sum_{i=1}^N x_i n_i , where n_i n_i is the elemental molar mass, and x_i x_i is the molar fraction Abundance metric = \\prod_{i=1}^N a_i^{y_i} \\prod_{i=1}^N a_i^{y_i} , where a_i a_i is the mass abundance of the element i i , and y_i y_i is the mass fraction in the material import numpy as np def compute_molar_weight ( crystal ): # Obtain atomic fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) atomic_fractions = [ comp . get_atomic_fraction ( Element ( elem )) for elem in crystal [ 'elements' ]] # Obtain atomic weights of elements in material weights = [ atomic_weights [ elem ] for elem in crystal [ 'elements' ]] # Compute molar weight of material (weighted mean) molar_weight = 0.0 for elem , frac , weight in zip ( crystal [ \"elements\" ], atomic_fractions , weights ): molar_weight += frac * weight return molar_weight def compute_abundance_metric ( crystal ): # Obtain mass fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) molar_weight = compute_molar_weight ( crystal ) mass_fractions = [ comp . get_atomic_fraction ( Element ( elem )) * ( atomic_weights [ elem ] / molar_weight ) for elem in crystal [ 'elements' ]] # Obtain atomic abundances of elements in material abundances = [ mass_frac_earth_crust [ elem ] for elem in crystal [ 'elements' ]] # Compute abundance metric (geometric mean) abundance_metric = 1.0 for elem , frac , abundance in zip ( crystal [ \"elements\" ], mass_fractions , abundances ): abundance_metric *= ( 100 * abundance ) ** frac return abundance_metric crystal = crystals [ 0 ] print ( \"Material:\" , crystal [ \"pretty_formula\" ]) print ( \"Molar weight (g / mol / # atoms per formula unit) = \" , compute_molar_weight ( crystal )) print ( \"Abundance metric (% kg/kg) = \" , compute_abundance_metric ( crystal )) Material: Ca3Ge3(MoO6)2 Molar weight (g / mol / # atoms per formula unit) = 36.10134 Abundance metric (% kg/kg) = 0.022347289066530374 Now that we have our sorting metrics, let's find the materials in our dataset that contain the elements we have provided, and sort them based on the criteria above. A helpful relation: For finite sets A A and B B , B \\subseteq A B \\subseteq A if and only if B = A \\cap B B = A \\cap B def get_crystals_from_elements ( elements : list , crystals : list , sort_scheme : int = 0 ): crystals_matched = [] for crystal in crystals : crystal_elems = [ Element ( elem ) for elem in crystal [ 'elements' ]] # We can check if the material contains the elements that we have provided # (set B in A) by checking if B = intersection(A,B) intersection = set ( elements ) & set ( crystal_elems ) if set ( elements ) == intersection : crystals_matched . append ( crystal ) if sort_scheme == 0 : # Sort by molar weight sort_key = \"Molar weight (g / mol / # atoms per formula unit)\" sortable_values = [ compute_molar_weight ( crystal ) for crystal in crystals_matched ] elif sort_scheme == 1 : # Sort by abundance metric sort_key = \"Abundance metric (% kg/kg)\" sortable_values = [ compute_abundance_metric ( crystal ) for crystal in crystals_matched ] else : # Catch all case - no sorting provided sortable_values = [] print ( \"Warning: Invalid sort scheme!\" ) return [], [], \"\" if sortable_values : #print(sortable_values) # Sort crystals based on sorting metric (reverse to descending order) value_map = [{ \"value\" : v , \"crystal\" : c } for v , c in zip ( sortable_values , crystals_matched )] value_map = sorted ( value_map , key = lambda x : x [ \"value\" ], reverse = True ) #sortable_values, crystals_matched = zip(*sorted(zip(sortable_values, crystals_matched), reverse=True)) # Extract desired values after sorting sortable_values = [ x [ 'value' ] for x in value_map ] crystals_matched = [ x [ 'crystal' ] for x in value_map ] #print(sortable_values) return crystals_matched , sortable_values , sort_key We've built our functions! Now let's test them to search the materials in our dataset # The elements we would like to search our dataset elements = [ Element ( elem ) for elem in [ 'Ca' , 'O' ]] # Testing our function crystals_matched , sorted_values , sort_key = get_crystals_from_elements ( elements , crystals , sort_scheme = 0 ) # The formulas of the crystals that we searched for formulas = [ crystal [ 'pretty_formula' ] for crystal in crystals_matched ] print ( \"Number of crystals found: \" , len ( crystals_matched )) # print(formulas) Number of crystals found: 445 For a large number of materials, we often gain the most information by perfoming an analysis of how the sorting criteria is distributed. In this case, we can create a histogram of the data using the matplotlib package. import matplotlib.pyplot as plt number_of_bins = 20 plt . hist ( sorted_values , number_of_bins ) plt . ylabel ( 'Counts' ) plt . xlabel ( sort_key ) plt . show ()","title":"Now it's time to put your skills to the test!"},{"location":"primer/02_building_logic/Exercises/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Python Primer Part II Exercises \u00b6 Lesson 5: Conditionals \u00b6 Exercise: \u00b6 Write a Python program to convert temperatures to and from celsius, fahrenheit. Formula : c/5 = f-32/9 (where c = temperature in celsius and f = temperature in fahrenheit ) Expected Output : 60\u00b0C is 140 in Fahrenheit 45\u00b0F is 7 in Celsius # gather input from the user temp = input ( \"Input the temperature you like to convert? (e.g., 45F, 102C etc.) : \" ) # parse the string of input from the user degree = int ( temp [: - 1 ]) i_convention = temp [ - 1 ] if i_convention . upper () == __ : result = int ( round (( 9 * degree ) / 5 + 32 )) o_convention = \"Fahrenheit\" elif i_convention . upper () == __ : result = int ( round (( degree - 32 ) * 5 / 9 )) o_convention = \"Celsius\" else : print ( \"Input proper convention.\" ) quit () print ( \"The temperature in\" , o_convention , \"is\" , result , \"degrees.\" ) Input the temperature you like to convert? (e.g., 45F, 102C etc.) : 100C The temperature in Celsius is 38 degrees. Exercise: \u00b6 Who discovered your favorite elements? Let's write a simple test to see which elements were discovered by discoverer \"A,\" discoverer \"B,\" and both. import os from monty.serialization import loadfn data_dir = \"./data/\" # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) from pymatgen.core import Element # The discoverers we want to explore... discover0 = \"Berkeley\" #discover0 = \"Ghiorso\" discover1 = \"Russia\" # Loop through discoverers to find which elements they discovered for element_name in discovery_dict : names = discovery_dict [ element_name ][ 'discovered_by' ] A , B = __ , __ for name in names : if discover0 in name : A = __ if discover1 in name : B = __ if __ and __ : print ( \"For \" , element_name , \", A and B is true!\" ) elif __ : print ( \"For \" , element_name , \", A is true!\" ) elif __ : print ( \"For \" , element_name , \", B is true!\" ) Lesson 6: Sets and Dictionaries \u00b6 Exercise: create a histogram \u00b6 numbers = [ 1 , 0 , 1 , 2 , 0 , 0 , 1 , 2 , 1 , 3 , 1 , 0 , 2 ] count = {} for n in numbers : if __ not in __ : count [ n ] = 1 else : count [ n ] = count [ n ] + 1 print ( count ) {1: 5, 0: 4, 2: 3, 3: 1} Reminder: there are lots of useful Python libraries, especially the \"standard library\" that comes with Python: from collections import Counter print ( Counter ( numbers )) print ( dict ( Counter ( numbers ))) Counter({1: 5, 0: 4, 2: 3, 3: 1}) {1: 5, 0: 4, 2: 3, 3: 1} Exercise: How heavy is this molecule? \u00b6 You are given two things: a dictionary mapping atomic symbols to atomic weights ( mp_workshop.data.atomic_weights ), and a list of (atomic_symbol, count) pairs for a molecule. # Example molecules: methane = [( 'C' , 1 ), ( 'H' , 4 )] aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] Print that molecule's molecular weight. import os from monty.serialization import loadfn data_dir = \"./data/\" atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # atomic weight is 16.0423 methane = [( 'C' , 1 ), ( 'H' , 4 )] # atomic weight is 100.1421 aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] # 2. Pick a molecule to test molecule = methane # 3. Do stuff to calculate `mol_weight` # ... #print(mol_weight) 103 Lesson 7: Writing Functions \u00b6 Exercise: Find the first \u00b6 Fill in the blanks to create a function that takes a list of numbers as an argument and returns the first negative value in the list. What does your function do if the list is empty? def first_negative ( values ): for v in ____ : if ____ : return ____ Exercise : Running sum \u00b6 Write a function that calculates the running sum of any number of input arguments, returning the result as a list. For example: running(1, 2) => [1, 3] running(-5, 2, 7) => [-5, -3, 4] What should running() return, and why? Exercise: How's your phase-change memory? \u00b6 A chalcogenide is a chemical compound consisting of at least one chalcogen anion (commonly restricted to \u2018S\u2019, \u2018Se\u2019, or \u2018Te\u2019) and at least one more electropositive element. Generalize the halide function below as compound_class , a function that takes a crystal and function as parameters and returns whether or not the compound is of that class. # %load code/phase_change_memory.py import random from pymatgen import Element import os from monty.serialization import loadfn data_dir = \"./data/\" crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) def halogen ( element ): return element . is_halogen def halide ( crystal ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return halogen ( anion ) def chalcogen ( element ): return element . is_chalogen def compound_class ( crystal , predicate ): # Fill this in. pass my_crystal = random . sample ( [ c for c in crystals if halide ( c )], 1 )[ 0 ] print ( compound_class ( my_crystal , halogen ) == halide ( my_crystal )) False Lesson 8: Test your Skills \u00b6 Now it's time to put your Python skills to the test! \u00b6 Exercise: As a materials investigator, your team has just finished running calculations for a large number of crystal structures. Now, you want to analyze the dataset by writing functions that utilize logic (in the form of conditionals ) to parse through the datasets in the forms of dictionaries and lists . First, load the relevant datasets import os from monty.serialization import loadfn data_dir = \"./data/\" # Our crystal structures, in addition to useful elemental information crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) atomic_numbers = loadfn ( os . path . join ( data_dir , \"atomic_numbers.json\" )) atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # Names of elements associated with an element symbol (e.g. {\"Al\": \"Aluminium\"}) element_names = loadfn ( os . path . join ( data_dir , \"element_names.json\" )) # Elemental mass fraction of Earth's crust (source: https://en.wikipedia.org/wiki/Abundances_of_the_elements_(data_page)) mass_frac_earth_crust = loadfn ( os . path . join ( data_dir , \"mass_frac_earth_crust.json\" )) # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) We have the mapping from symbol \\rightarrow \\rightarrow name , now let's obtain name \\rightarrow \\rightarrow symbol (we'll need it later) print ( element_names [ \"Ag\" ]) element_symbols = { __ : __ for k , v in element_names . items ()} print ( element_symbols [ \"Silver\" ]) Silver Ag Next, we'll choose the set of elements that we would like to start with. Each element has a unique story associated with it. We can explore these stories with the information from the element discovery timeline. Our task: Build a function that takes a list of element symbols as input. In addition, if we want to add the elements associated with a particular materials discoverer, we can include some regex (or \"regular expression\") strings corresponding to the discoverers we would like to feature. from pymatgen.core import Element , Composition def my_element_discoverer ( elements : list = [], discoverers : list = [], prior_to : int = 2020 ): # Start with elements provided by user # (use copy() to not modify list passed to function) all_elements = elements . copy () # Loop through discoverers to find which elements they discovered # and then add them to your list for discoverer in discoverers : for element_name in discovery_dict : for name in discovery_dict [ __ ][ 'discovered_by' ]: if discoverer in __ : elem = Element ( element_symbols [ element_name ]) all_elements . append ( __ ) # Create a new list that will contain only the elements discovered # before the year you provide elements_pruned = [] for elem in all_elements : element_name = element_names [ str ( elem )] if discovery_dict [ element_name ][ __ ] != '?' : year_discovered = int ( discovery_dict [ element_name ][ 'year' ]) else : # Unknown discovery date (known since ancient times) year_discovered = - 2000 # If statement if \"year_discovered\" is less than \"prior_to\" if __ : elem = Element ( elem ) elements_pruned . append ( elem ) all_elements = elements_pruned # Use set() to convert your list into a unique set # then recast as a list() all_elements = list ( set ( all_elements )) return all_elements Let's test out our function! Say we want to use oxygen in addition to elements discovered by scientists with Curie in their name (Marie and Pierre), as well as elements discovered by scientists in Berkeley my_elements = my_element_discoverer ( elements = [ \"O\" ], discoverers = [ \"Curie\" , \"Lawrence Berkeley\" ], prior_to = 2020 ) print ( my_elements ) Can you spot which elements are missing? (Hint below) # Discovered by scientists at UC Berkeley my_elements = my_element_discoverer ( discoverers = [ \"Ghiorso\" ], prior_to = 2020 ) print ( my_elements ) Platinum was found in gold alloys in present day Columbia dating as far back as 800 BC my_elements = my_element_discoverer ( elements = [ \"Ni\" ], discoverers = [ \"Indigenous People of South America\" ], prior_to = 1800 ) print ( my_elements ) Next, our goal is to find all of the crystals that contain the elements in our list. Once we obtain this list, it is often useful to sort these materials based on a particular metric, depending on which properties that we would like to assess. The two criteria we will use in this study are the molar mass and abundance: Molar mass = \\sum_{i=1}^N x_i n_i \\sum_{i=1}^N x_i n_i , where n_i n_i is the elemental molar mass, and x_i x_i is the molar fraction Abundance metric = \\prod_{i=1}^N a_i^{y_i} \\prod_{i=1}^N a_i^{y_i} , where a_i a_i is the mass abundance of the element i i , and y_i y_i is the mass fraction in the material import numpy as np def compute_molar_weight ( crystal ): # Obtain atomic fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) atomic_fractions = [ comp . get_atomic_fraction ( Element ( elem )) for elem in crystal [ 'elements' ]] # Obtain atomic weights of elements in material weights = [ atomic_weights [ __ ] for elem in crystal [ 'elements' ]] # Compute molar weight of material (weighted mean) molar_weight = 0.0 for elem , frac , weight in zip ( crystal [ __ ], atomic_fractions , __ ): molar_weight += __ * weight return molar_weight def compute_abundance_metric ( crystal ): # Obtain mass fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) molar_weight = compute_molar_weight ( crystal ) mass_fractions = [ comp . get_atomic_fraction ( Element ( elem )) * ( atomic_weights [ elem ] / molar_weight ) for elem in crystal [ 'elements' ]] # Obtain atomic abundances of elements in material abundances = [ mass_frac_earth_crust [ elem ] for __ in crystal [ 'elements' ]] # Compute abundance metric (geometric mean) abundance_metric = 1.0 for elem , frac , abundance in zip ( crystal [ \"elements\" ], __ , abundances ): abundance_metric *= ( abundance ) ** frac abundance_metric *= 100 return abundance_metric crystal = crystals [ 0 ] print ( \"Material:\" , crystal [ \"pretty_formula\" ]) print ( \"Molar weight (g / mol / # atoms per formula unit) = \" , compute_molar_weight ( crystal )) print ( \"Abundance metric (% kg/kg) = \" , compute_abundance_metric ( crystal )) Now that we have our sorting metrics, let's find the materials in our dataset that contain the elements we have provided, and sort them based on the criteria above. A helpful relation: For finite sets A A and B B , B \\subseteq A B \\subseteq A if and only if B = A \\cap B B = A \\cap B def get_crystals_from_elements ( elements : list , crystals : list , sort_scheme : int = 0 ): crystals_matched = [] for crystal in crystals : crystal_elems = [ Element ( elem ) for elem in crystal [ 'elements' ]] # We can check if the material contains the elements that we have provided # (set B in A) by checking if B = intersection(A,B) # Hint: \"&\" operator is used for intersection of two sets, #. and \"|\" for union intersection = set ( elements ) __ set ( crystal_elems ) if set ( elements ) == intersection : crystals_matched . append ( crystal ) if sort_scheme == 0 : # Sort by molar weight sort_key = \"Molar weight (g / mol / # atoms per formula unit)\" sortable_values = [ compute_molar_weight ( __ ) for crystal in crystals_matched ] elif sort_scheme == 1 : # Sort by abundance metric sort_key = \"Abundance metric (% kg/kg)\" sortable_values = [ compute_abundance_metric ( __ ) for crystal in crystals_matched ] else : # Catch all case - no sorting provided sortable_values = [] print ( \"Warning: Invalid sort scheme!\" ) return [], [], \"\" if sortable_values : #print(sortable_values) # Sort crystals based on sorting metric (reverse to descending order) value_map = [{ \"value\" : __ , \"crystal\" : __ } for v , c in zip ( sortable_values , crystals_matched )] value_map = sorted ( value_map , key = lambda x : x [ __ ], reverse = True ) #sortable_values, crystals_matched = zip(*sorted(zip(sortable_values, crystals_matched), reverse=True)) # Extract desired values after sorting sortable_values = [ x [ __ ] for x in value_map ] crystals_matched = [ x [ __ ] for x in value_map ] #print(sortable_values) return crystals_matched , sortable_values , sort_key We've built our functions! Now let's test them to search the materials in our dataset # The elements we would like to search our dataset elements = [ Element ( elem ) for elem in [ 'Ca' , 'O' ]] # Testing our function crystals_matched , sorted_values , sort_key = get_crystals_from_elements ( elements , crystals , sort_scheme = 0 ) # The formulas of the crystals that we searched for formulas = [ crystal [ __ ] for crystal in crystals_matched ] print ( \"Number of crystals found: \" , __ ( crystals_matched )) # print(formulas) For a large number of materials, we often gain the most information by perfoming an analysis of how the sorting criteria is distributed. In this case, we can create a histogram of the data using the matplotlib package. import matplotlib.pyplot as plt number_of_bins = 20 plt . hist ( sorted_values , number_of_bins ) plt . ylabel ( 'Counts' ) plt . xlabel ( sort_key ) plt . show ()","title":"Exercises"},{"location":"primer/02_building_logic/Exercises/#python-primer-part-ii-exercises","text":"","title":"Python Primer Part II Exercises"},{"location":"primer/02_building_logic/Exercises/#lesson-5-conditionals","text":"","title":"Lesson 5: Conditionals"},{"location":"primer/02_building_logic/Exercises/#exercise","text":"Write a Python program to convert temperatures to and from celsius, fahrenheit. Formula : c/5 = f-32/9 (where c = temperature in celsius and f = temperature in fahrenheit ) Expected Output : 60\u00b0C is 140 in Fahrenheit 45\u00b0F is 7 in Celsius # gather input from the user temp = input ( \"Input the temperature you like to convert? (e.g., 45F, 102C etc.) : \" ) # parse the string of input from the user degree = int ( temp [: - 1 ]) i_convention = temp [ - 1 ] if i_convention . upper () == __ : result = int ( round (( 9 * degree ) / 5 + 32 )) o_convention = \"Fahrenheit\" elif i_convention . upper () == __ : result = int ( round (( degree - 32 ) * 5 / 9 )) o_convention = \"Celsius\" else : print ( \"Input proper convention.\" ) quit () print ( \"The temperature in\" , o_convention , \"is\" , result , \"degrees.\" ) Input the temperature you like to convert? (e.g., 45F, 102C etc.) : 100C The temperature in Celsius is 38 degrees.","title":"Exercise:"},{"location":"primer/02_building_logic/Exercises/#exercise_1","text":"Who discovered your favorite elements? Let's write a simple test to see which elements were discovered by discoverer \"A,\" discoverer \"B,\" and both. import os from monty.serialization import loadfn data_dir = \"./data/\" # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) from pymatgen.core import Element # The discoverers we want to explore... discover0 = \"Berkeley\" #discover0 = \"Ghiorso\" discover1 = \"Russia\" # Loop through discoverers to find which elements they discovered for element_name in discovery_dict : names = discovery_dict [ element_name ][ 'discovered_by' ] A , B = __ , __ for name in names : if discover0 in name : A = __ if discover1 in name : B = __ if __ and __ : print ( \"For \" , element_name , \", A and B is true!\" ) elif __ : print ( \"For \" , element_name , \", A is true!\" ) elif __ : print ( \"For \" , element_name , \", B is true!\" )","title":"Exercise:"},{"location":"primer/02_building_logic/Exercises/#lesson-6-sets-and-dictionaries","text":"","title":"Lesson 6: Sets and Dictionaries"},{"location":"primer/02_building_logic/Exercises/#exercise-create-a-histogram","text":"numbers = [ 1 , 0 , 1 , 2 , 0 , 0 , 1 , 2 , 1 , 3 , 1 , 0 , 2 ] count = {} for n in numbers : if __ not in __ : count [ n ] = 1 else : count [ n ] = count [ n ] + 1 print ( count ) {1: 5, 0: 4, 2: 3, 3: 1} Reminder: there are lots of useful Python libraries, especially the \"standard library\" that comes with Python: from collections import Counter print ( Counter ( numbers )) print ( dict ( Counter ( numbers ))) Counter({1: 5, 0: 4, 2: 3, 3: 1}) {1: 5, 0: 4, 2: 3, 3: 1}","title":"Exercise: create a histogram"},{"location":"primer/02_building_logic/Exercises/#exercise-how-heavy-is-this-molecule","text":"You are given two things: a dictionary mapping atomic symbols to atomic weights ( mp_workshop.data.atomic_weights ), and a list of (atomic_symbol, count) pairs for a molecule. # Example molecules: methane = [( 'C' , 1 ), ( 'H' , 4 )] aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] Print that molecule's molecular weight. import os from monty.serialization import loadfn data_dir = \"./data/\" atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # atomic weight is 16.0423 methane = [( 'C' , 1 ), ( 'H' , 4 )] # atomic weight is 100.1421 aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] # 2. Pick a molecule to test molecule = methane # 3. Do stuff to calculate `mol_weight` # ... #print(mol_weight) 103","title":"Exercise: How heavy is this molecule?"},{"location":"primer/02_building_logic/Exercises/#lesson-7-writing-functions","text":"","title":"Lesson 7: Writing Functions"},{"location":"primer/02_building_logic/Exercises/#exercise-find-the-first","text":"Fill in the blanks to create a function that takes a list of numbers as an argument and returns the first negative value in the list. What does your function do if the list is empty? def first_negative ( values ): for v in ____ : if ____ : return ____","title":"Exercise: Find the first"},{"location":"primer/02_building_logic/Exercises/#exercise-running-sum","text":"Write a function that calculates the running sum of any number of input arguments, returning the result as a list. For example: running(1, 2) => [1, 3] running(-5, 2, 7) => [-5, -3, 4] What should running() return, and why?","title":"Exercise : Running sum"},{"location":"primer/02_building_logic/Exercises/#exercise-hows-your-phase-change-memory","text":"A chalcogenide is a chemical compound consisting of at least one chalcogen anion (commonly restricted to \u2018S\u2019, \u2018Se\u2019, or \u2018Te\u2019) and at least one more electropositive element. Generalize the halide function below as compound_class , a function that takes a crystal and function as parameters and returns whether or not the compound is of that class. # %load code/phase_change_memory.py import random from pymatgen import Element import os from monty.serialization import loadfn data_dir = \"./data/\" crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) def halogen ( element ): return element . is_halogen def halide ( crystal ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return halogen ( anion ) def chalcogen ( element ): return element . is_chalogen def compound_class ( crystal , predicate ): # Fill this in. pass my_crystal = random . sample ( [ c for c in crystals if halide ( c )], 1 )[ 0 ] print ( compound_class ( my_crystal , halogen ) == halide ( my_crystal )) False","title":"Exercise: How's your phase-change memory?"},{"location":"primer/02_building_logic/Exercises/#lesson-8-test-your-skills","text":"","title":"Lesson 8: Test your Skills"},{"location":"primer/02_building_logic/Exercises/#now-its-time-to-put-your-python-skills-to-the-test","text":"Exercise: As a materials investigator, your team has just finished running calculations for a large number of crystal structures. Now, you want to analyze the dataset by writing functions that utilize logic (in the form of conditionals ) to parse through the datasets in the forms of dictionaries and lists . First, load the relevant datasets import os from monty.serialization import loadfn data_dir = \"./data/\" # Our crystal structures, in addition to useful elemental information crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) atomic_numbers = loadfn ( os . path . join ( data_dir , \"atomic_numbers.json\" )) atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # Names of elements associated with an element symbol (e.g. {\"Al\": \"Aluminium\"}) element_names = loadfn ( os . path . join ( data_dir , \"element_names.json\" )) # Elemental mass fraction of Earth's crust (source: https://en.wikipedia.org/wiki/Abundances_of_the_elements_(data_page)) mass_frac_earth_crust = loadfn ( os . path . join ( data_dir , \"mass_frac_earth_crust.json\" )) # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) We have the mapping from symbol \\rightarrow \\rightarrow name , now let's obtain name \\rightarrow \\rightarrow symbol (we'll need it later) print ( element_names [ \"Ag\" ]) element_symbols = { __ : __ for k , v in element_names . items ()} print ( element_symbols [ \"Silver\" ]) Silver Ag Next, we'll choose the set of elements that we would like to start with. Each element has a unique story associated with it. We can explore these stories with the information from the element discovery timeline. Our task: Build a function that takes a list of element symbols as input. In addition, if we want to add the elements associated with a particular materials discoverer, we can include some regex (or \"regular expression\") strings corresponding to the discoverers we would like to feature. from pymatgen.core import Element , Composition def my_element_discoverer ( elements : list = [], discoverers : list = [], prior_to : int = 2020 ): # Start with elements provided by user # (use copy() to not modify list passed to function) all_elements = elements . copy () # Loop through discoverers to find which elements they discovered # and then add them to your list for discoverer in discoverers : for element_name in discovery_dict : for name in discovery_dict [ __ ][ 'discovered_by' ]: if discoverer in __ : elem = Element ( element_symbols [ element_name ]) all_elements . append ( __ ) # Create a new list that will contain only the elements discovered # before the year you provide elements_pruned = [] for elem in all_elements : element_name = element_names [ str ( elem )] if discovery_dict [ element_name ][ __ ] != '?' : year_discovered = int ( discovery_dict [ element_name ][ 'year' ]) else : # Unknown discovery date (known since ancient times) year_discovered = - 2000 # If statement if \"year_discovered\" is less than \"prior_to\" if __ : elem = Element ( elem ) elements_pruned . append ( elem ) all_elements = elements_pruned # Use set() to convert your list into a unique set # then recast as a list() all_elements = list ( set ( all_elements )) return all_elements Let's test out our function! Say we want to use oxygen in addition to elements discovered by scientists with Curie in their name (Marie and Pierre), as well as elements discovered by scientists in Berkeley my_elements = my_element_discoverer ( elements = [ \"O\" ], discoverers = [ \"Curie\" , \"Lawrence Berkeley\" ], prior_to = 2020 ) print ( my_elements ) Can you spot which elements are missing? (Hint below) # Discovered by scientists at UC Berkeley my_elements = my_element_discoverer ( discoverers = [ \"Ghiorso\" ], prior_to = 2020 ) print ( my_elements ) Platinum was found in gold alloys in present day Columbia dating as far back as 800 BC my_elements = my_element_discoverer ( elements = [ \"Ni\" ], discoverers = [ \"Indigenous People of South America\" ], prior_to = 1800 ) print ( my_elements ) Next, our goal is to find all of the crystals that contain the elements in our list. Once we obtain this list, it is often useful to sort these materials based on a particular metric, depending on which properties that we would like to assess. The two criteria we will use in this study are the molar mass and abundance: Molar mass = \\sum_{i=1}^N x_i n_i \\sum_{i=1}^N x_i n_i , where n_i n_i is the elemental molar mass, and x_i x_i is the molar fraction Abundance metric = \\prod_{i=1}^N a_i^{y_i} \\prod_{i=1}^N a_i^{y_i} , where a_i a_i is the mass abundance of the element i i , and y_i y_i is the mass fraction in the material import numpy as np def compute_molar_weight ( crystal ): # Obtain atomic fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) atomic_fractions = [ comp . get_atomic_fraction ( Element ( elem )) for elem in crystal [ 'elements' ]] # Obtain atomic weights of elements in material weights = [ atomic_weights [ __ ] for elem in crystal [ 'elements' ]] # Compute molar weight of material (weighted mean) molar_weight = 0.0 for elem , frac , weight in zip ( crystal [ __ ], atomic_fractions , __ ): molar_weight += __ * weight return molar_weight def compute_abundance_metric ( crystal ): # Obtain mass fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) molar_weight = compute_molar_weight ( crystal ) mass_fractions = [ comp . get_atomic_fraction ( Element ( elem )) * ( atomic_weights [ elem ] / molar_weight ) for elem in crystal [ 'elements' ]] # Obtain atomic abundances of elements in material abundances = [ mass_frac_earth_crust [ elem ] for __ in crystal [ 'elements' ]] # Compute abundance metric (geometric mean) abundance_metric = 1.0 for elem , frac , abundance in zip ( crystal [ \"elements\" ], __ , abundances ): abundance_metric *= ( abundance ) ** frac abundance_metric *= 100 return abundance_metric crystal = crystals [ 0 ] print ( \"Material:\" , crystal [ \"pretty_formula\" ]) print ( \"Molar weight (g / mol / # atoms per formula unit) = \" , compute_molar_weight ( crystal )) print ( \"Abundance metric (% kg/kg) = \" , compute_abundance_metric ( crystal )) Now that we have our sorting metrics, let's find the materials in our dataset that contain the elements we have provided, and sort them based on the criteria above. A helpful relation: For finite sets A A and B B , B \\subseteq A B \\subseteq A if and only if B = A \\cap B B = A \\cap B def get_crystals_from_elements ( elements : list , crystals : list , sort_scheme : int = 0 ): crystals_matched = [] for crystal in crystals : crystal_elems = [ Element ( elem ) for elem in crystal [ 'elements' ]] # We can check if the material contains the elements that we have provided # (set B in A) by checking if B = intersection(A,B) # Hint: \"&\" operator is used for intersection of two sets, #. and \"|\" for union intersection = set ( elements ) __ set ( crystal_elems ) if set ( elements ) == intersection : crystals_matched . append ( crystal ) if sort_scheme == 0 : # Sort by molar weight sort_key = \"Molar weight (g / mol / # atoms per formula unit)\" sortable_values = [ compute_molar_weight ( __ ) for crystal in crystals_matched ] elif sort_scheme == 1 : # Sort by abundance metric sort_key = \"Abundance metric (% kg/kg)\" sortable_values = [ compute_abundance_metric ( __ ) for crystal in crystals_matched ] else : # Catch all case - no sorting provided sortable_values = [] print ( \"Warning: Invalid sort scheme!\" ) return [], [], \"\" if sortable_values : #print(sortable_values) # Sort crystals based on sorting metric (reverse to descending order) value_map = [{ \"value\" : __ , \"crystal\" : __ } for v , c in zip ( sortable_values , crystals_matched )] value_map = sorted ( value_map , key = lambda x : x [ __ ], reverse = True ) #sortable_values, crystals_matched = zip(*sorted(zip(sortable_values, crystals_matched), reverse=True)) # Extract desired values after sorting sortable_values = [ x [ __ ] for x in value_map ] crystals_matched = [ x [ __ ] for x in value_map ] #print(sortable_values) return crystals_matched , sortable_values , sort_key We've built our functions! Now let's test them to search the materials in our dataset # The elements we would like to search our dataset elements = [ Element ( elem ) for elem in [ 'Ca' , 'O' ]] # Testing our function crystals_matched , sorted_values , sort_key = get_crystals_from_elements ( elements , crystals , sort_scheme = 0 ) # The formulas of the crystals that we searched for formulas = [ crystal [ __ ] for crystal in crystals_matched ] print ( \"Number of crystals found: \" , __ ( crystals_matched )) # print(formulas) For a large number of materials, we often gain the most information by perfoming an analysis of how the sorting criteria is distributed. In this case, we can create a histogram of the data using the matplotlib package. import matplotlib.pyplot as plt number_of_bins = 20 plt . hist ( sorted_values , number_of_bins ) plt . ylabel ( 'Counts' ) plt . xlabel ( sort_key ) plt . show ()","title":"Now it's time to put your Python skills to the test!"},{"location":"primer/03_MongoDB_part1/exercise_01/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Intro to MongoDB and the Nobel Prize Dataset - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from __ import __ client = __ db = __ . __ print ( db ) 2. Obtain a document from the laureates collection and display its contents. \u00b6 doc = db . __ . __ ( __ ) doc 3. Obtain a list of tuples containing the first ( \"firstname\" ) and last ( \"surname\" ) name of each laureate in the database who died ( \"diedCountry\" ) in USA. \u00b6 cursor = db . __ . __ ({ __ : __ }) names = [( doc [ __ ], doc [ __ ]) for __ in __ ] names 4. Did any of the above laureates receive more than one prize? Generate a list of tuples with their first name and the total number they were awarded. \u00b6 cursor = db . __ . __ ( __ ) names = [( doc [ __ ], len ( doc [ __ ])) for __ in __ if len ( doc [ __ ]) > 1 ] names","title":"Exercise 01"},{"location":"primer/03_MongoDB_part1/exercise_01/#intro-to-mongodb-and-the-nobel-prize-dataset-exercise","text":"","title":"Intro to MongoDB and the Nobel Prize Dataset - Exercise"},{"location":"primer/03_MongoDB_part1/exercise_01/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from __ import __ client = __ db = __ . __ print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/exercise_01/#2-obtain-a-document-from-the-laureates-collection-and-display-its-contents","text":"doc = db . __ . __ ( __ ) doc","title":"2. Obtain a document from the laureates collection and display its contents."},{"location":"primer/03_MongoDB_part1/exercise_01/#3-obtain-a-list-of-tuples-containing-the-first-firstname-and-last-surname-name-of-each-laureate-in-the-database-who-died-diedcountry-in-usa","text":"cursor = db . __ . __ ({ __ : __ }) names = [( doc [ __ ], doc [ __ ]) for __ in __ ] names","title":"3. Obtain a list of tuples containing the first (\"firstname\") and last (\"surname\") name of each laureate in the database who died (\"diedCountry\") in USA."},{"location":"primer/03_MongoDB_part1/exercise_01/#4-did-any-of-the-above-laureates-receive-more-than-one-prize-generate-a-list-of-tuples-with-their-first-name-and-the-total-number-they-were-awarded","text":"cursor = db . __ . __ ( __ ) names = [( doc [ __ ], len ( doc [ __ ])) for __ in __ if len ( doc [ __ ]) > 1 ] names","title":"4. Did any of the above laureates receive more than one prize? Generate a list of tuples with their first name and the total number they were awarded."},{"location":"primer/03_MongoDB_part1/exercise_02/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Listing and Counting - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from __ import __ client = __ db = __ . __ print ( db ) 2. Obtain a document from the prizes collection and display its contents. \u00b6 doc = db . __ . __ ( __ ) doc 3. Use count_documents to identify which of the following statements is true? \u00b6 A. the number of prizes and laureates are equal B. prizes outnumber laureates by < 2x C. prizes outnumber laureates by > 2x D. laureates outnumber prizes by < 2x E. laureates outnumber prizes by > 2x num_prizes = db . __ . __ ( __ ) num_laureates = db . __ . __ ( __ ) num_laureates / num_prizes Is the number of peace prizes awarded in 1911 ( \"year\" ) larger or smaller than the number of laureates who were born ( \"bornCountry\" ) in Finland? \u00b6 num_prizes = db . __ . __ ({ __ : __ }) num_laureates = db . __ . __ ({ __ : __ }) num_laureates > num_prizes","title":"Exercise 02"},{"location":"primer/03_MongoDB_part1/exercise_02/#listing-and-counting-exercise","text":"","title":"Listing and Counting - Exercise"},{"location":"primer/03_MongoDB_part1/exercise_02/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from __ import __ client = __ db = __ . __ print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/exercise_02/#2-obtain-a-document-from-the-prizes-collection-and-display-its-contents","text":"doc = db . __ . __ ( __ ) doc","title":"2. Obtain a document from the prizes collection and display its contents."},{"location":"primer/03_MongoDB_part1/exercise_02/#3-use-count_documents-to-identify-which-of-the-following-statements-is-true","text":"A. the number of prizes and laureates are equal B. prizes outnumber laureates by < 2x C. prizes outnumber laureates by > 2x D. laureates outnumber prizes by < 2x E. laureates outnumber prizes by > 2x num_prizes = db . __ . __ ( __ ) num_laureates = db . __ . __ ( __ ) num_laureates / num_prizes","title":"3. Use count_documents to identify which of the following statements is true?"},{"location":"primer/03_MongoDB_part1/exercise_02/#is-the-number-of-peace-prizes-awarded-in-1911-year-larger-or-smaller-than-the-number-of-laureates-who-were-born-borncountry-in-finland","text":"num_prizes = db . __ . __ ({ __ : __ }) num_laureates = db . __ . __ ({ __ : __ }) num_laureates > num_prizes","title":"Is the number of peace prizes awarded in 1911 (\"year\") larger or smaller than the number of laureates who were born (\"bornCountry\") in Finland?"},{"location":"primer/03_MongoDB_part1/exercise_03/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Finding, and Dot Notation - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from __ import __ client = __ db = __ . __ print ( db ) 2. Find the total number of laureates who died ( \"diedCountry\" ) in Canada and were not born ( \"bornCountry\" ) in Germany using the $ne operator. \u00b6 criteria = { __ : __ , __ : { __ : __ }} count = db . laureates . count_documents ( criteria ) count 3. Use the $in and $gt operators to count the total number of physics and chemistry prizes awarded after the year 1930. Recall the structure of a document in prizes : \u00b6 {'_id': ObjectId('5f1746222466f220f494d00c'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} criteria = { __ : { __ : [ \"physics\" , \"chemistry\" ]}, __ :{ __ : \"1930\" }} count = db . prizes . count_documents ( criteria ) count 4. Let's define \"high-share\" prizes as those shared by at least three people. Use dot notation and the $exists operator to find the number of \"high-share\" physics and chemistry prizes awarded after the year 2001. Remember arrays start with index 0 ! \u00b6 criteria = { __ : { __ : [ \"physics\" , \"chemistry\" ]}, __ :{ __ : \"2001\" }, \"__.__\" : { __ : True }} count = db . prizes . count_documents ( criteria ) count 5. Use the $size operator to find the total number of awarded peace prizes shared by exactly three people. \u00b6 criteria = { __ : __ , __ : { __ : 3 }} count = db . prizes . count_documents ( criteria ) count 6. Estimate the number of laureates who were awarded a prize affiliated with the USA, but were born in a different country. Use only the first prize and affiliation in each respective array. Recall the structure of a document in laureates : \u00b6 {'_id': ObjectId('5f1746222466f220f494d292'), 'id': '1', 'firstname': 'Wilhelm Conrad', 'surname': 'R\u00f6ntgen', 'born': '1845-03-27', 'died': '1923-02-10', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'bornCity': 'Lennep (now Remscheid)', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'diedCity': 'Munich', 'gender': 'male', 'prizes': [{'year': '1901', 'category': 'physics', 'share': '1', 'motivation': '\"in recognition of the extraordinary services he has rendered by the discovery of the remarkable rays subsequently named after him\"', 'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]} criteria = { __ : { __ : \"USA\" }, \"__.__.__.__.__\" : \"USA\" } count = db . laureates . count_documents ( criteria ) count","title":"Exercise 03"},{"location":"primer/03_MongoDB_part1/exercise_03/#finding-and-dot-notation-exercise","text":"","title":"Finding, and Dot Notation - Exercise"},{"location":"primer/03_MongoDB_part1/exercise_03/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from __ import __ client = __ db = __ . __ print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/exercise_03/#2-find-the-total-number-of-laureates-who-died-diedcountry-in-canada-and-were-not-born-borncountry-in-germany-using-the-ne-operator","text":"criteria = { __ : __ , __ : { __ : __ }} count = db . laureates . count_documents ( criteria ) count","title":"2. Find the total number of laureates who died (\"diedCountry\") in Canada and were not born (\"bornCountry\") in Germany using the $ne operator."},{"location":"primer/03_MongoDB_part1/exercise_03/#3-use-the-in-and-gt-operators-to-count-the-total-number-of-physics-and-chemistry-prizes-awarded-after-the-year-1930-recall-the-structure-of-a-document-in-prizes","text":"{'_id': ObjectId('5f1746222466f220f494d00c'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} criteria = { __ : { __ : [ \"physics\" , \"chemistry\" ]}, __ :{ __ : \"1930\" }} count = db . prizes . count_documents ( criteria ) count","title":"3. Use the $in and $gt operators to count the total number of physics and chemistry prizes awarded after the year 1930. Recall the structure of a document in prizes:"},{"location":"primer/03_MongoDB_part1/exercise_03/#4-lets-define-high-share-prizes-as-those-shared-by-at-least-three-people-use-dot-notation-and-the-exists-operator-to-find-the-number-of-high-share-physics-and-chemistry-prizes-awarded-after-the-year-2001-remember-arrays-start-with-index-0","text":"criteria = { __ : { __ : [ \"physics\" , \"chemistry\" ]}, __ :{ __ : \"2001\" }, \"__.__\" : { __ : True }} count = db . prizes . count_documents ( criteria ) count","title":"4. Let's define \"high-share\" prizes as those shared by at least three people. Use dot notation and the $exists operator to find the number of \"high-share\" physics and chemistry prizes awarded after the year 2001. Remember arrays start with index 0!"},{"location":"primer/03_MongoDB_part1/exercise_03/#5-use-the-size-operator-to-find-the-total-number-of-awarded-peace-prizes-shared-by-exactly-three-people","text":"criteria = { __ : __ , __ : { __ : 3 }} count = db . prizes . count_documents ( criteria ) count","title":"5. Use the $size operator to find the total number of awarded peace prizes shared by exactly three people."},{"location":"primer/03_MongoDB_part1/exercise_03/#6-estimate-the-number-of-laureates-who-were-awarded-a-prize-affiliated-with-the-usa-but-were-born-in-a-different-country-use-only-the-first-prize-and-affiliation-in-each-respective-array-recall-the-structure-of-a-document-in-laureates","text":"{'_id': ObjectId('5f1746222466f220f494d292'), 'id': '1', 'firstname': 'Wilhelm Conrad', 'surname': 'R\u00f6ntgen', 'born': '1845-03-27', 'died': '1923-02-10', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'bornCity': 'Lennep (now Remscheid)', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'diedCity': 'Munich', 'gender': 'male', 'prizes': [{'year': '1901', 'category': 'physics', 'share': '1', 'motivation': '\"in recognition of the extraordinary services he has rendered by the discovery of the remarkable rays subsequently named after him\"', 'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]} criteria = { __ : { __ : \"USA\" }, \"__.__.__.__.__\" : \"USA\" } count = db . laureates . count_documents ( criteria ) count","title":"6. Estimate the number of laureates who were awarded a prize affiliated with the USA, but were born in a different country. Use only the first prize and affiliation in each respective array. Recall the structure of a document in laureates:"},{"location":"primer/03_MongoDB_part1/lessons/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Intro to MongoDB and the Nobel Prize Dataset - Lesson 1 \u00b6 Why MongoDB? \u00b6 All Materials Project data is stored using MongoDB Our API query language is based on MongoDB syntax MongoDB Structure \u00b6 Data objects represented by documents Documents organized into collections Collections make up a database Data Structure \u00b6 object \u2192 { field : value , field1 : value1 , ...} fields: string values: string , int/double , true , false , null , array , object , ... example: { name: Sue, age: 28, lawSpecialties: [copyright, tax], canMeet: { mon: True, tues: False, wed: True, thurs: True, fri: False, } } JavaScript Object Notation (JSON) \u00b6 object \u2192 { string : value , string1 : value1 , ...} values: string , number , true , false , null , object , array JSON \\longleftrightarrow \\longleftrightarrow Python \u00b6 objects \u2192 { string : value , string1 : value1 , ...} ---> dictionaries (with str keys) arrays \u2192 [ value , value1 , ...] ---> lists values: string , number , true , false , null , object , array str , int , float , True , False , None , dict , list Accessing MongoDB \u00b6 We can access our MongoDB databases using an instance of MongoClient from the pymongo package. from pymongo import MongoClient client = MongoClient () print ( client ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True) You can access databases and collections as attributes and/or treat them as dictionary keys. client . nobel == client [ \"nobel\" ] True client . nobel . prizes == client [ \"nobel\" ][ \"prizes\" ] True We can also connect to the nobel database. db = client . nobel print ( db ) Database(MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True), 'nobel') Searching for documents \u00b6 Let's see what a document looks like in the prizes collection using the find_one() method. This takes an optional filter argument. Passing an empty filter ( {} ) is the same as passing no filter. In Python, the returned document takes the form of a dictionary. The keys of the dictionary are the (root-level) \"fields\" of the document. db . prizes . find_one ({}) {'_id': ObjectId('5f1f4e9430688833f8e30309'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} We can now add a filter to our search to ensure that the returned prizes document contains data for a physics nobel prize. criteria = { \"category\" : \"physics\" } db . prizes . find_one ( criteria ) {'_id': ObjectId('5f1f4e9430688833f8e3030d'), 'year': '2019', 'category': 'physics', 'overallMotivation': '\"for contributions to our understanding of the evolution of the universe and Earth\u2019s place in the cosmos\"', 'laureates': [{'id': '973', 'firstname': 'James', 'surname': 'Peebles', 'motivation': '\"for theoretical discoveries in physical cosmology\"', 'share': '2'}, {'id': '974', 'firstname': 'Michel', 'surname': 'Mayor', 'motivation': '\"for the discovery of an exoplanet orbiting a solar-type star\"', 'share': '4'}, {'id': '975', 'firstname': 'Didier', 'surname': 'Queloz', 'motivation': '\"for the discovery of an exoplanet orbiting a solar-type star\"', 'share': '4'}]} You may iterate over a collection, collecting from each document. However, a collection is not a list, so we can't write for doc in <collection> to iterate over documents. Instead, we can use the find() method to produce an iterable called a cursor , and instead write for doc in <collection>.find() to iterate over documents. - Using find() to iterate over documents in the laureates collection, sum the total number of laureate prizes. The length of doc[\"prizes\"] for a laureate document doc is the number of prizes won by that laureate. Store the sum in the variable count . # Compute the total number of laureate prizes count = 0 cursor = db . laureates . find ({}) for doc in cursor : num_prizes = len ( doc [ \"prizes\" ]) count += num_prizes count 950 Listing and Counting - Lesson 2 \u00b6 from pymongo import MongoClient client = MongoClient () print ( client ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True) Listing databases and collections \u00b6 Recall: - Data objects represented by documents - Documents organized into collections - Collections make up a database We can list database names by calling list_database_names() on a client instance, and we can list collection names by calling list_collection_names() on a database instance. - How many databases are managed by client ? # Save a list of names of the databases managed by client db_names = client . list_database_names () print ( db_names ) # Save a list of names of the collections managed by the \"nobel\" database nobel_coll_names = client . nobel . list_collection_names () print ( nobel_coll_names ) ['admin', 'config', 'drone_test', 'fireworks', 'local', 'maggma_test', 'mp_workshop', 'nobel'] ['prizes', 'laureates'] Counting documents \u00b6 # Connect to our \"nobel\" database db = client . nobel The count_documents() method of a collection can be used to count the number of documents matching a particular filter. Let's use the method to count the total number of nobel laureates who died in the USA. An example laureates document: {'_id': ObjectId('5b9ac94ff35b63cf5231ccb1'), 'born': '1845-03-27', 'bornCity': 'Lennep (now Remscheid)', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'died': '1923-02-10', 'diedCity': 'Munich', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'firstname': 'Wilhelm Conrad', 'gender': 'male', 'id': '1', 'prizes': [{'affiliations': [{'city': 'Munich', 'country': 'Germany', 'name': 'Munich University'}], 'category': 'physics', 'motivation': '\"in recognition of the extraordinary services ' 'he has rendered by the discovery of the ' 'remarkable rays subsequently named after him\"', 'share': '1', 'year': '1901'}], 'surname': 'R\u00f6ntgen'} db . laureates . count_documents ({ \"diedCountry\" : \"USA\" }) 222 We can now build out our filter to reduce the total number of matching documents: Create a filter criteria to count the number of laureates who died in the USA but were born ( \"bornCountry\" ) in Germany. # Create a filter for laureates who died in the USA but were born in Germany criteria = { \"diedCountry\" : \"USA\" , \"bornCountry\" : \"Germany\" } # Save a count count = db . laureates . count_documents ( criteria ) print ( count ) 5 - Count laureates who died in the USA, were born in Germany, and whose first name ( \"firstname\" ) was \"Albert\". # Create a filter for laureates who died in the USA, were born in Germany, and whose first name was Albert. criteria = { \"diedCountry\" : \"USA\" , \"bornCountry\" : \"Germany\" , \"firstname\" : \"Albert\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 1 db . laureates . find_one ( criteria ) {'_id': ObjectId('5f1f4e418defad6d9f1ccead'), 'id': '26', 'firstname': 'Albert', 'surname': 'Einstein', 'born': '1879-03-14', 'died': '1955-04-18', 'bornCountry': 'Germany', 'bornCountryCode': 'DE', 'bornCity': 'Ulm', 'diedCountry': 'USA', 'diedCountryCode': 'US', 'diedCity': 'Princeton, NJ', 'gender': 'male', 'prizes': [{'year': '1921', 'category': 'physics', 'share': '1', 'motivation': '\"for his services to Theoretical Physics, and especially for his discovery of the law of the photoelectric effect\"', 'affiliations': [{'name': 'Kaiser-Wilhelm-Institut (now Max-Planck-Institut) f\u00fcr Physik', 'city': 'Berlin', 'country': 'Germany'}]}]} Finding, and Dot Notation - Lesson 3 \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel print ( client ) print ( db ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True) Database(MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True), 'nobel') Query operators \u00b6 Query operators provide us more options when constructing filters. For example, we may wish to find documents where a field's value matches any of a set of options. To do this we can use the $in query operator. - How many laureates were born in any of \"Canada\", \"Mexico\", or \"USA\"? #Save a filter for laureates who were born in with Canada, Mexico, or the USA. criteria = { \"bornCountry\" : { \"$in\" : [ \"Canada\" , \"Mexico\" , \"USA\" ]}} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 295 If we wish to accept all but one option as a value for a field, we can use the $ne ( n ot e qual) operator. - How many laureates died in the USA but were not born in the USA? # Save a filter for laureates who died in the USA and were not born there. criteria = { \"bornCountry\" : { \"$ne\" : \"USA\" }, \"diedCountry\" : \"USA\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 71 Below is a list of comparison query operators that are available in MongoDB: $eq -- Matches values that are equal to a specified value. $gt -- Matches values that are greater than a specified value. $gte -- Matches values that are greater than or equal to a specified value. $in -- Matches any of the values specified in an array. $lt -- Matches values that are less than a specified value. $lte -- Matches values that are less than or equal to a specified value. $ne -- Matches all values that are not equal to a specified value. $nin -- Matches none of the values specified in an array. In addition to comparison query operators, we can use logical query operators in our filters as well. - How many laureates died in Canada OR were born in France? #Save a filter for laureates who were born in Canada OR died in France. criteria = { \"$or\" :[{ \"diedCountry\" : \"Canada\" }, { \"bornCountry\" : \"France\" }]} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 59 Below is a list of logical query operators that are available in MongoDB: $and -- Joins query clauses with a logical AND returns all documents that match the conditions of both clauses. $not -- Inverts the effect of a query expression and returns documents that do not match the query expression. $nor -- Joins query clauses with a logical NOR returns all documents that fail to match both clauses. $or -- Joins query clauses with a logical OR returns all documents that match the conditions of either clause. See https://docs.mongodb.com/manual/reference/operator/query/ for more operators! Using dot notation \u00b6 You will notice that the prizes field of a laureates document consists of an array of subdocuments: An example laureates document: {'_id': ObjectId('5b9ac94ff35b63cf5231ccb1'), 'born': '1845-03-27', 'bornCity': 'Lennep (now Remscheid)', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'died': '1923-02-10', 'diedCity': 'Munich', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'firstname': 'Wilhelm Conrad', 'gender': 'male', 'id': '1', 'prizes': [{'affiliations': [{'city': 'Munich', 'country': 'Germany', 'name': 'Munich University'}], 'category': 'physics', 'motivation': '\"in recognition of the extraordinary services ' 'he has rendered by the discovery of the ' 'remarkable rays subsequently named after him\"', 'share': '1', 'year': '1901'}], 'surname': 'R\u00f6ntgen'} An easy way to construct filters for array entries or subdocument fields is to use dot notation. - Use the $exists operator to find out how many laureates were awarded at least two prizes? #Save a filter for laureates who were awarded at least two prizes. criteria = { \"prizes.1\" :{ \"$exists\" : True }} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 6 - Estimate how many laureates were awarded at least two prizes in physics specifically? #Save a filter to estimate the number of laureates who were awarded at least two prizes in physics. criteria = { \"prizes.0.category\" : \"physics\" , \"prizes.1.category\" : \"physics\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 1 db . laureates . find_one ( criteria ) {'_id': ObjectId('5f1f4e418defad6d9f1cced5'), 'id': '66', 'firstname': 'John', 'surname': 'Bardeen', 'born': '1908-05-23', 'died': '1991-01-30', 'bornCountry': 'USA', 'bornCountryCode': 'US', 'bornCity': 'Madison, WI', 'diedCountry': 'USA', 'diedCountryCode': 'US', 'diedCity': 'Boston, MA', 'gender': 'male', 'prizes': [{'year': '1956', 'category': 'physics', 'share': '3', 'motivation': '\"for their researches on semiconductors and their discovery of the transistor effect\"', 'affiliations': [{'name': 'University of Illinois', 'city': 'Urbana, IL', 'country': 'USA'}]}, {'year': '1972', 'category': 'physics', 'share': '3', 'motivation': '\"for their jointly developed theory of superconductivity, usually called the BCS-theory\"', 'affiliations': [{'name': 'University of Illinois', 'city': 'Urbana, IL', 'country': 'USA'}]}]}","title":"Intro to MongoDB"},{"location":"primer/03_MongoDB_part1/lessons/#intro-to-mongodb-and-the-nobel-prize-dataset-lesson-1","text":"","title":"Intro to MongoDB and the Nobel Prize Dataset - Lesson 1"},{"location":"primer/03_MongoDB_part1/lessons/#why-mongodb","text":"All Materials Project data is stored using MongoDB Our API query language is based on MongoDB syntax","title":"Why MongoDB?"},{"location":"primer/03_MongoDB_part1/lessons/#mongodb-structure","text":"Data objects represented by documents Documents organized into collections Collections make up a database","title":"MongoDB Structure"},{"location":"primer/03_MongoDB_part1/lessons/#data-structure","text":"object \u2192 { field : value , field1 : value1 , ...} fields: string values: string , int/double , true , false , null , array , object , ... example: { name: Sue, age: 28, lawSpecialties: [copyright, tax], canMeet: { mon: True, tues: False, wed: True, thurs: True, fri: False, } }","title":"Data Structure"},{"location":"primer/03_MongoDB_part1/lessons/#javascript-object-notation-json","text":"object \u2192 { string : value , string1 : value1 , ...} values: string , number , true , false , null , object , array","title":"JavaScript Object Notation (JSON)"},{"location":"primer/03_MongoDB_part1/lessons/#json-longleftrightarrowlongleftrightarrow-python","text":"objects \u2192 { string : value , string1 : value1 , ...} ---> dictionaries (with str keys) arrays \u2192 [ value , value1 , ...] ---> lists values: string , number , true , false , null , object , array str , int , float , True , False , None , dict , list","title":"JSON \\longleftrightarrow\\longleftrightarrow Python"},{"location":"primer/03_MongoDB_part1/lessons/#accessing-mongodb","text":"We can access our MongoDB databases using an instance of MongoClient from the pymongo package. from pymongo import MongoClient client = MongoClient () print ( client ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True) You can access databases and collections as attributes and/or treat them as dictionary keys. client . nobel == client [ \"nobel\" ] True client . nobel . prizes == client [ \"nobel\" ][ \"prizes\" ] True We can also connect to the nobel database. db = client . nobel print ( db ) Database(MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True), 'nobel')","title":"Accessing MongoDB"},{"location":"primer/03_MongoDB_part1/lessons/#searching-for-documents","text":"Let's see what a document looks like in the prizes collection using the find_one() method. This takes an optional filter argument. Passing an empty filter ( {} ) is the same as passing no filter. In Python, the returned document takes the form of a dictionary. The keys of the dictionary are the (root-level) \"fields\" of the document. db . prizes . find_one ({}) {'_id': ObjectId('5f1f4e9430688833f8e30309'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} We can now add a filter to our search to ensure that the returned prizes document contains data for a physics nobel prize. criteria = { \"category\" : \"physics\" } db . prizes . find_one ( criteria ) {'_id': ObjectId('5f1f4e9430688833f8e3030d'), 'year': '2019', 'category': 'physics', 'overallMotivation': '\"for contributions to our understanding of the evolution of the universe and Earth\u2019s place in the cosmos\"', 'laureates': [{'id': '973', 'firstname': 'James', 'surname': 'Peebles', 'motivation': '\"for theoretical discoveries in physical cosmology\"', 'share': '2'}, {'id': '974', 'firstname': 'Michel', 'surname': 'Mayor', 'motivation': '\"for the discovery of an exoplanet orbiting a solar-type star\"', 'share': '4'}, {'id': '975', 'firstname': 'Didier', 'surname': 'Queloz', 'motivation': '\"for the discovery of an exoplanet orbiting a solar-type star\"', 'share': '4'}]} You may iterate over a collection, collecting from each document. However, a collection is not a list, so we can't write for doc in <collection> to iterate over documents. Instead, we can use the find() method to produce an iterable called a cursor , and instead write for doc in <collection>.find() to iterate over documents. - Using find() to iterate over documents in the laureates collection, sum the total number of laureate prizes. The length of doc[\"prizes\"] for a laureate document doc is the number of prizes won by that laureate. Store the sum in the variable count . # Compute the total number of laureate prizes count = 0 cursor = db . laureates . find ({}) for doc in cursor : num_prizes = len ( doc [ \"prizes\" ]) count += num_prizes count 950","title":"Searching for documents"},{"location":"primer/03_MongoDB_part1/lessons/#listing-and-counting-lesson-2","text":"from pymongo import MongoClient client = MongoClient () print ( client ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True)","title":"Listing and Counting - Lesson 2"},{"location":"primer/03_MongoDB_part1/lessons/#listing-databases-and-collections","text":"Recall: - Data objects represented by documents - Documents organized into collections - Collections make up a database We can list database names by calling list_database_names() on a client instance, and we can list collection names by calling list_collection_names() on a database instance. - How many databases are managed by client ? # Save a list of names of the databases managed by client db_names = client . list_database_names () print ( db_names ) # Save a list of names of the collections managed by the \"nobel\" database nobel_coll_names = client . nobel . list_collection_names () print ( nobel_coll_names ) ['admin', 'config', 'drone_test', 'fireworks', 'local', 'maggma_test', 'mp_workshop', 'nobel'] ['prizes', 'laureates']","title":"Listing databases and collections"},{"location":"primer/03_MongoDB_part1/lessons/#counting-documents","text":"# Connect to our \"nobel\" database db = client . nobel The count_documents() method of a collection can be used to count the number of documents matching a particular filter. Let's use the method to count the total number of nobel laureates who died in the USA. An example laureates document: {'_id': ObjectId('5b9ac94ff35b63cf5231ccb1'), 'born': '1845-03-27', 'bornCity': 'Lennep (now Remscheid)', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'died': '1923-02-10', 'diedCity': 'Munich', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'firstname': 'Wilhelm Conrad', 'gender': 'male', 'id': '1', 'prizes': [{'affiliations': [{'city': 'Munich', 'country': 'Germany', 'name': 'Munich University'}], 'category': 'physics', 'motivation': '\"in recognition of the extraordinary services ' 'he has rendered by the discovery of the ' 'remarkable rays subsequently named after him\"', 'share': '1', 'year': '1901'}], 'surname': 'R\u00f6ntgen'} db . laureates . count_documents ({ \"diedCountry\" : \"USA\" }) 222 We can now build out our filter to reduce the total number of matching documents: Create a filter criteria to count the number of laureates who died in the USA but were born ( \"bornCountry\" ) in Germany. # Create a filter for laureates who died in the USA but were born in Germany criteria = { \"diedCountry\" : \"USA\" , \"bornCountry\" : \"Germany\" } # Save a count count = db . laureates . count_documents ( criteria ) print ( count ) 5 - Count laureates who died in the USA, were born in Germany, and whose first name ( \"firstname\" ) was \"Albert\". # Create a filter for laureates who died in the USA, were born in Germany, and whose first name was Albert. criteria = { \"diedCountry\" : \"USA\" , \"bornCountry\" : \"Germany\" , \"firstname\" : \"Albert\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 1 db . laureates . find_one ( criteria ) {'_id': ObjectId('5f1f4e418defad6d9f1ccead'), 'id': '26', 'firstname': 'Albert', 'surname': 'Einstein', 'born': '1879-03-14', 'died': '1955-04-18', 'bornCountry': 'Germany', 'bornCountryCode': 'DE', 'bornCity': 'Ulm', 'diedCountry': 'USA', 'diedCountryCode': 'US', 'diedCity': 'Princeton, NJ', 'gender': 'male', 'prizes': [{'year': '1921', 'category': 'physics', 'share': '1', 'motivation': '\"for his services to Theoretical Physics, and especially for his discovery of the law of the photoelectric effect\"', 'affiliations': [{'name': 'Kaiser-Wilhelm-Institut (now Max-Planck-Institut) f\u00fcr Physik', 'city': 'Berlin', 'country': 'Germany'}]}]}","title":"Counting documents"},{"location":"primer/03_MongoDB_part1/lessons/#finding-and-dot-notation-lesson-3","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel print ( client ) print ( db ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True) Database(MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True), 'nobel')","title":"Finding, and Dot Notation - Lesson 3"},{"location":"primer/03_MongoDB_part1/lessons/#query-operators","text":"Query operators provide us more options when constructing filters. For example, we may wish to find documents where a field's value matches any of a set of options. To do this we can use the $in query operator. - How many laureates were born in any of \"Canada\", \"Mexico\", or \"USA\"? #Save a filter for laureates who were born in with Canada, Mexico, or the USA. criteria = { \"bornCountry\" : { \"$in\" : [ \"Canada\" , \"Mexico\" , \"USA\" ]}} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 295 If we wish to accept all but one option as a value for a field, we can use the $ne ( n ot e qual) operator. - How many laureates died in the USA but were not born in the USA? # Save a filter for laureates who died in the USA and were not born there. criteria = { \"bornCountry\" : { \"$ne\" : \"USA\" }, \"diedCountry\" : \"USA\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 71 Below is a list of comparison query operators that are available in MongoDB: $eq -- Matches values that are equal to a specified value. $gt -- Matches values that are greater than a specified value. $gte -- Matches values that are greater than or equal to a specified value. $in -- Matches any of the values specified in an array. $lt -- Matches values that are less than a specified value. $lte -- Matches values that are less than or equal to a specified value. $ne -- Matches all values that are not equal to a specified value. $nin -- Matches none of the values specified in an array. In addition to comparison query operators, we can use logical query operators in our filters as well. - How many laureates died in Canada OR were born in France? #Save a filter for laureates who were born in Canada OR died in France. criteria = { \"$or\" :[{ \"diedCountry\" : \"Canada\" }, { \"bornCountry\" : \"France\" }]} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 59 Below is a list of logical query operators that are available in MongoDB: $and -- Joins query clauses with a logical AND returns all documents that match the conditions of both clauses. $not -- Inverts the effect of a query expression and returns documents that do not match the query expression. $nor -- Joins query clauses with a logical NOR returns all documents that fail to match both clauses. $or -- Joins query clauses with a logical OR returns all documents that match the conditions of either clause. See https://docs.mongodb.com/manual/reference/operator/query/ for more operators!","title":"Query operators"},{"location":"primer/03_MongoDB_part1/lessons/#using-dot-notation","text":"You will notice that the prizes field of a laureates document consists of an array of subdocuments: An example laureates document: {'_id': ObjectId('5b9ac94ff35b63cf5231ccb1'), 'born': '1845-03-27', 'bornCity': 'Lennep (now Remscheid)', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'died': '1923-02-10', 'diedCity': 'Munich', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'firstname': 'Wilhelm Conrad', 'gender': 'male', 'id': '1', 'prizes': [{'affiliations': [{'city': 'Munich', 'country': 'Germany', 'name': 'Munich University'}], 'category': 'physics', 'motivation': '\"in recognition of the extraordinary services ' 'he has rendered by the discovery of the ' 'remarkable rays subsequently named after him\"', 'share': '1', 'year': '1901'}], 'surname': 'R\u00f6ntgen'} An easy way to construct filters for array entries or subdocument fields is to use dot notation. - Use the $exists operator to find out how many laureates were awarded at least two prizes? #Save a filter for laureates who were awarded at least two prizes. criteria = { \"prizes.1\" :{ \"$exists\" : True }} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 6 - Estimate how many laureates were awarded at least two prizes in physics specifically? #Save a filter to estimate the number of laureates who were awarded at least two prizes in physics. criteria = { \"prizes.0.category\" : \"physics\" , \"prizes.1.category\" : \"physics\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 1 db . laureates . find_one ( criteria ) {'_id': ObjectId('5f1f4e418defad6d9f1cced5'), 'id': '66', 'firstname': 'John', 'surname': 'Bardeen', 'born': '1908-05-23', 'died': '1991-01-30', 'bornCountry': 'USA', 'bornCountryCode': 'US', 'bornCity': 'Madison, WI', 'diedCountry': 'USA', 'diedCountryCode': 'US', 'diedCity': 'Boston, MA', 'gender': 'male', 'prizes': [{'year': '1956', 'category': 'physics', 'share': '3', 'motivation': '\"for their researches on semiconductors and their discovery of the transistor effect\"', 'affiliations': [{'name': 'University of Illinois', 'city': 'Urbana, IL', 'country': 'USA'}]}, {'year': '1972', 'category': 'physics', 'share': '3', 'motivation': '\"for their jointly developed theory of superconductivity, usually called the BCS-theory\"', 'affiliations': [{'name': 'University of Illinois', 'city': 'Urbana, IL', 'country': 'USA'}]}]}","title":"Using dot notation"},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Intro to MongoDB and the Nobel Prize Dataset - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db ) 2. Obtain a document from the laureates collection and display its contents. \u00b6 doc = db . laureates . find_one ({}) doc Obtain a list of field values for this document that have a string value. \u00b6 fields = [ field for field in doc if type ( doc [ field ]) is str ] fields 3. Obtain a list of tuples containing the first and last name of each laureate in the database who died in USA. i.e. (FirstName, LastName) \u00b6 cursor = db . laureates . find ({ \"diedCountry\" : \"USA\" }) names = [( doc [ \"firstname\" ], doc [ \"surname\" ]) for doc in cursor ] names 4. Did any of the above laureates receive more than one prize? Generate a list of tuples with their first name and the total number they were awarded. \u00b6 cursor = db . laureates . find ({}) names = [( doc [ \"firstname\" ], len ( doc [ \"prizes\" ])) for doc in cursor if len ( doc [ \"prizes\" ]) > 1 ] names","title":"Exercise 01 solved"},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#intro-to-mongodb-and-the-nobel-prize-dataset-exercise","text":"","title":"Intro to MongoDB and the Nobel Prize Dataset - Exercise"},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#2-obtain-a-document-from-the-laureates-collection-and-display-its-contents","text":"doc = db . laureates . find_one ({}) doc","title":"2. Obtain a document from the laureates collection and display its contents."},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#obtain-a-list-of-field-values-for-this-document-that-have-a-string-value","text":"fields = [ field for field in doc if type ( doc [ field ]) is str ] fields","title":"Obtain a list of field values for this document that have a string value."},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#3-obtain-a-list-of-tuples-containing-the-first-and-last-name-of-each-laureate-in-the-database-who-died-in-usa-ie-firstname-lastname","text":"cursor = db . laureates . find ({ \"diedCountry\" : \"USA\" }) names = [( doc [ \"firstname\" ], doc [ \"surname\" ]) for doc in cursor ] names","title":"3. Obtain a list of tuples containing the first and last name of each laureate in the database who died in USA. i.e. (FirstName, LastName)"},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#4-did-any-of-the-above-laureates-receive-more-than-one-prize-generate-a-list-of-tuples-with-their-first-name-and-the-total-number-they-were-awarded","text":"cursor = db . laureates . find ({}) names = [( doc [ \"firstname\" ], len ( doc [ \"prizes\" ])) for doc in cursor if len ( doc [ \"prizes\" ]) > 1 ] names","title":"4. Did any of the above laureates receive more than one prize? Generate a list of tuples with their first name and the total number they were awarded."},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Listing and Counting - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db ) 2. Obtain a document from the prizes collection and display its contents. \u00b6 doc = db . prizes . find_one ({}) doc 3. Use count_documents to identify which of the following statements is true? \u00b6 A. the number of prizes and laureates are equal B. prizes outnumber laureates by < 2x C. prizes outnumber laureates by > 2x D. laureates outnumber prizes by < 2x E. laureates outnumber prizes by > 2x num_prizes = db . prizes . count_documents ({}) num_laureates = db . laureates . count_documents ({}) num_laureates / num_prizes # D is correct. Is the number of peace prizes awarded in 1911 larger or smaller than the number of laureates who were born ( \"bornCountry\" ) in Finland? \u00b6 num_prizes = db . prizes . count_documents ({ \"year\" : \"1911\" }) num_laureates = db . laureates . count_documents ({ \"bornCountry\" : \"Finland\" }) num_laureates > num_prizes","title":"Exercise 02 solved"},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/#listing-and-counting-exercise","text":"","title":"Listing and Counting - Exercise"},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/#2-obtain-a-document-from-the-prizes-collection-and-display-its-contents","text":"doc = db . prizes . find_one ({}) doc","title":"2. Obtain a document from the prizes collection and display its contents."},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/#3-use-count_documents-to-identify-which-of-the-following-statements-is-true","text":"A. the number of prizes and laureates are equal B. prizes outnumber laureates by < 2x C. prizes outnumber laureates by > 2x D. laureates outnumber prizes by < 2x E. laureates outnumber prizes by > 2x num_prizes = db . prizes . count_documents ({}) num_laureates = db . laureates . count_documents ({}) num_laureates / num_prizes # D is correct.","title":"3. Use count_documents to identify which of the following statements is true?"},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/#is-the-number-of-peace-prizes-awarded-in-1911-larger-or-smaller-than-the-number-of-laureates-who-were-born-borncountry-in-finland","text":"num_prizes = db . prizes . count_documents ({ \"year\" : \"1911\" }) num_laureates = db . laureates . count_documents ({ \"bornCountry\" : \"Finland\" }) num_laureates > num_prizes","title":"Is the number of peace prizes awarded in 1911 larger or smaller than the number of laureates who were born (\"bornCountry\") in Finland?"},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Finding, and Dot Notation - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db ) 2. Find the total number of laureates who died ( \"diedCountry\" ) in Canada and were not born in Germany using the $ne operator. \u00b6 criteria = { \"diedCountry\" : \"Canada\" , \"bornCountry\" : { \"$ne\" : \"Germany\" }} count = db . laureates . count_documents ( criteria ) count 3. Use the $in and $gt operators to count the total number of physics and chemistry prizes awarded after the year 1930. Recall the structure of a document in prizes : \u00b6 {'_id': ObjectId('5f1746222466f220f494d00c'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} criteria = { \"category\" : { \"$in\" : [ \"physics\" , \"chemistry\" ]}, \"year\" :{ \"$gt\" : \"1930\" }} count = db . prizes . count_documents ( criteria ) count 4. Let's define \"high-share\" prizes as those shared by at least three people. Use dot notation and the $exists operator to find the number of \"high-share\" physics and chemistry prizes awarded after the year 2001. Remember arrays start with index 0 ! \u00b6 criteria = { \"category\" : { \"$in\" : [ \"physics\" , \"chemistry\" ]}, \"year\" :{ \"$gt\" : \"2001\" }, \"laureates.2\" : { \"$exists\" : True }} count = db . prizes . count_documents ( criteria ) count 5. Use the $size operator to find the total number of awarded peace prizes shared by exactly three people. \u00b6 criteria = { \"category\" : \"peace\" , \"laureates\" : { \"$size\" : 3 }} count = db . prizes . count_documents ( criteria ) count 6. Estimate the number of laureates who were awarded a prize ( \"prizes\" ) affiliated with the USA, but were born in a different country ( \"bornCountry\" ). Use only the first prize and affiliation in each respective array. Recall the structure of a document in laureates : \u00b6 {'_id': ObjectId('5f1746222466f220f494d292'), 'id': '1', 'firstname': 'Wilhelm Conrad', 'surname': 'R\u00f6ntgen', 'born': '1845-03-27', 'died': '1923-02-10', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'bornCity': 'Lennep (now Remscheid)', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'diedCity': 'Munich', 'gender': 'male', 'prizes': [{'year': '1901', 'category': 'physics', 'share': '1', 'motivation': '\"in recognition of the extraordinary services he has rendered by the discovery of the remarkable rays subsequently named after him\"', 'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]} criteria = { \"bornCountry\" : { \"$ne\" : \"USA\" }, \"prizes.0.affiliations.0.country\" : \"USA\" } count = db . laureates . count_documents ( criteria ) count","title":"Exercise 03 solved"},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#finding-and-dot-notation-exercise","text":"","title":"Finding, and Dot Notation - Exercise"},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#2-find-the-total-number-of-laureates-who-died-diedcountry-in-canada-and-were-not-born-in-germany-using-the-ne-operator","text":"criteria = { \"diedCountry\" : \"Canada\" , \"bornCountry\" : { \"$ne\" : \"Germany\" }} count = db . laureates . count_documents ( criteria ) count","title":"2. Find the total number of laureates who died (\"diedCountry\") in Canada and were not born in Germany using the $ne operator."},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#3-use-the-in-and-gt-operators-to-count-the-total-number-of-physics-and-chemistry-prizes-awarded-after-the-year-1930-recall-the-structure-of-a-document-in-prizes","text":"{'_id': ObjectId('5f1746222466f220f494d00c'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} criteria = { \"category\" : { \"$in\" : [ \"physics\" , \"chemistry\" ]}, \"year\" :{ \"$gt\" : \"1930\" }} count = db . prizes . count_documents ( criteria ) count","title":"3. Use the $in and $gt operators to count the total number of physics and chemistry prizes awarded after the year 1930. Recall the structure of a document in prizes:"},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#4-lets-define-high-share-prizes-as-those-shared-by-at-least-three-people-use-dot-notation-and-the-exists-operator-to-find-the-number-of-high-share-physics-and-chemistry-prizes-awarded-after-the-year-2001-remember-arrays-start-with-index-0","text":"criteria = { \"category\" : { \"$in\" : [ \"physics\" , \"chemistry\" ]}, \"year\" :{ \"$gt\" : \"2001\" }, \"laureates.2\" : { \"$exists\" : True }} count = db . prizes . count_documents ( criteria ) count","title":"4. Let's define \"high-share\" prizes as those shared by at least three people. Use dot notation and the $exists operator to find the number of \"high-share\" physics and chemistry prizes awarded after the year 2001. Remember arrays start with index 0!"},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#5-use-the-size-operator-to-find-the-total-number-of-awarded-peace-prizes-shared-by-exactly-three-people","text":"criteria = { \"category\" : \"peace\" , \"laureates\" : { \"$size\" : 3 }} count = db . prizes . count_documents ( criteria ) count","title":"5. Use the $size operator to find the total number of awarded peace prizes shared by exactly three people."},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#6-estimate-the-number-of-laureates-who-were-awarded-a-prize-prizes-affiliated-with-the-usa-but-were-born-in-a-different-country-borncountry-use-only-the-first-prize-and-affiliation-in-each-respective-array-recall-the-structure-of-a-document-in-laureates","text":"{'_id': ObjectId('5f1746222466f220f494d292'), 'id': '1', 'firstname': 'Wilhelm Conrad', 'surname': 'R\u00f6ntgen', 'born': '1845-03-27', 'died': '1923-02-10', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'bornCity': 'Lennep (now Remscheid)', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'diedCity': 'Munich', 'gender': 'male', 'prizes': [{'year': '1901', 'category': 'physics', 'share': '1', 'motivation': '\"in recognition of the extraordinary services he has rendered by the discovery of the remarkable rays subsequently named after him\"', 'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]} criteria = { \"bornCountry\" : { \"$ne\" : \"USA\" }, \"prizes.0.affiliations.0.country\" : \"USA\" } count = db . laureates . count_documents ( criteria ) count","title":"6. Estimate the number of laureates who were awarded a prize (\"prizes\") affiliated with the USA, but were born in a different country (\"bornCountry\"). Use only the first prize and affiliation in each respective array. Recall the structure of a document in laureates:"},{"location":"primer/04_MongoDB_part2/exercises/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); MongoDB Part 2 Exercises \u00b6 1: Working with Distinct Values, $elemMatch, and Regex \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel Never from there, but sometimes there at last \u00b6 There are some recorded countries of death ( \"diedCountry\" ) that do not appear as a country of birth ( \"bornCountry\" ) for laureates. One such country is \"East Germany\". Return a set of all such countries as countries . # Countries recorded as countries of death but not as countries of birth countries = set ( ____ ) - set ( ____ ) print ( countries ) Countries of affiliation \u00b6 We saw in the last exercise that countries can be associated with a laureate as their country of birth and as their country of death. For each prize a laureate received, they may also have been affiliated with an institution at the time, located in a country. Determine the number of distinct countries recorded as part of an affiliation for laureates' prizes. Save this as count . # The number of distinct countries of laureate affiliation for prizes count = ____ ( db . laureates . ____ ( ____ )) print ( count ) Triple plays (mostly) all around \u00b6 All prize categories but one \u2013 literature \u2013 have had prizes shared by three or more laureates. Save a filter document criteria that, when passed to db.prizes.distinct , returns all prize categories shared by three or more laureates. That is, \"laureates.2\" must exist for such documents. Save these prize categories as a Python set called triple_play_categories . Confirm via an assertion that \"literature\" is the only prize category with no prizes shared by three or more laureates. # Save a filter for prize documents with three or more laureates criteria = { ____ : { ____ : ____ }} # Save the set of distinct prize categories in documents satisfying the criteria triple_play_categories = ____ ( db . prizes . distinct ( ____ , criteria )) # Confirm literature as the only category not satisfying the criteria. assert set ( db . prizes . distinct ( ____ )) - triple_play_categories == { ____ } Other sharing after World War II \u00b6 Similar to the example in the lesson, what is the approximate ratio of the number of laureates who won an unshared prize in categories other than physics, chemistry, and medicine after World War II to the number of laureates who won a shared prize in categories other than physics, chemistry, and medicine after World War II? Save an $elemMatch filter unshared to count laureates with unshared prizes in categories other than (\"not in\") [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. Save an $elemMatch filter shared to count laureates with shared (i.e., \"share\" is not \"1\") prizes in categories other than [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { ____ : { ____ : { ____ : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : \"1\" , \"year\" : { ____ : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { ____ : { ____ : { ____ : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : { ____ : \"1\" }, \"year\" : { ____ : \"1945\" }, }}} ratio = db . laureates . ____ ( ____ ) / db . laureates . ____ ( ____ ) print ( ratio ) Organizations and prizes over time \u00b6 How many organizations won prizes before 1945 versus in or after 1945? - Save a filter before to count organization laureates with prizes won before 1945. Recall that organization status is encoded with the \"gender\" field, and that dot notation is needed to access a laureate's \"year\" field within its \"prizes\" array. - Save a filter in_or_after to count organization laureates with prizes won in or after 1945. # Save a filter for organization laureates with prizes won before 1945 before = { ____ : ____ , ____ : { ____ : \"1945\" }, } # Save a filter for organization laureates with prizes won in or after 1945 in_or_after = { ____ : ____ , ____ : { ____ : \"1945\" }, } n_before = db . laureates . count_documents ( before ) n_in_or_after = db . laureates . count_documents ( in_or_after ) ratio = n_in_or_after / ( n_in_or_after + n_before ) print ( ratio ) Germany, then and now \u00b6 Just as we saw with Poland, there are laureates who were born somewhere that was in Germany at the time but is now not, and others born somewhere that was not in Germany at the time but now is. - Use a regular expression object to filter for laureates with \"Germany\" in their \"bornCountry\" value. # Filter for laureates with \"Germany\" in their \"bornCountry\" value criteria = { \"bornCountry\" : { \"$regex\" : ____ }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates with a \"bornCountry\" value starting with \"Germany\". # Filter for laureates with a \"bornCountry\" value starting with \"Germany\" criteria = { \"bornCountry\" : { ____ : ____ }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what was at the time Germany but is now another country. # Fill in a string value to be sandwiched between the strings \"^\" and \"now\" criteria = { \"bornCountry\" : { ____ : \"^\" + ____ + \"now\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what is now Germany but at the time was another country. # Filter for currently-Germany countries of birth. # Fill in a string value to be sandwiched between the strings \"now\" and \"$\" criteria = { \"bornCountry\" : { ____ : \"now\" + ____ + \"$\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) The prized transistor \u00b6 Three people shared a Nobel prize \"for their researches on semiconductors and their discovery of the transistor effect\". We can filter on \"transistor\" as a substring of a laureate's \"prizes.motivation\" field value to find these laureates. Save a filter criteria that finds laureates with prizes.motivation values containing \"transistor\" as a substring. The substring can appear anywhere within the value, so no anchoring characters are needed. Save to first and last the field names corresponding to a laureate's first name and last name (i.e. \"surname\") so that we can print out the names of these laureates. # Save a filter for laureates with prize motivation values containing \"transistor\" as a substring criteria = { ____ : { ____ : ____ }} # Save the field names corresponding to a laureate's first name and last name first , last = ____ , ____ print ([( laureate [ first ], laureate [ last ]) for laureate in db . laureates . find ( criteria )]) 2: Projection and Sorting \u00b6 Rounding up the G.S. crew \u00b6 We can use the regular expression operator $regex to find laureates whose initials are G.S. Let's use projection and list comprehension to collect the full names of these laureates by concatenating their first (\"firstname\") and last (\"surname\") names. Fill in the blanks to save a list names of full names (\"firstname\" plus \"surname\") of laureates with initials G.S. (ignoring middles names/initials). You'll need to both filter on names as well as project out the fields required to collect the full names. # Collect a list of full names names = [ \" \" . join ([ doc [ ____ ], doc [ ____ ]]) for doc in db . laureates . find ( { ____ : { \"$regex\" : \"^G\" }, ____ : { \"$regex\" : \"^S\" }}, { ____ : 1 , ____ : 1 })] print ( names ) Sorting together: MongoDB + Python \u00b6 You will print out the names of all physics laureates, with one line printed for each award year, in chronological order. Each line will list laureates for that year in alphabetical order by surname (\"last\" name). I encourage you to print intermediate results and understand the nested structure of prize documents. - Construct a sort specification sort_spec to fetch physics prizes by ascending year. from operator import itemgetter # Sort by ascending year sort_spec = [( ____ , ____ )] - Use <collection>.find to construct a cursor that fetches prizes with a \"category\" of \"physics\", sorts by ascending year, and projects the year and first laureate full name ( laureates.firstname and laureates.surname ). You should encounter an error at year 1916 . # Construct a cursor over physics prizes cursor = db . prizes . ____ ({ ____ : ____ }, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - The error is caused by the fact that the Nobel Prize in physics was not awarded in 1916 due to World War I. Supplement the cursor's filter to avoid the error: # Construct a fixed cursor over physics prizes cursor = db . prizes . ____ ({ ____ : ____ , ____ : { ____ : True }}, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - Complete the definition of the function names so that, given a prize document, it returns a list of formatted names, sorted by ascending \"surname\", for each of the \"laureates\" in that prize document. # Define a function names() to return a list of formatted names def names ( doc ): formatted_names = [ \" {firstname} {surname} \" . format ( ** laureate ) for laureate in sorted ( doc [ ____ ], key = itemgetter ( ____ ))] return formatted_names lines = [ \" {year} : {names} \" . format ( year = doc [ \"year\" ], names = \" and \" . join ( names ( doc ))) for doc in cursor ] for line in lines : print ( line ) Gap years \u00b6 As we saw above, there have been years for which prizes in one or more of the original categories were not awarded. Sorting first by reverse chronological order and second by alphabetical order of category, collect and format prize documents to produce one formatted entry per year listing categories missing for that year. - Construct a set original_categories of prize categories awarded in 1901. import itertools from operator import itemgetter # Save the set of prize categories awarded in 1901 original_categories = set ( db . prizes . ____ ( \"category\" , { ____ : \"1901\" })) print ( original_categories ) - Use <collection>.find to construct a cursor that yields prize documents only for categories in the list of original categories which contain the laureates key and thus were awarded, sorted first by decreasing year and second by increasing category. # Construct a cursor over original-category prizes cursor = db . prizes . ____ ({ \"category\" : { ____ : list ( original_categories )}, ____ : { ____ : ____ }}, { \"category\" : 1 , \"year\" : 1 }, sort = [( ____ , ____ ), ( ____ , ____ )]) - Collect a list not_awarded of entries to be printed, one per line, that displays a year and the categories missing for that year. You will collect \"category\" values for each year and set-subtract them from the original categories. # Collect entries for missing prize categories not_awarded = [] for key , group in itertools . groupby ( cursor , key = itemgetter ( \"year\" )): year_categories = set ( prize [ ____ ] for prize in group ) missing = \", \" . join ( sorted ( ____ - ____ )) if missing : not_awarded . append ( \" {} : {} \" . format ( key , missing )) for line in not_awarded : print ( line ) 3: Indexing \u00b6 An index for high-share categories \u00b6 We want to speed up the following operation: db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Confirm that the operation takes approximately 1 ms without an index. - Specify a compound index model index_model to pass to db.prizes.create_index . index_model = [( ____ , ____ ), ( ____ , ____ )] db . prizes . create_index ( index_model ) - Confirm that the execution time is now below 400 \u00b5s. # Drop the index for consistency db . prizes . drop_index ( index_model ) Recently single? \u00b6 A prize might be awarded to a single laureate or to several. For each prize category, report the most recent year that a single laureate -- rather than several -- received a prize in that category. Specify an index model index_model to pass to db.prizes.create_index that speeds up finding prizes by category and sorting results by decreasing year. That is, the model should index first on category (ascending) and second on year (descending). Save a string report for printing the last single-laureate year for each distinct category, one category per line. To do this, for each distinct prize category, find the latest-year prize of that category with a laureate share of \"1\". # Specify an index model for compound sorting index_model = [( ____ , 1 ), ( ____ , - 1 )] db . prizes . create_index ( index_model ) # Collect the last single-laureate year for each category report = \"\" for category in sorted ( db . prizes . ____ ( \"category\" )): doc = db . prizes . find_one ( { ____ : ____ , \"laureates.share\" : \"1\" }, sort = [( ____ , ____ )] ) report += \" {category} : {year} \\n \" . format ( ** doc ) print ( report ) # Drop the index for consistency db . prizes . drop_index ( index_model ) Born and affiliated \u00b6 Some countries are, for one or more laureates, both their country of birth (\"bornCountry\") and a country of affiliation for one or more of their prizes (\"prizes.affiliations.country\"). You will find the five countries of birth with the highest counts of such laureates. Create an index on country of birth (\"bornCountry\") for db.laureates to ensure efficient gathering of distinct values and counting of documents Complete the skeleton dictionary comprehension to construct n_born_and_affiliated , the count of laureates as described above for each distinct country of birth. from collections import Counter # Ensure an index on country of birth db . laureates . create_index ([( ____ , 1 )]) # Collect a count of laureates for each country of birth n_born_and_affiliated = { country : db . laureates . count_documents ({ ____ : ____ , \"prizes.affiliations.country\" : ____ }) for ____ in db . laureates . distinct ( \"bornCountry\" ) } five_most_common = Counter ( n_born_and_affiliated ) . most_common ( 5 ) print ( five_most_common ) # Drop the index for consistency db . laureates . drop_index ([( ____ , 1 )])","title":"Exercises"},{"location":"primer/04_MongoDB_part2/exercises/#mongodb-part-2-exercises","text":"","title":"MongoDB Part 2 Exercises"},{"location":"primer/04_MongoDB_part2/exercises/#1-working-with-distinct-values-elemmatch-and-regex","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel","title":"1: Working with Distinct Values, $elemMatch, and Regex"},{"location":"primer/04_MongoDB_part2/exercises/#never-from-there-but-sometimes-there-at-last","text":"There are some recorded countries of death ( \"diedCountry\" ) that do not appear as a country of birth ( \"bornCountry\" ) for laureates. One such country is \"East Germany\". Return a set of all such countries as countries . # Countries recorded as countries of death but not as countries of birth countries = set ( ____ ) - set ( ____ ) print ( countries )","title":"Never from there, but sometimes there at last"},{"location":"primer/04_MongoDB_part2/exercises/#countries-of-affiliation","text":"We saw in the last exercise that countries can be associated with a laureate as their country of birth and as their country of death. For each prize a laureate received, they may also have been affiliated with an institution at the time, located in a country. Determine the number of distinct countries recorded as part of an affiliation for laureates' prizes. Save this as count . # The number of distinct countries of laureate affiliation for prizes count = ____ ( db . laureates . ____ ( ____ )) print ( count )","title":"Countries of affiliation"},{"location":"primer/04_MongoDB_part2/exercises/#triple-plays-mostly-all-around","text":"All prize categories but one \u2013 literature \u2013 have had prizes shared by three or more laureates. Save a filter document criteria that, when passed to db.prizes.distinct , returns all prize categories shared by three or more laureates. That is, \"laureates.2\" must exist for such documents. Save these prize categories as a Python set called triple_play_categories . Confirm via an assertion that \"literature\" is the only prize category with no prizes shared by three or more laureates. # Save a filter for prize documents with three or more laureates criteria = { ____ : { ____ : ____ }} # Save the set of distinct prize categories in documents satisfying the criteria triple_play_categories = ____ ( db . prizes . distinct ( ____ , criteria )) # Confirm literature as the only category not satisfying the criteria. assert set ( db . prizes . distinct ( ____ )) - triple_play_categories == { ____ }","title":"Triple plays (mostly) all around"},{"location":"primer/04_MongoDB_part2/exercises/#other-sharing-after-world-war-ii","text":"Similar to the example in the lesson, what is the approximate ratio of the number of laureates who won an unshared prize in categories other than physics, chemistry, and medicine after World War II to the number of laureates who won a shared prize in categories other than physics, chemistry, and medicine after World War II? Save an $elemMatch filter unshared to count laureates with unshared prizes in categories other than (\"not in\") [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. Save an $elemMatch filter shared to count laureates with shared (i.e., \"share\" is not \"1\") prizes in categories other than [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { ____ : { ____ : { ____ : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : \"1\" , \"year\" : { ____ : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { ____ : { ____ : { ____ : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : { ____ : \"1\" }, \"year\" : { ____ : \"1945\" }, }}} ratio = db . laureates . ____ ( ____ ) / db . laureates . ____ ( ____ ) print ( ratio )","title":"Other sharing after World War II"},{"location":"primer/04_MongoDB_part2/exercises/#organizations-and-prizes-over-time","text":"How many organizations won prizes before 1945 versus in or after 1945? - Save a filter before to count organization laureates with prizes won before 1945. Recall that organization status is encoded with the \"gender\" field, and that dot notation is needed to access a laureate's \"year\" field within its \"prizes\" array. - Save a filter in_or_after to count organization laureates with prizes won in or after 1945. # Save a filter for organization laureates with prizes won before 1945 before = { ____ : ____ , ____ : { ____ : \"1945\" }, } # Save a filter for organization laureates with prizes won in or after 1945 in_or_after = { ____ : ____ , ____ : { ____ : \"1945\" }, } n_before = db . laureates . count_documents ( before ) n_in_or_after = db . laureates . count_documents ( in_or_after ) ratio = n_in_or_after / ( n_in_or_after + n_before ) print ( ratio )","title":"Organizations and prizes over time"},{"location":"primer/04_MongoDB_part2/exercises/#germany-then-and-now","text":"Just as we saw with Poland, there are laureates who were born somewhere that was in Germany at the time but is now not, and others born somewhere that was not in Germany at the time but now is. - Use a regular expression object to filter for laureates with \"Germany\" in their \"bornCountry\" value. # Filter for laureates with \"Germany\" in their \"bornCountry\" value criteria = { \"bornCountry\" : { \"$regex\" : ____ }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates with a \"bornCountry\" value starting with \"Germany\". # Filter for laureates with a \"bornCountry\" value starting with \"Germany\" criteria = { \"bornCountry\" : { ____ : ____ }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what was at the time Germany but is now another country. # Fill in a string value to be sandwiched between the strings \"^\" and \"now\" criteria = { \"bornCountry\" : { ____ : \"^\" + ____ + \"now\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what is now Germany but at the time was another country. # Filter for currently-Germany countries of birth. # Fill in a string value to be sandwiched between the strings \"now\" and \"$\" criteria = { \"bornCountry\" : { ____ : \"now\" + ____ + \"$\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria )))","title":"Germany, then and now"},{"location":"primer/04_MongoDB_part2/exercises/#the-prized-transistor","text":"Three people shared a Nobel prize \"for their researches on semiconductors and their discovery of the transistor effect\". We can filter on \"transistor\" as a substring of a laureate's \"prizes.motivation\" field value to find these laureates. Save a filter criteria that finds laureates with prizes.motivation values containing \"transistor\" as a substring. The substring can appear anywhere within the value, so no anchoring characters are needed. Save to first and last the field names corresponding to a laureate's first name and last name (i.e. \"surname\") so that we can print out the names of these laureates. # Save a filter for laureates with prize motivation values containing \"transistor\" as a substring criteria = { ____ : { ____ : ____ }} # Save the field names corresponding to a laureate's first name and last name first , last = ____ , ____ print ([( laureate [ first ], laureate [ last ]) for laureate in db . laureates . find ( criteria )])","title":"The prized transistor"},{"location":"primer/04_MongoDB_part2/exercises/#2-projection-and-sorting","text":"","title":"2: Projection and Sorting"},{"location":"primer/04_MongoDB_part2/exercises/#rounding-up-the-gs-crew","text":"We can use the regular expression operator $regex to find laureates whose initials are G.S. Let's use projection and list comprehension to collect the full names of these laureates by concatenating their first (\"firstname\") and last (\"surname\") names. Fill in the blanks to save a list names of full names (\"firstname\" plus \"surname\") of laureates with initials G.S. (ignoring middles names/initials). You'll need to both filter on names as well as project out the fields required to collect the full names. # Collect a list of full names names = [ \" \" . join ([ doc [ ____ ], doc [ ____ ]]) for doc in db . laureates . find ( { ____ : { \"$regex\" : \"^G\" }, ____ : { \"$regex\" : \"^S\" }}, { ____ : 1 , ____ : 1 })] print ( names )","title":"Rounding up the G.S. crew"},{"location":"primer/04_MongoDB_part2/exercises/#sorting-together-mongodb-python","text":"You will print out the names of all physics laureates, with one line printed for each award year, in chronological order. Each line will list laureates for that year in alphabetical order by surname (\"last\" name). I encourage you to print intermediate results and understand the nested structure of prize documents. - Construct a sort specification sort_spec to fetch physics prizes by ascending year. from operator import itemgetter # Sort by ascending year sort_spec = [( ____ , ____ )] - Use <collection>.find to construct a cursor that fetches prizes with a \"category\" of \"physics\", sorts by ascending year, and projects the year and first laureate full name ( laureates.firstname and laureates.surname ). You should encounter an error at year 1916 . # Construct a cursor over physics prizes cursor = db . prizes . ____ ({ ____ : ____ }, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - The error is caused by the fact that the Nobel Prize in physics was not awarded in 1916 due to World War I. Supplement the cursor's filter to avoid the error: # Construct a fixed cursor over physics prizes cursor = db . prizes . ____ ({ ____ : ____ , ____ : { ____ : True }}, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - Complete the definition of the function names so that, given a prize document, it returns a list of formatted names, sorted by ascending \"surname\", for each of the \"laureates\" in that prize document. # Define a function names() to return a list of formatted names def names ( doc ): formatted_names = [ \" {firstname} {surname} \" . format ( ** laureate ) for laureate in sorted ( doc [ ____ ], key = itemgetter ( ____ ))] return formatted_names lines = [ \" {year} : {names} \" . format ( year = doc [ \"year\" ], names = \" and \" . join ( names ( doc ))) for doc in cursor ] for line in lines : print ( line )","title":"Sorting together: MongoDB + Python"},{"location":"primer/04_MongoDB_part2/exercises/#gap-years","text":"As we saw above, there have been years for which prizes in one or more of the original categories were not awarded. Sorting first by reverse chronological order and second by alphabetical order of category, collect and format prize documents to produce one formatted entry per year listing categories missing for that year. - Construct a set original_categories of prize categories awarded in 1901. import itertools from operator import itemgetter # Save the set of prize categories awarded in 1901 original_categories = set ( db . prizes . ____ ( \"category\" , { ____ : \"1901\" })) print ( original_categories ) - Use <collection>.find to construct a cursor that yields prize documents only for categories in the list of original categories which contain the laureates key and thus were awarded, sorted first by decreasing year and second by increasing category. # Construct a cursor over original-category prizes cursor = db . prizes . ____ ({ \"category\" : { ____ : list ( original_categories )}, ____ : { ____ : ____ }}, { \"category\" : 1 , \"year\" : 1 }, sort = [( ____ , ____ ), ( ____ , ____ )]) - Collect a list not_awarded of entries to be printed, one per line, that displays a year and the categories missing for that year. You will collect \"category\" values for each year and set-subtract them from the original categories. # Collect entries for missing prize categories not_awarded = [] for key , group in itertools . groupby ( cursor , key = itemgetter ( \"year\" )): year_categories = set ( prize [ ____ ] for prize in group ) missing = \", \" . join ( sorted ( ____ - ____ )) if missing : not_awarded . append ( \" {} : {} \" . format ( key , missing )) for line in not_awarded : print ( line )","title":"Gap years"},{"location":"primer/04_MongoDB_part2/exercises/#3-indexing","text":"","title":"3: Indexing"},{"location":"primer/04_MongoDB_part2/exercises/#an-index-for-high-share-categories","text":"We want to speed up the following operation: db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Confirm that the operation takes approximately 1 ms without an index. - Specify a compound index model index_model to pass to db.prizes.create_index . index_model = [( ____ , ____ ), ( ____ , ____ )] db . prizes . create_index ( index_model ) - Confirm that the execution time is now below 400 \u00b5s. # Drop the index for consistency db . prizes . drop_index ( index_model )","title":"An index for high-share categories"},{"location":"primer/04_MongoDB_part2/exercises/#recently-single","text":"A prize might be awarded to a single laureate or to several. For each prize category, report the most recent year that a single laureate -- rather than several -- received a prize in that category. Specify an index model index_model to pass to db.prizes.create_index that speeds up finding prizes by category and sorting results by decreasing year. That is, the model should index first on category (ascending) and second on year (descending). Save a string report for printing the last single-laureate year for each distinct category, one category per line. To do this, for each distinct prize category, find the latest-year prize of that category with a laureate share of \"1\". # Specify an index model for compound sorting index_model = [( ____ , 1 ), ( ____ , - 1 )] db . prizes . create_index ( index_model ) # Collect the last single-laureate year for each category report = \"\" for category in sorted ( db . prizes . ____ ( \"category\" )): doc = db . prizes . find_one ( { ____ : ____ , \"laureates.share\" : \"1\" }, sort = [( ____ , ____ )] ) report += \" {category} : {year} \\n \" . format ( ** doc ) print ( report ) # Drop the index for consistency db . prizes . drop_index ( index_model )","title":"Recently single?"},{"location":"primer/04_MongoDB_part2/exercises/#born-and-affiliated","text":"Some countries are, for one or more laureates, both their country of birth (\"bornCountry\") and a country of affiliation for one or more of their prizes (\"prizes.affiliations.country\"). You will find the five countries of birth with the highest counts of such laureates. Create an index on country of birth (\"bornCountry\") for db.laureates to ensure efficient gathering of distinct values and counting of documents Complete the skeleton dictionary comprehension to construct n_born_and_affiliated , the count of laureates as described above for each distinct country of birth. from collections import Counter # Ensure an index on country of birth db . laureates . create_index ([( ____ , 1 )]) # Collect a count of laureates for each country of birth n_born_and_affiliated = { country : db . laureates . count_documents ({ ____ : ____ , \"prizes.affiliations.country\" : ____ }) for ____ in db . laureates . distinct ( \"bornCountry\" ) } five_most_common = Counter ( n_born_and_affiliated ) . most_common ( 5 ) print ( five_most_common ) # Drop the index for consistency db . laureates . drop_index ([( ____ , 1 )])","title":"Born and affiliated"},{"location":"primer/04_MongoDB_part2/exercises_solved/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); MongoDB Part 2 Exercise Solutions \u00b6 1: Working with Distinct Values, $elemMatch, and Regex \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel Never from there, but sometimes there at last \u00b6 There are some recorded countries of death ( \"diedCountry\" ) that do not appear as a country of birth ( \"bornCountry\" ) for laureates. One such country is \"East Germany\". Return a set of all such countries as countries . # Countries recorded as countries of death but not as countries of birth countries = set ( db . laureates . distinct ( \"diedCountry\" )) - set ( db . laureates . distinct ( \"bornCountry\" )) print ( countries ) Countries of affiliation \u00b6 We saw in the last exercise that countries can be associated with a laureate as their country of birth and as their country of death. For each prize a laureate received, they may also have been affiliated with an institution at the time, located in a country. Determine the number of distinct countries recorded as part of an affiliation for laureates' prizes. Save this as count . # The number of distinct countries of laureate affiliation for prizes count = len ( db . laureates . distinct ( \"prizes.affiliations.country\" )) print ( count ) Triple plays (mostly) all around \u00b6 All prize categories but one \u2013 literature \u2013 have had prizes shared by three or more laureates. Save a filter document criteria that, when passed to db.prizes.distinct , returns all prize categories shared by three or more laureates. That is, \"laureates.2\" must exist for such documents. Save these prize categories as a Python set called triple_play_categories . Confirm via an assertion that \"literature\" is the only prize category with no prizes shared by three or more laureates. # Save a filter for prize documents with three or more laureates criteria = { \"laureates.2\" : { \"$exists\" : True }} # Save the set of distinct prize categories in documents satisfying the criteria triple_play_categories = set ( db . prizes . distinct ( \"category\" , criteria )) # Confirm literature as the only category not satisfying the criteria. assert set ( db . prizes . distinct ( \"category\" )) - triple_play_categories == { \"literature\" } Other sharing after World War II \u00b6 Similar to the example in the lesson, what is the approximate ratio of the number of laureates who won an unshared prize in categories other than physics, chemistry, and medicine after World War II to the number of laureates who won a shared prize in categories other than physics, chemistry, and medicine after World War II? Save an $elemMatch filter unshared to count laureates with unshared prizes in categories other than (\"not in\") [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. Save an $elemMatch filter shared to count laureates with shared (i.e., \"share\" is not \"1\") prizes in categories other than [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : { \"$nin\" : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : \"1\" , \"year\" : { \"$gt\" : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : { \"$nin\" : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : { \"$gt\" : \"1\" }, \"year\" : { \"$gt\" : \"1945\" }, }}} ratio = db . laureates . count_documents ( unshared ) / db . laureates . count_documents ( shared ) print ( ratio ) Organizations and prizes over time \u00b6 How many organizations won prizes before 1945 versus in or after 1945? - Save a filter before to count organization laureates with prizes won before 1945. Recall that organization status is encoded with the \"gender\" field, and that dot notation is needed to access a laureate's \"year\" field within its \"prizes\" array. - Save a filter in_or_after to count organization laureates with prizes won in or after 1945. # Save a filter for organization laureates with prizes won before 1945 before = { \"gender\" : \"org\" , \"prizes.year\" : { \"$lt\" : \"1945\" } } # Save a filter for organization laureates with prizes won in or after 1945 in_or_after = { \"gender\" : \"org\" , \"prizes.year\" : { \"$gte\" : \"1945\" } } n_before = db . laureates . count_documents ( before ) n_in_or_after = db . laureates . count_documents ( in_or_after ) ratio = n_in_or_after / ( n_in_or_after + n_before ) print ( ratio ) Germany, then and now \u00b6 Just as we saw with Poland, there are laureates who were born somewhere that was in Germany at the time but is now not, and others born somewhere that was not in Germany at the time but now is. - Use a regular expression object to filter for laureates with \"Germany\" in their \"bornCountry\" value. # Filter for laureates with \"Germany\" in their \"bornCountry\" value criteria = { \"bornCountry\" : { \"$regex\" : \"Germany\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates with a \"bornCountry\" value starting with \"Germany\". # Filter for laureates with a \"bornCountry\" value starting with \"Germany\" criteria = { \"bornCountry\" : { \"$regex\" : \"^Germany\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what was at the time Germany but is now another country. # Fill in a string value to be sandwiched between the strings \"^\" and \"now\" criteria = { \"bornCountry\" : { \"$regex\" : \"^\" + \"Germany \\(\" + \"now\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what is now Germany but at the time was another country. # Filter for currently-Germany countries of birth. # Fill in a string value to be sandwiched between the strings \"now\" and \"$\" criteria = { \"bornCountry\" : { \"$regex\" : \"now\" + \" Germany\\)\" + \"$\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) The prized transistor \u00b6 Three people shared a Nobel prize \"for their researches on semiconductors and their discovery of the transistor effect\". We can filter on \"transistor\" as a substring of a laureate's \"prizes.motivation\" field value to find these laureates. Save a filter criteria that finds laureates with prizes.motivation values containing \"transistor\" as a substring. The substring can appear anywhere within the value, so no anchoring characters are needed. Save to first and last the field names corresponding to a laureate's first name and last name (i.e. \"surname\") so that we can print out the names of these laureates. # Save a filter for laureates with prize motivation values containing \"transistor\" as a substring criteria = { \"prizes.motivation\" : { \"$regex\" : \"transistor\" }} # Save the field names corresponding to a laureate's first name and last name first , last = \"firstname\" , \"surname\" print ([( laureate [ first ], laureate [ last ]) for laureate in db . laureates . find ( criteria )]) 2: Projection and Sorting \u00b6 Rounding up the G.S. crew \u00b6 We can use the regular expression operator $regex to find laureates whose initials are G.S. Let's use projection and list comprehension to collect the full names of these laureates by concatenating their first (\"firstname\") and last (\"surname\") names. Fill in the blanks to save a list names of full names (\"firstname\" plus \"surname\") of laureates with initials G.S. (ignoring middles names/initials). You'll need to both filter on names as well as project out the fields required to collect the full names. # Collect a list of full names names = [ \" \" . join ([ doc [ \"firstname\" ], doc [ \"surname\" ]]) for doc in db . laureates . find ( { \"firstname\" : { \"$regex\" : \"^G\" }, \"surname\" : { \"$regex\" : \"^S\" }}, { \"firstname\" : 1 , \"surname\" : 1 })] print ( names ) Sorting together: MongoDB + Python \u00b6 You will print out the names of all physics laureates, with one line printed for each award year, in chronological order. Each line will list laureates for that year in alphabetical order by surname (\"last\" name). I encourage you to print intermediate results and understand the nested structure of prize documents. - Construct a sort specification sort_spec to fetch physics prizes by ascending year. from operator import itemgetter # Sort by ascending year sort_spec = [( \"year\" , 1 )] - Use <collection>.find to construct a cursor that fetches prizes with a \"category\" of \"physics\", sorts by ascending year, and projects the year and first laureate full name ( laureates.firstname and laureates.surname ). You should encounter an error at year 1916 . # Construct a cursor over physics prizes cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - The error is caused by the fact that the Nobel Prize in physics was not awarded in 1916 due to World War I. Supplement the cursor's filter to avoid the error: # Construct a fixed cursor over physics prizes cursor = db . prizes . find ({ \"category\" : \"physics\" , \"laureates\" : { \"$exists\" : True }}, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - Complete the definition of the function names so that, given a prize document, it returns a list of formatted names, sorted by ascending \"surname\", for each of the \"laureates\" in that prize document. # Define a function names() to return a list of formatted names def names ( doc ): formatted_names = [ \" {firstname} {surname} \" . format ( ** laureate ) for laureate in sorted ( doc [ \"laureates\" ], key = itemgetter ( \"surname\" ))] return formatted_names lines = [ \" {year} : {names} \" . format ( year = doc [ \"year\" ], names = \" and \" . join ( names ( doc ))) for doc in cursor ] for line in lines : print ( line ) Gap years \u00b6 As we saw above, there have been years for which prizes in one or more of the original categories were not awarded. Sorting first by reverse chronological order and second by alphabetical order of category, collect and format prize documents to produce one formatted entry per year listing categories missing for that year. - Construct a set original_categories of prize categories awarded in 1901. import itertools from operator import itemgetter # Save the set of prize categories awarded in 1901 original_categories = set ( db . prizes . distinct ( \"category\" , { \"year\" : \"1901\" })) print ( original_categories ) - Use <collection>.find to construct a cursor that yields prize documents only for categories in the list of original categories which contain the laureates key and thus were awarded, sorted first by decreasing year and second by increasing category. # Construct a cursor over original-category prizes cursor = db . prizes . find ({ \"category\" : { \"$in\" : list ( original_categories )}, \"laureates\" : { \"$exists\" : True }}, { \"category\" : 1 , \"year\" : 1 }, sort = [( \"year\" , - 1 ), ( \"category\" , 1 )]) - Collect a list not_awarded of entries to be printed, one per line, that displays a year and the categories missing for that year. You will collect \"category\" values for each year and set-subtract them from the original categories. # Collect entries for missing prize categories not_awarded = [] for key , group in itertools . groupby ( cursor , key = itemgetter ( \"year\" )): year_categories = set ( prize [ \"category\" ] for prize in group ) missing = \", \" . join ( sorted ( original_categories - year_categories )) if missing : not_awarded . append ( \" {} : {} \" . format ( key , missing )) for line in not_awarded : print ( line ) 3: Indexing \u00b6 An index for high-share categories \u00b6 We want to speed up the following operation: db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Confirm that the operation takes approximately 1 ms without an index. %% timeit db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Specify a compound index model index_model to pass to db.prizes.create_index . index_model = [( \"laureates.share\" , 1 ), ( \"category\" , 1 )] db . prizes . create_index ( index_model ) - Confirm that the execution time is now below 400 \u00b5s. %% timeit db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) # Drop the index for consistency db . prizes . drop_index ( index_model ) Recently single? \u00b6 A prize might be awarded to a single laureate or to several. For each prize category, report the most recent year that a single laureate -- rather than several -- received a prize in that category. Specify an index model index_model to pass to db.prizes.create_index that speeds up finding prizes by category and sorting results by decreasing year. That is, the model should index first on category (ascending) and second on year (descending). Save a string report for printing the last single-laureate year for each distinct category, one category per line. To do this, for each distinct prize category, find the latest-year prize of that category with a laureate share of \"1\". # Specify an index model for compound sorting index_model = [( \"category\" , 1 ), ( \"year\" , - 1 )] db . prizes . create_index ( index_model ) # Collect the last single-laureate year for each category report = \"\" for category in sorted ( db . prizes . distinct ( \"category\" )): doc = db . prizes . find_one ( { \"category\" : category , \"laureates.share\" : \"1\" }, sort = [( \"year\" , - 1 )] ) report += \" {category} : {year} \\n \" . format ( ** doc ) print ( report ) # Drop the index for consistency db . prizes . drop_index ( index_model ) Born and affiliated \u00b6 Some countries are, for one or more laureates, both their country of birth (\"bornCountry\") and a country of affiliation for one or more of their prizes (\"prizes.affiliations.country\"). You will find the five countries of birth with the highest counts of such laureates. Create an index on country of birth (\"bornCountry\") for db.laureates to ensure efficient gathering of distinct values and counting of documents Complete the skeleton dictionary comprehension to construct n_born_and_affiliated , the count of laureates as described above for each distinct country of birth. from collections import Counter # Ensure an index on country of birth db . laureates . create_index ([( \"bornCountry\" , 1 )]) # Collect a count of laureates for each country of birth n_born_and_affiliated = { country : db . laureates . count_documents ({ \"bornCountry\" : country , \"prizes.affiliations.country\" : country }) for country in db . laureates . distinct ( \"bornCountry\" ) } five_most_common = Counter ( n_born_and_affiliated ) . most_common ( 5 ) print ( five_most_common ) # Drop the index for consistency db . laureates . drop_index ([( \"bornCountry\" , 1 )])","title":"Exercises solved"},{"location":"primer/04_MongoDB_part2/exercises_solved/#mongodb-part-2-exercise-solutions","text":"","title":"MongoDB Part 2 Exercise Solutions"},{"location":"primer/04_MongoDB_part2/exercises_solved/#1-working-with-distinct-values-elemmatch-and-regex","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel","title":"1: Working with Distinct Values, $elemMatch, and Regex"},{"location":"primer/04_MongoDB_part2/exercises_solved/#never-from-there-but-sometimes-there-at-last","text":"There are some recorded countries of death ( \"diedCountry\" ) that do not appear as a country of birth ( \"bornCountry\" ) for laureates. One such country is \"East Germany\". Return a set of all such countries as countries . # Countries recorded as countries of death but not as countries of birth countries = set ( db . laureates . distinct ( \"diedCountry\" )) - set ( db . laureates . distinct ( \"bornCountry\" )) print ( countries )","title":"Never from there, but sometimes there at last"},{"location":"primer/04_MongoDB_part2/exercises_solved/#countries-of-affiliation","text":"We saw in the last exercise that countries can be associated with a laureate as their country of birth and as their country of death. For each prize a laureate received, they may also have been affiliated with an institution at the time, located in a country. Determine the number of distinct countries recorded as part of an affiliation for laureates' prizes. Save this as count . # The number of distinct countries of laureate affiliation for prizes count = len ( db . laureates . distinct ( \"prizes.affiliations.country\" )) print ( count )","title":"Countries of affiliation"},{"location":"primer/04_MongoDB_part2/exercises_solved/#triple-plays-mostly-all-around","text":"All prize categories but one \u2013 literature \u2013 have had prizes shared by three or more laureates. Save a filter document criteria that, when passed to db.prizes.distinct , returns all prize categories shared by three or more laureates. That is, \"laureates.2\" must exist for such documents. Save these prize categories as a Python set called triple_play_categories . Confirm via an assertion that \"literature\" is the only prize category with no prizes shared by three or more laureates. # Save a filter for prize documents with three or more laureates criteria = { \"laureates.2\" : { \"$exists\" : True }} # Save the set of distinct prize categories in documents satisfying the criteria triple_play_categories = set ( db . prizes . distinct ( \"category\" , criteria )) # Confirm literature as the only category not satisfying the criteria. assert set ( db . prizes . distinct ( \"category\" )) - triple_play_categories == { \"literature\" }","title":"Triple plays (mostly) all around"},{"location":"primer/04_MongoDB_part2/exercises_solved/#other-sharing-after-world-war-ii","text":"Similar to the example in the lesson, what is the approximate ratio of the number of laureates who won an unshared prize in categories other than physics, chemistry, and medicine after World War II to the number of laureates who won a shared prize in categories other than physics, chemistry, and medicine after World War II? Save an $elemMatch filter unshared to count laureates with unshared prizes in categories other than (\"not in\") [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. Save an $elemMatch filter shared to count laureates with shared (i.e., \"share\" is not \"1\") prizes in categories other than [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : { \"$nin\" : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : \"1\" , \"year\" : { \"$gt\" : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : { \"$nin\" : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : { \"$gt\" : \"1\" }, \"year\" : { \"$gt\" : \"1945\" }, }}} ratio = db . laureates . count_documents ( unshared ) / db . laureates . count_documents ( shared ) print ( ratio )","title":"Other sharing after World War II"},{"location":"primer/04_MongoDB_part2/exercises_solved/#organizations-and-prizes-over-time","text":"How many organizations won prizes before 1945 versus in or after 1945? - Save a filter before to count organization laureates with prizes won before 1945. Recall that organization status is encoded with the \"gender\" field, and that dot notation is needed to access a laureate's \"year\" field within its \"prizes\" array. - Save a filter in_or_after to count organization laureates with prizes won in or after 1945. # Save a filter for organization laureates with prizes won before 1945 before = { \"gender\" : \"org\" , \"prizes.year\" : { \"$lt\" : \"1945\" } } # Save a filter for organization laureates with prizes won in or after 1945 in_or_after = { \"gender\" : \"org\" , \"prizes.year\" : { \"$gte\" : \"1945\" } } n_before = db . laureates . count_documents ( before ) n_in_or_after = db . laureates . count_documents ( in_or_after ) ratio = n_in_or_after / ( n_in_or_after + n_before ) print ( ratio )","title":"Organizations and prizes over time"},{"location":"primer/04_MongoDB_part2/exercises_solved/#germany-then-and-now","text":"Just as we saw with Poland, there are laureates who were born somewhere that was in Germany at the time but is now not, and others born somewhere that was not in Germany at the time but now is. - Use a regular expression object to filter for laureates with \"Germany\" in their \"bornCountry\" value. # Filter for laureates with \"Germany\" in their \"bornCountry\" value criteria = { \"bornCountry\" : { \"$regex\" : \"Germany\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates with a \"bornCountry\" value starting with \"Germany\". # Filter for laureates with a \"bornCountry\" value starting with \"Germany\" criteria = { \"bornCountry\" : { \"$regex\" : \"^Germany\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what was at the time Germany but is now another country. # Fill in a string value to be sandwiched between the strings \"^\" and \"now\" criteria = { \"bornCountry\" : { \"$regex\" : \"^\" + \"Germany \\(\" + \"now\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what is now Germany but at the time was another country. # Filter for currently-Germany countries of birth. # Fill in a string value to be sandwiched between the strings \"now\" and \"$\" criteria = { \"bornCountry\" : { \"$regex\" : \"now\" + \" Germany\\)\" + \"$\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria )))","title":"Germany, then and now"},{"location":"primer/04_MongoDB_part2/exercises_solved/#the-prized-transistor","text":"Three people shared a Nobel prize \"for their researches on semiconductors and their discovery of the transistor effect\". We can filter on \"transistor\" as a substring of a laureate's \"prizes.motivation\" field value to find these laureates. Save a filter criteria that finds laureates with prizes.motivation values containing \"transistor\" as a substring. The substring can appear anywhere within the value, so no anchoring characters are needed. Save to first and last the field names corresponding to a laureate's first name and last name (i.e. \"surname\") so that we can print out the names of these laureates. # Save a filter for laureates with prize motivation values containing \"transistor\" as a substring criteria = { \"prizes.motivation\" : { \"$regex\" : \"transistor\" }} # Save the field names corresponding to a laureate's first name and last name first , last = \"firstname\" , \"surname\" print ([( laureate [ first ], laureate [ last ]) for laureate in db . laureates . find ( criteria )])","title":"The prized transistor"},{"location":"primer/04_MongoDB_part2/exercises_solved/#2-projection-and-sorting","text":"","title":"2: Projection and Sorting"},{"location":"primer/04_MongoDB_part2/exercises_solved/#rounding-up-the-gs-crew","text":"We can use the regular expression operator $regex to find laureates whose initials are G.S. Let's use projection and list comprehension to collect the full names of these laureates by concatenating their first (\"firstname\") and last (\"surname\") names. Fill in the blanks to save a list names of full names (\"firstname\" plus \"surname\") of laureates with initials G.S. (ignoring middles names/initials). You'll need to both filter on names as well as project out the fields required to collect the full names. # Collect a list of full names names = [ \" \" . join ([ doc [ \"firstname\" ], doc [ \"surname\" ]]) for doc in db . laureates . find ( { \"firstname\" : { \"$regex\" : \"^G\" }, \"surname\" : { \"$regex\" : \"^S\" }}, { \"firstname\" : 1 , \"surname\" : 1 })] print ( names )","title":"Rounding up the G.S. crew"},{"location":"primer/04_MongoDB_part2/exercises_solved/#sorting-together-mongodb-python","text":"You will print out the names of all physics laureates, with one line printed for each award year, in chronological order. Each line will list laureates for that year in alphabetical order by surname (\"last\" name). I encourage you to print intermediate results and understand the nested structure of prize documents. - Construct a sort specification sort_spec to fetch physics prizes by ascending year. from operator import itemgetter # Sort by ascending year sort_spec = [( \"year\" , 1 )] - Use <collection>.find to construct a cursor that fetches prizes with a \"category\" of \"physics\", sorts by ascending year, and projects the year and first laureate full name ( laureates.firstname and laureates.surname ). You should encounter an error at year 1916 . # Construct a cursor over physics prizes cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - The error is caused by the fact that the Nobel Prize in physics was not awarded in 1916 due to World War I. Supplement the cursor's filter to avoid the error: # Construct a fixed cursor over physics prizes cursor = db . prizes . find ({ \"category\" : \"physics\" , \"laureates\" : { \"$exists\" : True }}, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - Complete the definition of the function names so that, given a prize document, it returns a list of formatted names, sorted by ascending \"surname\", for each of the \"laureates\" in that prize document. # Define a function names() to return a list of formatted names def names ( doc ): formatted_names = [ \" {firstname} {surname} \" . format ( ** laureate ) for laureate in sorted ( doc [ \"laureates\" ], key = itemgetter ( \"surname\" ))] return formatted_names lines = [ \" {year} : {names} \" . format ( year = doc [ \"year\" ], names = \" and \" . join ( names ( doc ))) for doc in cursor ] for line in lines : print ( line )","title":"Sorting together: MongoDB + Python"},{"location":"primer/04_MongoDB_part2/exercises_solved/#gap-years","text":"As we saw above, there have been years for which prizes in one or more of the original categories were not awarded. Sorting first by reverse chronological order and second by alphabetical order of category, collect and format prize documents to produce one formatted entry per year listing categories missing for that year. - Construct a set original_categories of prize categories awarded in 1901. import itertools from operator import itemgetter # Save the set of prize categories awarded in 1901 original_categories = set ( db . prizes . distinct ( \"category\" , { \"year\" : \"1901\" })) print ( original_categories ) - Use <collection>.find to construct a cursor that yields prize documents only for categories in the list of original categories which contain the laureates key and thus were awarded, sorted first by decreasing year and second by increasing category. # Construct a cursor over original-category prizes cursor = db . prizes . find ({ \"category\" : { \"$in\" : list ( original_categories )}, \"laureates\" : { \"$exists\" : True }}, { \"category\" : 1 , \"year\" : 1 }, sort = [( \"year\" , - 1 ), ( \"category\" , 1 )]) - Collect a list not_awarded of entries to be printed, one per line, that displays a year and the categories missing for that year. You will collect \"category\" values for each year and set-subtract them from the original categories. # Collect entries for missing prize categories not_awarded = [] for key , group in itertools . groupby ( cursor , key = itemgetter ( \"year\" )): year_categories = set ( prize [ \"category\" ] for prize in group ) missing = \", \" . join ( sorted ( original_categories - year_categories )) if missing : not_awarded . append ( \" {} : {} \" . format ( key , missing )) for line in not_awarded : print ( line )","title":"Gap years"},{"location":"primer/04_MongoDB_part2/exercises_solved/#3-indexing","text":"","title":"3: Indexing"},{"location":"primer/04_MongoDB_part2/exercises_solved/#an-index-for-high-share-categories","text":"We want to speed up the following operation: db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Confirm that the operation takes approximately 1 ms without an index. %% timeit db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Specify a compound index model index_model to pass to db.prizes.create_index . index_model = [( \"laureates.share\" , 1 ), ( \"category\" , 1 )] db . prizes . create_index ( index_model ) - Confirm that the execution time is now below 400 \u00b5s. %% timeit db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) # Drop the index for consistency db . prizes . drop_index ( index_model )","title":"An index for high-share categories"},{"location":"primer/04_MongoDB_part2/exercises_solved/#recently-single","text":"A prize might be awarded to a single laureate or to several. For each prize category, report the most recent year that a single laureate -- rather than several -- received a prize in that category. Specify an index model index_model to pass to db.prizes.create_index that speeds up finding prizes by category and sorting results by decreasing year. That is, the model should index first on category (ascending) and second on year (descending). Save a string report for printing the last single-laureate year for each distinct category, one category per line. To do this, for each distinct prize category, find the latest-year prize of that category with a laureate share of \"1\". # Specify an index model for compound sorting index_model = [( \"category\" , 1 ), ( \"year\" , - 1 )] db . prizes . create_index ( index_model ) # Collect the last single-laureate year for each category report = \"\" for category in sorted ( db . prizes . distinct ( \"category\" )): doc = db . prizes . find_one ( { \"category\" : category , \"laureates.share\" : \"1\" }, sort = [( \"year\" , - 1 )] ) report += \" {category} : {year} \\n \" . format ( ** doc ) print ( report ) # Drop the index for consistency db . prizes . drop_index ( index_model )","title":"Recently single?"},{"location":"primer/04_MongoDB_part2/exercises_solved/#born-and-affiliated","text":"Some countries are, for one or more laureates, both their country of birth (\"bornCountry\") and a country of affiliation for one or more of their prizes (\"prizes.affiliations.country\"). You will find the five countries of birth with the highest counts of such laureates. Create an index on country of birth (\"bornCountry\") for db.laureates to ensure efficient gathering of distinct values and counting of documents Complete the skeleton dictionary comprehension to construct n_born_and_affiliated , the count of laureates as described above for each distinct country of birth. from collections import Counter # Ensure an index on country of birth db . laureates . create_index ([( \"bornCountry\" , 1 )]) # Collect a count of laureates for each country of birth n_born_and_affiliated = { country : db . laureates . count_documents ({ \"bornCountry\" : country , \"prizes.affiliations.country\" : country }) for country in db . laureates . distinct ( \"bornCountry\" ) } five_most_common = Counter ( n_born_and_affiliated ) . most_common ( 5 ) print ( five_most_common ) # Drop the index for consistency db . laureates . drop_index ([( \"bornCountry\" , 1 )])","title":"Born and affiliated"},{"location":"primer/04_MongoDB_part2/lesson/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); MongoDB Part 2 \u00b6 1: Working with Distinct Values, $elemMatch, and Regex \u00b6 An exceptional laureate \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel db . laureates . find_one ({ \"prizes.2\" : { \"$exists\" : True }}) {'_id': ObjectId('5f1f4e418defad6d9f1cd070'), 'id': '482', 'firstname': 'International Committee of the Red Cross', 'born': '1863-00-00', 'died': '0000-00-00', 'gender': 'org', 'prizes': [{'year': '1917', 'category': 'peace', 'share': '1', 'motivation': '\"for the efforts to take care of wounded soldiers and prisoners of war and their families\"', 'affiliations': [[]]}, {'year': '1944', 'category': 'peace', 'share': '1', 'motivation': '\"for the great work it has performed during the war on behalf of humanity\"', 'affiliations': [[]]}, {'year': '1963', 'category': 'peace', 'share': '2', 'motivation': '\"for promoting the principles of the Geneva Convention and cooperation with the UN\"', 'affiliations': [[]]}]} Using .distinct() \u00b6 db . laureates . distinct ( \"gender\" ) ['female', 'male', 'org'] A convenience method for a common aggregation (like count_documents ) We will not cover custom aggregations in this lesson, but the aggregate method is powerful. distinct aggregation is efficient if there is a collection index on the field We will learn how to create an index later in this lesson No index needed here: collection fits in memory, has \u2272 1,000 documents All prize categories vs those with multi-winners \u00b6 db . laureates . distinct ( \"prizes.category\" ) ['chemistry', 'economics', 'literature', 'medicine', 'peace', 'physics'] db . laureates . distinct ( \"prizes.category\" ,{ \"prizes.1\" : { \"$exists\" : True }}) ['chemistry', 'peace', 'physics'] Distinct example: Born here, went there \u00b6 In which countries have USA-born laureates had affiliations for their prizes? db . laureates . distinct ( \"prizes.affiliations.country\" ,{ \"bornCountry\" : \"USA\" }) ['Australia', 'Denmark', 'USA', 'United Kingdom'] Enter $elemMatch \u00b6 db . laureates . count_documents ({ \"prizes\" : { \"category\" : \"physics\" , \"share\" : \"1\" } }) 0 Why is the above number zero? db . laureates . count_documents ({ \"prizes.category\" : \"physics\" , \"prizes.share\" : \"1\" }) 48 db . laureates . count_documents ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : \"1\" } } }) 47 Why are these numbers different? db . laureates . find_one ({ \"firstname\" : \"Marie\" }) {'_id': ObjectId('5f1f4e418defad6d9f1cce9a'), 'id': '6', 'firstname': 'Marie', 'surname': 'Curie', 'born': '1867-11-07', 'died': '1934-07-04', 'bornCountry': 'Russian Empire (now Poland)', 'bornCountryCode': 'PL', 'bornCity': 'Warsaw', 'diedCountry': 'France', 'diedCountryCode': 'FR', 'diedCity': 'Sallanches', 'gender': 'female', 'prizes': [{'year': '1903', 'category': 'physics', 'share': '4', 'motivation': '\"in recognition of the extraordinary services they have rendered by their joint researches on the radiation phenomena discovered by Professor Henri Becquerel\"', 'affiliations': [[]]}, {'year': '1911', 'category': 'chemistry', 'share': '1', 'motivation': '\"in recognition of her services to the advancement of chemistry by the discovery of the elements radium and polonium, by the isolation of radium and the study of the nature and compounds of this remarkable element\"', 'affiliations': [{'name': 'Sorbonne University', 'city': 'Paris', 'country': 'France'}]}]} $elemMatch example: Sharing in physics after World War II \u00b6 What is the approximate ratio of the number of laureates who won an unshared , i.e. {\"share\": \"1\"} , prize in physics after World War II, i.e. {\"year\": {\"$gte\": \"1945\"}} , to the number of laureates who won a shared prize in physics after World War II? # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : \"1\" , \"year\" : { \"$gte\" : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : { \"$gt\" : \"1\" }, \"year\" : { \"$gte\" : \"1945\" }, }}} ratio = db . laureates . count_documents ( unshared ) / db . laureates . count_documents ( shared ) print ( ratio ) 0.1232876712328767 Finding a substring with $regex \u00b6 db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"Poland\" }}) ['Austria-Hungary (now Poland)', 'Free City of Danzig (now Poland)', 'German-occupied Poland (now Poland)', 'Germany (now Poland)', 'Poland', 'Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)', 'Prussia (now Poland)', 'Russian Empire (now Poland)'] Beginning and ending \u00b6 db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"^Poland\" }}) ['Poland', 'Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)'] db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"^Poland \\(now\" }}) ['Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)'] db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"now Poland\\)$\" }}) ['Austria-Hungary (now Poland)', 'Free City of Danzig (now Poland)', 'German-occupied Poland (now Poland)', 'Germany (now Poland)', 'Prussia (now Poland)', 'Russian Empire (now Poland)'] Regex example: Glenn, George, and others in the G.S. crew \u00b6 There are two laureates with Berkeley, California as a prize affiliation city that have the initials G.S. - Glenn Seaborg and George Smoot. How many laureates in total have a first name beginning with \"G\" and a surname beginning with \"S\"? db . laureates . count_documents ({ \"firstname\" : { \"$regex\" : \"^G\" }, \"surname\" : { \"$regex\" : \"^S\" }}) 10 2: Projection and Sorting \u00b6 What is \"projection\"? \u00b6 reducing data to fewer dimensions Asking certain data to \"speak up\"! Projection in MongoDB \u00b6 When using db.collection.find() , the first argument is the filter and the second is the projection. db . laureates . find ({}, {}) <pymongo.cursor.Cursor at 0x7f8360632850> Since db.collection.find() returns a cursor, we need to make it into a list: list ( db . laureates . find ({},{}))[: 3 ] [{'_id': ObjectId('5f1f4e418defad6d9f1cce95')}, {'_id': ObjectId('5f1f4e418defad6d9f1cce96')}, {'_id': ObjectId('5f1f4e418defad6d9f1cce97')}] An empty projection dictionary by default only displays the entry \"_id\" field. To project out the prizes.affiliation field without the \"_id\" field, we would use a projection equal to {\"prizes.affiliations\": 1, \"_id\": 0} . list ( db . laureates . find ({},{ \"prizes.affiliations\" : 1 , \"_id\" : 0 }))[: 3 ] [{'prizes': [{'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]}, {'prizes': [{'affiliations': [{'name': 'Leiden University', 'city': 'Leiden', 'country': 'the Netherlands'}]}]}, {'prizes': [{'affiliations': [{'name': 'Amsterdam University', 'city': 'Amsterdam', 'country': 'the Netherlands'}]}]}] where the 1 value turns on \"prizes.affiliations\" and the 0 value turns off \"_id\" . Missing fields \u00b6 list ( db . laureates . find ({ \"gender\" : \"org\" }, { \"firstname\" : 1 , \"born\" : 1 , \"_id\" : 0 })) [{'firstname': 'Institute of International Law', 'born': '1873-00-00'}, {'firstname': 'Permanent International Peace Bureau', 'born': '1891-00-00'}, {'firstname': 'International Committee of the Red Cross', 'born': '1863-00-00'}, {'firstname': 'Nansen International Office for Refugees', 'born': '1921-00-00'}, {'firstname': 'Friends Service Council', 'born': '1647-00-00'}, {'firstname': 'American Friends Service Committee', 'born': '1917-00-00'}, {'firstname': 'Office of the United Nations High Commissioner for Refugees', 'born': '1951-00-00'}, {'firstname': 'League of Red Cross Societies', 'born': '1919-00-00'}, {'firstname': \"United Nations Children's Fund\", 'born': '1946-00-00'}, {'firstname': 'International Labour Organization', 'born': '1919-00-00'}, {'firstname': 'Amnesty International', 'born': '1961-00-00'}, {'firstname': 'International Physicians for the Prevention of Nuclear War', 'born': '1980-00-00'}, {'firstname': 'United Nations Peacekeeping Forces', 'born': '1948-00-00'}, {'firstname': 'Pugwash Conferences on Science and World Affairs', 'born': '1957-00-00'}, {'firstname': 'International Campaign to Ban Landmines', 'born': '1992-00-00'}, {'firstname': 'M\u00e9decins Sans Fronti\u00e8res', 'born': '1971-00-00'}, {'firstname': 'United Nations', 'born': '1945-00-00'}, {'firstname': 'International Atomic Energy Agency', 'born': '1957-00-00'}, {'firstname': 'Grameen Bank', 'born': '1976-00-00'}, {'firstname': 'Intergovernmental Panel on Climate Change', 'born': '1988-00-00'}, {'firstname': 'European Union (EU)', 'born': '1952-00-00'}, {'firstname': 'Organisation for the Prohibition of Chemical Weapons', 'born': '1997-00-00'}, {'firstname': 'National Dialogue Quartet '}, {'firstname': 'International Campaign to Abolish Nuclear Weapons (ICAN)', 'born': '2007-00-00'}] Projection example: Shares of the 1963 prize in physics \u00b6 Let's examine the laureates of the 1963 prize in physics and how they split the prize. Here is a query without projection: db . laureates . find ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"year\" : \"1963\" }}}) How would we fetch the laureates' full names and prize share info? projection = { \"firstname\" : 1 , \"surname\" : 1 , \"prizes.share\" : 1 , \"_id\" : 0 } list ( db . laureates . find ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"year\" : \"1963\" }}}, projection )) [{'firstname': 'Eugene', 'surname': 'Wigner', 'prizes': [{'share': '2'}]}, {'firstname': 'Maria', 'surname': 'Goeppert Mayer', 'prizes': [{'share': '4'}]}, {'firstname': 'J. Hans D.', 'surname': 'Jensen', 'prizes': [{'share': '4'}]}] Sorting post-query with Python \u00b6 from operator import itemgetter docs = list ( db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 })) docs = sorted ( docs , key = itemgetter ( \"year\" )) print ([ doc [ \"year\" ] for doc in docs ][: 5 ]) ['1901', '1902', '1903', '1904', '1905'] docs = sorted ( docs , key = itemgetter ( \"year\" ), reverse = True ) print ([ doc [ \"year\" ] for doc in docs ][: 5 ]) ['2019', '2018', '2017', '2016', '2015'] Sorting in-query with MongoDB \u00b6 cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 }, sort = [( \"year\" , 1 )]) print ([ doc [ \"year\" ] for doc in cursor ][: 5 ]) ['1901', '1902', '1903', '1904', '1905'] cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 }, sort = [( \"year\" , - 1 )]) print ([ doc [ \"year\" ] for doc in cursor ][: 5 ]) ['2019', '2018', '2017', '2016', '2015'] Primary and secondary sorting \u00b6 for doc in db . prizes . find ( { \"year\" : { \"$gt\" : \"1966\" , \"$lt\" : \"1970\" }}, { \"category\" : 1 , \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 ), ( \"category\" , - 1 )]): print ( doc [ \"year\" ], doc [ \"category\" ]) 1967 physics 1967 peace 1967 medicine 1967 literature 1967 chemistry 1968 physics 1968 peace 1968 medicine 1968 literature 1968 chemistry 1969 physics 1969 peace 1969 medicine 1969 literature 1969 economics 1969 chemistry Sorting example: What the sort? \u00b6 This block prints out the first five projections of a sorted query. What \"sort\" argument fills the blank? docs = list ( db . laureates . find ( { \"born\" : { \"$gte\" : \"1900\" }, \"prizes.year\" : { \"$gte\" : \"1954\" }, \"gender\" :{ \"$in\" :[ \"male\" , \"female\" ]}}, { \"born\" : 1 , \"prizes.year\" : 1 , \"_id\" : 0 }, sort = ____ )) for doc in docs [: 5 ]: print ( doc ) {'born': '1916-08-25', 'prizes': [{'year': '1954'}]} {'born': '1915-06-15', 'prizes': [{'year': '1954'}]} {'born': '1901-02-28', 'prizes': [{'year': '1954'}, {'year': '1962'}]} {'born': '1913-07-12', 'prizes': [{'year': '1955'}]} {'born': '1911-01-26', 'prizes': [{'year': '1955'}]} Primary sorting is ascending by \"prizes.year\" . Secondary sort is descending by \"born\" . Thus, sort= [(\"prizes.year\",1),(\"born\",-1)] . my_sort = [( \"prizes.year\" , 1 ),( \"born\" , - 1 )] docs = list ( db . laureates . find ( { \"born\" : { \"$gte\" : \"1900\" }, \"prizes.year\" : { \"$gte\" : \"1954\" }, \"gender\" :{ \"$in\" :[ \"male\" , \"female\" ]}}, { \"born\" : 1 , \"prizes.year\" : 1 , \"_id\" : 0 }, sort = my_sort )) for doc in docs [: 5 ]: print ( doc ) {'born': '1916-08-25', 'prizes': [{'year': '1954'}]} {'born': '1915-06-15', 'prizes': [{'year': '1954'}]} {'born': '1901-02-28', 'prizes': [{'year': '1962'}, {'year': '1954'}]} {'born': '1913-07-12', 'prizes': [{'year': '1955'}]} {'born': '1911-01-26', 'prizes': [{'year': '1955'}]} 3: Indexing \u00b6 What are indexes? \u00b6 When to use indexes? \u00b6 Queries with high specificity Large documents Large collections Getting index information \u00b6 db . prizes . index_information () {'_id_': {'v': 2, 'key': [('_id', 1)], 'ns': 'nobel.prizes'}} Gauging performance before indexing \u00b6 Jupyter Notebook %%timeit magic (same as python -m timeit \"[expression]\" ) %% timeit docs = list ( db . prizes . find ({ \"year\" : \"1901\" })) 577 \u00b5s \u00b1 22.4 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , 1 )])) 5 ms \u00b1 269 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.79 ms \u00b1 400 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) Adding a single-field index \u00b6 * index model: list of (field, direction) pairs. * directions: 1 (ascending) and -1 (descending) db . prizes . create_index ([( \"year\" , 1 )]) 'year_1' db . prizes . index_information () {'_id_': {'v': 2, 'key': [('_id', 1)], 'ns': 'nobel.prizes'}, 'year_1': {'v': 2, 'key': [('year', 1)], 'ns': 'nobel.prizes'}} %% timeit docs = list ( db . prizes . find ({ \"year\" : \"1901\" })) 330 \u00b5s \u00b1 12.1 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , 1 )])) 3.89 ms \u00b1 122 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.07 ms \u00b1 122 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) db . prizes . drop_index ([( \"year\" , 1 )]) db . prizes . create_index ([( \"year\" , - 1 )]) 'year_-1' %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.36 ms \u00b1 249 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) db . prizes . drop_index ([( \"year\" , - 1 )]) Adding a compound (multiple-field) index \u00b6 index \"covering\" a query with projection %% timeit list ( db . prizes . find ({ \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 })) 620 \u00b5s \u00b1 3.05 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . create_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) 'category_1_year_1' %% timeit list ( db . prizes . find ({ \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 })) 435 \u00b5s \u00b1 12.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . drop_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) * index \"covering\" a query with projection and sorting %% timeit db . prizes . find_one ( { \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 )] ) 698 \u00b5s \u00b1 62.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . create_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) 'category_1_year_1' %% timeit db . prizes . find_one ( { \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 )] ) 504 \u00b5s \u00b1 17.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . drop_index ([( \"category\" , 1 ), ( \"year\" , 1 )])","title":"Advanced MongoDB"},{"location":"primer/04_MongoDB_part2/lesson/#mongodb-part-2","text":"","title":"MongoDB Part 2"},{"location":"primer/04_MongoDB_part2/lesson/#1-working-with-distinct-values-elemmatch-and-regex","text":"","title":"1: Working with Distinct Values, $elemMatch, and Regex"},{"location":"primer/04_MongoDB_part2/lesson/#an-exceptional-laureate","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel db . laureates . find_one ({ \"prizes.2\" : { \"$exists\" : True }}) {'_id': ObjectId('5f1f4e418defad6d9f1cd070'), 'id': '482', 'firstname': 'International Committee of the Red Cross', 'born': '1863-00-00', 'died': '0000-00-00', 'gender': 'org', 'prizes': [{'year': '1917', 'category': 'peace', 'share': '1', 'motivation': '\"for the efforts to take care of wounded soldiers and prisoners of war and their families\"', 'affiliations': [[]]}, {'year': '1944', 'category': 'peace', 'share': '1', 'motivation': '\"for the great work it has performed during the war on behalf of humanity\"', 'affiliations': [[]]}, {'year': '1963', 'category': 'peace', 'share': '2', 'motivation': '\"for promoting the principles of the Geneva Convention and cooperation with the UN\"', 'affiliations': [[]]}]}","title":"An exceptional laureate"},{"location":"primer/04_MongoDB_part2/lesson/#using-distinct","text":"db . laureates . distinct ( \"gender\" ) ['female', 'male', 'org'] A convenience method for a common aggregation (like count_documents ) We will not cover custom aggregations in this lesson, but the aggregate method is powerful. distinct aggregation is efficient if there is a collection index on the field We will learn how to create an index later in this lesson No index needed here: collection fits in memory, has \u2272 1,000 documents","title":"Using .distinct()"},{"location":"primer/04_MongoDB_part2/lesson/#all-prize-categories-vs-those-with-multi-winners","text":"db . laureates . distinct ( \"prizes.category\" ) ['chemistry', 'economics', 'literature', 'medicine', 'peace', 'physics'] db . laureates . distinct ( \"prizes.category\" ,{ \"prizes.1\" : { \"$exists\" : True }}) ['chemistry', 'peace', 'physics']","title":"All prize categories vs those with multi-winners"},{"location":"primer/04_MongoDB_part2/lesson/#distinct-example-born-here-went-there","text":"In which countries have USA-born laureates had affiliations for their prizes? db . laureates . distinct ( \"prizes.affiliations.country\" ,{ \"bornCountry\" : \"USA\" }) ['Australia', 'Denmark', 'USA', 'United Kingdom']","title":"Distinct example: Born here, went there"},{"location":"primer/04_MongoDB_part2/lesson/#enter-elemmatch","text":"db . laureates . count_documents ({ \"prizes\" : { \"category\" : \"physics\" , \"share\" : \"1\" } }) 0 Why is the above number zero? db . laureates . count_documents ({ \"prizes.category\" : \"physics\" , \"prizes.share\" : \"1\" }) 48 db . laureates . count_documents ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : \"1\" } } }) 47 Why are these numbers different? db . laureates . find_one ({ \"firstname\" : \"Marie\" }) {'_id': ObjectId('5f1f4e418defad6d9f1cce9a'), 'id': '6', 'firstname': 'Marie', 'surname': 'Curie', 'born': '1867-11-07', 'died': '1934-07-04', 'bornCountry': 'Russian Empire (now Poland)', 'bornCountryCode': 'PL', 'bornCity': 'Warsaw', 'diedCountry': 'France', 'diedCountryCode': 'FR', 'diedCity': 'Sallanches', 'gender': 'female', 'prizes': [{'year': '1903', 'category': 'physics', 'share': '4', 'motivation': '\"in recognition of the extraordinary services they have rendered by their joint researches on the radiation phenomena discovered by Professor Henri Becquerel\"', 'affiliations': [[]]}, {'year': '1911', 'category': 'chemistry', 'share': '1', 'motivation': '\"in recognition of her services to the advancement of chemistry by the discovery of the elements radium and polonium, by the isolation of radium and the study of the nature and compounds of this remarkable element\"', 'affiliations': [{'name': 'Sorbonne University', 'city': 'Paris', 'country': 'France'}]}]}","title":"Enter $elemMatch"},{"location":"primer/04_MongoDB_part2/lesson/#elemmatch-example-sharing-in-physics-after-world-war-ii","text":"What is the approximate ratio of the number of laureates who won an unshared , i.e. {\"share\": \"1\"} , prize in physics after World War II, i.e. {\"year\": {\"$gte\": \"1945\"}} , to the number of laureates who won a shared prize in physics after World War II? # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : \"1\" , \"year\" : { \"$gte\" : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : { \"$gt\" : \"1\" }, \"year\" : { \"$gte\" : \"1945\" }, }}} ratio = db . laureates . count_documents ( unshared ) / db . laureates . count_documents ( shared ) print ( ratio ) 0.1232876712328767","title":"$elemMatch example: Sharing in physics after World War II"},{"location":"primer/04_MongoDB_part2/lesson/#finding-a-substring-with-regex","text":"db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"Poland\" }}) ['Austria-Hungary (now Poland)', 'Free City of Danzig (now Poland)', 'German-occupied Poland (now Poland)', 'Germany (now Poland)', 'Poland', 'Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)', 'Prussia (now Poland)', 'Russian Empire (now Poland)']","title":"Finding a substring with $regex"},{"location":"primer/04_MongoDB_part2/lesson/#beginning-and-ending","text":"db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"^Poland\" }}) ['Poland', 'Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)'] db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"^Poland \\(now\" }}) ['Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)'] db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"now Poland\\)$\" }}) ['Austria-Hungary (now Poland)', 'Free City of Danzig (now Poland)', 'German-occupied Poland (now Poland)', 'Germany (now Poland)', 'Prussia (now Poland)', 'Russian Empire (now Poland)']","title":"Beginning and ending"},{"location":"primer/04_MongoDB_part2/lesson/#regex-example-glenn-george-and-others-in-the-gs-crew","text":"There are two laureates with Berkeley, California as a prize affiliation city that have the initials G.S. - Glenn Seaborg and George Smoot. How many laureates in total have a first name beginning with \"G\" and a surname beginning with \"S\"? db . laureates . count_documents ({ \"firstname\" : { \"$regex\" : \"^G\" }, \"surname\" : { \"$regex\" : \"^S\" }}) 10","title":"Regex example: Glenn, George, and others in the G.S. crew"},{"location":"primer/04_MongoDB_part2/lesson/#2-projection-and-sorting","text":"","title":"2: Projection and Sorting"},{"location":"primer/04_MongoDB_part2/lesson/#what-is-projection","text":"reducing data to fewer dimensions Asking certain data to \"speak up\"!","title":"What is \"projection\"?"},{"location":"primer/04_MongoDB_part2/lesson/#projection-in-mongodb","text":"When using db.collection.find() , the first argument is the filter and the second is the projection. db . laureates . find ({}, {}) <pymongo.cursor.Cursor at 0x7f8360632850> Since db.collection.find() returns a cursor, we need to make it into a list: list ( db . laureates . find ({},{}))[: 3 ] [{'_id': ObjectId('5f1f4e418defad6d9f1cce95')}, {'_id': ObjectId('5f1f4e418defad6d9f1cce96')}, {'_id': ObjectId('5f1f4e418defad6d9f1cce97')}] An empty projection dictionary by default only displays the entry \"_id\" field. To project out the prizes.affiliation field without the \"_id\" field, we would use a projection equal to {\"prizes.affiliations\": 1, \"_id\": 0} . list ( db . laureates . find ({},{ \"prizes.affiliations\" : 1 , \"_id\" : 0 }))[: 3 ] [{'prizes': [{'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]}, {'prizes': [{'affiliations': [{'name': 'Leiden University', 'city': 'Leiden', 'country': 'the Netherlands'}]}]}, {'prizes': [{'affiliations': [{'name': 'Amsterdam University', 'city': 'Amsterdam', 'country': 'the Netherlands'}]}]}] where the 1 value turns on \"prizes.affiliations\" and the 0 value turns off \"_id\" .","title":"Projection in MongoDB"},{"location":"primer/04_MongoDB_part2/lesson/#missing-fields","text":"list ( db . laureates . find ({ \"gender\" : \"org\" }, { \"firstname\" : 1 , \"born\" : 1 , \"_id\" : 0 })) [{'firstname': 'Institute of International Law', 'born': '1873-00-00'}, {'firstname': 'Permanent International Peace Bureau', 'born': '1891-00-00'}, {'firstname': 'International Committee of the Red Cross', 'born': '1863-00-00'}, {'firstname': 'Nansen International Office for Refugees', 'born': '1921-00-00'}, {'firstname': 'Friends Service Council', 'born': '1647-00-00'}, {'firstname': 'American Friends Service Committee', 'born': '1917-00-00'}, {'firstname': 'Office of the United Nations High Commissioner for Refugees', 'born': '1951-00-00'}, {'firstname': 'League of Red Cross Societies', 'born': '1919-00-00'}, {'firstname': \"United Nations Children's Fund\", 'born': '1946-00-00'}, {'firstname': 'International Labour Organization', 'born': '1919-00-00'}, {'firstname': 'Amnesty International', 'born': '1961-00-00'}, {'firstname': 'International Physicians for the Prevention of Nuclear War', 'born': '1980-00-00'}, {'firstname': 'United Nations Peacekeeping Forces', 'born': '1948-00-00'}, {'firstname': 'Pugwash Conferences on Science and World Affairs', 'born': '1957-00-00'}, {'firstname': 'International Campaign to Ban Landmines', 'born': '1992-00-00'}, {'firstname': 'M\u00e9decins Sans Fronti\u00e8res', 'born': '1971-00-00'}, {'firstname': 'United Nations', 'born': '1945-00-00'}, {'firstname': 'International Atomic Energy Agency', 'born': '1957-00-00'}, {'firstname': 'Grameen Bank', 'born': '1976-00-00'}, {'firstname': 'Intergovernmental Panel on Climate Change', 'born': '1988-00-00'}, {'firstname': 'European Union (EU)', 'born': '1952-00-00'}, {'firstname': 'Organisation for the Prohibition of Chemical Weapons', 'born': '1997-00-00'}, {'firstname': 'National Dialogue Quartet '}, {'firstname': 'International Campaign to Abolish Nuclear Weapons (ICAN)', 'born': '2007-00-00'}]","title":"Missing fields"},{"location":"primer/04_MongoDB_part2/lesson/#projection-example-shares-of-the-1963-prize-in-physics","text":"Let's examine the laureates of the 1963 prize in physics and how they split the prize. Here is a query without projection: db . laureates . find ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"year\" : \"1963\" }}}) How would we fetch the laureates' full names and prize share info? projection = { \"firstname\" : 1 , \"surname\" : 1 , \"prizes.share\" : 1 , \"_id\" : 0 } list ( db . laureates . find ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"year\" : \"1963\" }}}, projection )) [{'firstname': 'Eugene', 'surname': 'Wigner', 'prizes': [{'share': '2'}]}, {'firstname': 'Maria', 'surname': 'Goeppert Mayer', 'prizes': [{'share': '4'}]}, {'firstname': 'J. Hans D.', 'surname': 'Jensen', 'prizes': [{'share': '4'}]}]","title":"Projection example: Shares of the 1963 prize in physics"},{"location":"primer/04_MongoDB_part2/lesson/#sorting-post-query-with-python","text":"from operator import itemgetter docs = list ( db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 })) docs = sorted ( docs , key = itemgetter ( \"year\" )) print ([ doc [ \"year\" ] for doc in docs ][: 5 ]) ['1901', '1902', '1903', '1904', '1905'] docs = sorted ( docs , key = itemgetter ( \"year\" ), reverse = True ) print ([ doc [ \"year\" ] for doc in docs ][: 5 ]) ['2019', '2018', '2017', '2016', '2015']","title":"Sorting post-query with Python"},{"location":"primer/04_MongoDB_part2/lesson/#sorting-in-query-with-mongodb","text":"cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 }, sort = [( \"year\" , 1 )]) print ([ doc [ \"year\" ] for doc in cursor ][: 5 ]) ['1901', '1902', '1903', '1904', '1905'] cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 }, sort = [( \"year\" , - 1 )]) print ([ doc [ \"year\" ] for doc in cursor ][: 5 ]) ['2019', '2018', '2017', '2016', '2015']","title":"Sorting in-query with MongoDB"},{"location":"primer/04_MongoDB_part2/lesson/#primary-and-secondary-sorting","text":"for doc in db . prizes . find ( { \"year\" : { \"$gt\" : \"1966\" , \"$lt\" : \"1970\" }}, { \"category\" : 1 , \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 ), ( \"category\" , - 1 )]): print ( doc [ \"year\" ], doc [ \"category\" ]) 1967 physics 1967 peace 1967 medicine 1967 literature 1967 chemistry 1968 physics 1968 peace 1968 medicine 1968 literature 1968 chemistry 1969 physics 1969 peace 1969 medicine 1969 literature 1969 economics 1969 chemistry","title":"Primary and secondary sorting"},{"location":"primer/04_MongoDB_part2/lesson/#sorting-example-what-the-sort","text":"This block prints out the first five projections of a sorted query. What \"sort\" argument fills the blank? docs = list ( db . laureates . find ( { \"born\" : { \"$gte\" : \"1900\" }, \"prizes.year\" : { \"$gte\" : \"1954\" }, \"gender\" :{ \"$in\" :[ \"male\" , \"female\" ]}}, { \"born\" : 1 , \"prizes.year\" : 1 , \"_id\" : 0 }, sort = ____ )) for doc in docs [: 5 ]: print ( doc ) {'born': '1916-08-25', 'prizes': [{'year': '1954'}]} {'born': '1915-06-15', 'prizes': [{'year': '1954'}]} {'born': '1901-02-28', 'prizes': [{'year': '1954'}, {'year': '1962'}]} {'born': '1913-07-12', 'prizes': [{'year': '1955'}]} {'born': '1911-01-26', 'prizes': [{'year': '1955'}]} Primary sorting is ascending by \"prizes.year\" . Secondary sort is descending by \"born\" . Thus, sort= [(\"prizes.year\",1),(\"born\",-1)] . my_sort = [( \"prizes.year\" , 1 ),( \"born\" , - 1 )] docs = list ( db . laureates . find ( { \"born\" : { \"$gte\" : \"1900\" }, \"prizes.year\" : { \"$gte\" : \"1954\" }, \"gender\" :{ \"$in\" :[ \"male\" , \"female\" ]}}, { \"born\" : 1 , \"prizes.year\" : 1 , \"_id\" : 0 }, sort = my_sort )) for doc in docs [: 5 ]: print ( doc ) {'born': '1916-08-25', 'prizes': [{'year': '1954'}]} {'born': '1915-06-15', 'prizes': [{'year': '1954'}]} {'born': '1901-02-28', 'prizes': [{'year': '1962'}, {'year': '1954'}]} {'born': '1913-07-12', 'prizes': [{'year': '1955'}]} {'born': '1911-01-26', 'prizes': [{'year': '1955'}]}","title":"Sorting example: What the sort?"},{"location":"primer/04_MongoDB_part2/lesson/#3-indexing","text":"","title":"3: Indexing"},{"location":"primer/04_MongoDB_part2/lesson/#what-are-indexes","text":"","title":"What are indexes?"},{"location":"primer/04_MongoDB_part2/lesson/#when-to-use-indexes","text":"Queries with high specificity Large documents Large collections","title":"When to use indexes?"},{"location":"primer/04_MongoDB_part2/lesson/#getting-index-information","text":"db . prizes . index_information () {'_id_': {'v': 2, 'key': [('_id', 1)], 'ns': 'nobel.prizes'}}","title":"Getting index information"},{"location":"primer/04_MongoDB_part2/lesson/#gauging-performance-before-indexing","text":"Jupyter Notebook %%timeit magic (same as python -m timeit \"[expression]\" ) %% timeit docs = list ( db . prizes . find ({ \"year\" : \"1901\" })) 577 \u00b5s \u00b1 22.4 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , 1 )])) 5 ms \u00b1 269 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.79 ms \u00b1 400 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)","title":"Gauging performance before indexing"},{"location":"primer/04_MongoDB_part2/lesson/#adding-a-single-field-index","text":"* index model: list of (field, direction) pairs. * directions: 1 (ascending) and -1 (descending) db . prizes . create_index ([( \"year\" , 1 )]) 'year_1' db . prizes . index_information () {'_id_': {'v': 2, 'key': [('_id', 1)], 'ns': 'nobel.prizes'}, 'year_1': {'v': 2, 'key': [('year', 1)], 'ns': 'nobel.prizes'}} %% timeit docs = list ( db . prizes . find ({ \"year\" : \"1901\" })) 330 \u00b5s \u00b1 12.1 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , 1 )])) 3.89 ms \u00b1 122 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.07 ms \u00b1 122 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) db . prizes . drop_index ([( \"year\" , 1 )]) db . prizes . create_index ([( \"year\" , - 1 )]) 'year_-1' %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.36 ms \u00b1 249 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) db . prizes . drop_index ([( \"year\" , - 1 )])","title":"Adding a single-field index"},{"location":"primer/04_MongoDB_part2/lesson/#adding-a-compound-multiple-field-index","text":"index \"covering\" a query with projection %% timeit list ( db . prizes . find ({ \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 })) 620 \u00b5s \u00b1 3.05 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . create_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) 'category_1_year_1' %% timeit list ( db . prizes . find ({ \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 })) 435 \u00b5s \u00b1 12.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . drop_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) * index \"covering\" a query with projection and sorting %% timeit db . prizes . find_one ( { \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 )] ) 698 \u00b5s \u00b1 62.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . create_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) 'category_1_year_1' %% timeit db . prizes . find_one ( { \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 )] ) 504 \u00b5s \u00b1 17.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . drop_index ([( \"category\" , 1 ), ( \"year\" , 1 )])","title":"Adding a compound (multiple-field) index"}]}